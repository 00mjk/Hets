<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--Rendered using the Haskell Html Library v0.2-->
<HTML
><HEAD
  ><TITLE
    >Control.Monad.State</TITLE
    ><LINK HREF = "haddock.css" REL = "stylesheet" TYPE = "text/css"
    ></HEAD
  ><BODY
  ><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
    ><TR
      ><TD CLASS = "topbar"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD
	      ><IMG SRC = "haskell_icon.gif" WIDTH = "16" HEIGHT = "16" ALT = " "
		></TD
	      ><TD CLASS = "title"
	      >Haskell Hierarchical Libraries (base package)</TD
	      ><TD CLASS = "topbut"
	      ><A HREF = "index.html"
		>Contents</A
		></TD
	      ><TD CLASS = "topbut"
	      ><A HREF = "doc-index.html"
		>Index</A
		></TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "modulebar"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD
	      ><FONT SIZE = "6"
		>Control.Monad.State</FONT
		></TD
	      ><TD ALIGN = "right"
	      ><TABLE CLASS = "narrow" CELLSPACING = "0" CELLPADDING = "0"
		><TR
		  ><TD CLASS = "infohead"
		    >Portability</TD
		    ><TD CLASS = "infoval"
		    >  non-portable (multi-param classes, functional dependencies)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "infohead"
		    >Stability</TD
		    ><TD CLASS = "infoval"
		    >  experimental</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "infohead"
		    >Maintainer</TD
		    ><TD CLASS = "infoval"
		    >  libraries@haskell.org</TD
		    ></TR
		  ></TABLE
		></TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD CLASS = "section4"
	      ><B
		>Contents</B
		></TD
	      ></TR
	    ><TR
	    ><TD
	      ><DL
		><DT
		  ><A HREF = "#1"
		    >MonadState class</A
		    ></DT
		  ><DT
		  ><A HREF = "#2"
		    >The State Monad</A
		    ></DT
		  ><DT
		  ><A HREF = "#3"
		    >The StateT Monad</A
		    ></DT
		  ><DT
		  ><A HREF = "#4"
		    >Examples</A
		    ></DT
		  ></DL
		></TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	>Description</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >State monads.
</P
	  ><P
	  >This module is inspired by the paper
<EM
	    >Functional Programming with Overloading and
Higher-Order Polymorphism</EM
	    >, 
Mark P Jones (<A HREF = "http://www.cse.ogi.edu/~mpj/"
	    >http://www.cse.ogi.edu/~mpj/</A
	    >)
Advanced School of Functional Programming, 1995.
</P
	  ><P
	  >See below for examples.</P
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	>Synopsis</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "body"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD CLASS = "decl"
	      ><SPAN CLASS = "keyword"
		>class</SPAN
		> <A HREF = "GHC.Base.html#t%3AMonad"
		>Monad</A
		> m =&gt; <A HREF = "#t%3AMonadState"
		>MonadState</A
		> s m | m -&gt; s <SPAN CLASS = "keyword"
		>where</SPAN
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "body"
	      ><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
		><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "#v%3Aget"
		      >get</A
		      > :: m s</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "#v%3Aput"
		      >put</A
		      > :: s -&gt; m ()</TD
		    ></TR
		  ></TABLE
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Amodify"
		>modify</A
		> :: <A HREF = "Control.Monad.State.html#t%3AMonadState"
		>MonadState</A
		> s m =&gt; (s -&gt; s) -&gt; m ()</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Agets"
		>gets</A
		> :: <A HREF = "Control.Monad.State.html#t%3AMonadState"
		>MonadState</A
		> s m =&gt; (s -&gt; a) -&gt; m a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><SPAN CLASS = "keyword"
		>newtype</SPAN
		> <A HREF = "#t%3AState"
		>State</A
		> s a = <A HREF = "#v%3AState"
		>State</A
		> {<TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
		><TR
		  ><TD CLASS = "recfield"
		    ><A HREF = "#v%3ArunState"
		      >runState</A
		      > :: (s -&gt; (a, s))</TD
		    ></TR
		  ></TABLE
		>}</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AevalState"
		>evalState</A
		> :: <A HREF = "Control.Monad.State.html#t%3AState"
		>State</A
		> s a -&gt; s -&gt; a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AexecState"
		>execState</A
		> :: <A HREF = "Control.Monad.State.html#t%3AState"
		>State</A
		> s a -&gt; s -&gt; s</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AmapState"
		>mapState</A
		> :: ((a, s) -&gt; (b, s)) -&gt; <A HREF = "Control.Monad.State.html#t%3AState"
		>State</A
		> s a -&gt; <A HREF = "Control.Monad.State.html#t%3AState"
		>State</A
		> s b</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AwithState"
		>withState</A
		> :: (s -&gt; s) -&gt; <A HREF = "Control.Monad.State.html#t%3AState"
		>State</A
		> s a -&gt; <A HREF = "Control.Monad.State.html#t%3AState"
		>State</A
		> s a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><SPAN CLASS = "keyword"
		>newtype</SPAN
		> <A HREF = "#t%3AStateT"
		>StateT</A
		> s m a = <A HREF = "#v%3AStateT"
		>StateT</A
		> {<TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
		><TR
		  ><TD CLASS = "recfield"
		    ><A HREF = "#v%3ArunStateT"
		      >runStateT</A
		      > :: (s -&gt; m (a, s))</TD
		    ></TR
		  ></TABLE
		>}</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AevalStateT"
		>evalStateT</A
		> :: <A HREF = "GHC.Base.html#t%3AMonad"
		>Monad</A
		> m =&gt; <A HREF = "Control.Monad.State.html#t%3AStateT"
		>StateT</A
		> s m a -&gt; s -&gt; m a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AexecStateT"
		>execStateT</A
		> :: <A HREF = "GHC.Base.html#t%3AMonad"
		>Monad</A
		> m =&gt; <A HREF = "Control.Monad.State.html#t%3AStateT"
		>StateT</A
		> s m a -&gt; s -&gt; m s</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AmapStateT"
		>mapStateT</A
		> :: (m (a, s) -&gt; n (b, s)) -&gt; <A HREF = "Control.Monad.State.html#t%3AStateT"
		>StateT</A
		> s m a -&gt; <A HREF = "Control.Monad.State.html#t%3AStateT"
		>StateT</A
		> s n b</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AwithStateT"
		>withStateT</A
		> :: (s -&gt; s) -&gt; <A HREF = "Control.Monad.State.html#t%3AStateT"
		>StateT</A
		> s m a -&gt; <A HREF = "Control.Monad.State.html#t%3AStateT"
		>StateT</A
		> s m a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      >module <A HREF = "Control.Monad.html"
		>Control.Monad</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      >module <A HREF = "Control.Monad.Fix.html"
		>Control.Monad.Fix</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      >module <A HREF = "Control.Monad.Trans.html"
		>Control.Monad.Trans</A
		></TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "1"
	  >MonadState class</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><SPAN CLASS = "keyword"
	  >class</SPAN
	  > <A HREF = "GHC.Base.html#t%3AMonad"
	  >Monad</A
	  > m =&gt; <A NAME = "t%3AMonadState"
	  ></A
	  ><B
	  >MonadState</B
	  > s m | m -&gt; s <SPAN CLASS = "keyword"
	  >where</SPAN
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "body"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD CLASS = "ndoc"
	      ><P
		><EM
		  >get</EM
		  > returns the state from the internals of the monad.
</P
		><P
		><EM
		  >put</EM
		  > replaces the state inside the monad.</P
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "section4"
	      >Methods</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "body"
	      ><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
		><TR
		  ><TD CLASS = "decl"
		    ><A NAME = "v%3Aget"
		      ></A
		      ><B
		      >get</B
		      > :: m s</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "s8"
		    ></TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A NAME = "v%3Aput"
		      ></A
		      ><B
		      >put</B
		      > :: s -&gt; m ()</TD
		    ></TR
		  ></TABLE
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "section4"
	      >Instances</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "body"
	      ><TABLE CLASS = "vanilla" CELLSPACING = "1" CELLPADDING = "0"
		><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s m =&gt; <A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s (<A HREF = "Control.Monad.Cont.html#t%3AContT"
		      >ContT</A
		      > r m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    >(<A HREF = "Control.Monad.Error.html#t%3AError"
		      >Error</A
		      > e, <A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s m) =&gt; <A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s (<A HREF = "Control.Monad.Error.html#t%3AErrorT"
		      >ErrorT</A
		      > e m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s m =&gt; <A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s (<A HREF = "Control.Monad.List.html#t%3AListT"
		      >ListT</A
		      > m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Data.Monoid.html#t%3AMonoid"
		      >Monoid</A
		      > w =&gt; <A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s (<A HREF = "Control.Monad.RWS.html#t%3ARWS"
		      >RWS</A
		      > r w s)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    >(<A HREF = "Data.Monoid.html#t%3AMonoid"
		      >Monoid</A
		      > w, <A HREF = "GHC.Base.html#t%3AMonad"
		      >Monad</A
		      > m) =&gt; <A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s (<A HREF = "Control.Monad.RWS.html#t%3ARWST"
		      >RWST</A
		      > r w s m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s (<A HREF = "Control.Monad.State.html#t%3AState"
		      >State</A
		      > s)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "GHC.Base.html#t%3AMonad"
		      >Monad</A
		      > m =&gt; <A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s (<A HREF = "Control.Monad.State.html#t%3AStateT"
		      >StateT</A
		      > s m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s m =&gt; <A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s (<A HREF = "Control.Monad.Reader.html#t%3AReaderT"
		      >ReaderT</A
		      > r m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    >(<A HREF = "Data.Monoid.html#t%3AMonoid"
		      >Monoid</A
		      > w, <A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s m) =&gt; <A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s (<A HREF = "Control.Monad.Writer.html#t%3AWriterT"
		      >WriterT</A
		      > w m)</TD
		    ></TR
		  ></TABLE
		></TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Amodify"
	  ></A
	  ><B
	  >modify</B
	  > :: <A HREF = "Control.Monad.State.html#t%3AMonadState"
	  >MonadState</A
	  > s m =&gt; (s -&gt; s) -&gt; m ()</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >Monadic state transformer.
</P
	  ><P
	  >Maps an old state to a new state inside a state monad.
The old state is thrown away.
</P
	  ><PRE
	  >	  Main&gt; :t modify ((+1) :: Int -&gt; Int)
	  modify (...) :: (MonadState Int a) =&gt; a ()
</PRE
	  ><P
	  >This says that <TT
	    >modify (+1)</TT
	    > acts over any
Monad that is a member of the <TT
	    >MonadState</TT
	    > class,
with an <TT
	    >Int</TT
	    > state.</P
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Agets"
	  ></A
	  ><B
	  >gets</B
	  > :: <A HREF = "Control.Monad.State.html#t%3AMonadState"
	  >MonadState</A
	  > s m =&gt; (s -&gt; a) -&gt; m a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Gets specific component of the state, using a projection function
supplied.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "2"
	  >The State Monad</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><SPAN CLASS = "keyword"
	  >newtype</SPAN
	  > <A NAME = "t%3AState"
	  ></A
	  ><B
	  >State</B
	  > s a</TD
	></TR
      ><TR
      ><TD CLASS = "body"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD CLASS = "ndoc"
	      >A parameterizable state monad where <EM
		>s</EM
		> is the type of the state
to carry and <EM
		>a</EM
		> is the type of the <EM
		>return value</EM
		>.</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "section4"
	      >Constructors</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "body"
	      ><TABLE CLASS = "vanilla" CELLSPACING = "5" CELLPADDING = "0"
		><TR
		  ><TD CLASS = "arg"
		    ><A NAME = "v%3AState"
		      ></A
		      ><B
		      >State</B
		      ></TD
		    ><TD CLASS = "rdoc"
		    ></TD
		    ></TR
		  ><TR
		  ><TD CLASS = "body" COLSPAN = "2"
		    ><TABLE CLASS = "vanilla" CELLSPACING = "1" CELLPADDING = "0"
		      ><TR
			><TD CLASS = "arg"
			  ><A NAME = "v%3ArunState"
			    ></A
			    ><B
			    >runState</B
			    > :: (s -&gt; (a, s))</TD
			  ><TD CLASS = "rdoc"
			  ></TD
			  ></TR
			></TABLE
		      ></TD
		    ></TR
		  ></TABLE
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "section4"
	      >Instances</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "body"
	      ><TABLE CLASS = "vanilla" CELLSPACING = "1" CELLPADDING = "0"
		><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "GHC.Base.html#t%3AFunctor"
		      >Functor</A
		      > (<A HREF = "Control.Monad.State.html#t%3AState"
		      >State</A
		      > s)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "GHC.Base.html#t%3AMonad"
		      >Monad</A
		      > (<A HREF = "Control.Monad.State.html#t%3AState"
		      >State</A
		      > s)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.Fix.html#t%3AMonadFix"
		      >MonadFix</A
		      > (<A HREF = "Control.Monad.State.html#t%3AState"
		      >State</A
		      > s)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s (<A HREF = "Control.Monad.State.html#t%3AState"
		      >State</A
		      > s)</TD
		    ></TR
		  ></TABLE
		></TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AevalState"
	  ></A
	  ><B
	  >evalState</B
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "body"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD CLASS = "arg"
	      >:: <A HREF = "Control.Monad.State.html#t%3AState"
		>State</A
		> s a</TD
	      ><TD CLASS = "rdoc"
	      >The state to evaluate</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "arg"
	      >-&gt; s</TD
	      ><TD CLASS = "rdoc"
	      >An initial value</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "arg"
	      >-&gt; a</TD
	      ><TD CLASS = "rdoc"
	      >The return value of the state application</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "ndoc" COLSPAN = "2"
	      >Evaluate this state monad with the given initial state,throwing
away the final state.  Very much like <TT
		>fst</TT
		> composed with
<TT
		>runstate</TT
		>.</TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AexecState"
	  ></A
	  ><B
	  >execState</B
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "body"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD CLASS = "arg"
	      >:: <A HREF = "Control.Monad.State.html#t%3AState"
		>State</A
		> s a</TD
	      ><TD CLASS = "rdoc"
	      >The state to evaluate</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "arg"
	      >-&gt; s</TD
	      ><TD CLASS = "rdoc"
	      >An initial value</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "arg"
	      >-&gt; s</TD
	      ><TD CLASS = "rdoc"
	      >The new state</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "ndoc" COLSPAN = "2"
	      >Execute this state and return the new state, throwing away the
return value.  Very much like <TT
		>snd</TT
		> composed with
<TT
		>runstate</TT
		>.</TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AmapState"
	  ></A
	  ><B
	  >mapState</B
	  > :: ((a, s) -&gt; (b, s)) -&gt; <A HREF = "Control.Monad.State.html#t%3AState"
	  >State</A
	  > s a -&gt; <A HREF = "Control.Monad.State.html#t%3AState"
	  >State</A
	  > s b</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >Map a stateful computation from one (return value, state) pair to
another.  For instance, to convert numberTree from a function that
returns a tree to a function that returns the sum of the numbered
tree (see the Examples section for numberTree and sumTree) you may
write:
</P
	  ><PRE
	  > sumNumberedTree :: (Eq a) =&gt; Tree a -&gt; State (Table a) Int
 sumNumberedTree = mapState (\ (t, tab) -&gt; (sumTree t, tab))  . numberTree</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AwithState"
	  ></A
	  ><B
	  >withState</B
	  > :: (s -&gt; s) -&gt; <A HREF = "Control.Monad.State.html#t%3AState"
	  >State</A
	  > s a -&gt; <A HREF = "Control.Monad.State.html#t%3AState"
	  >State</A
	  > s a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Apply this function to this state and return the resulting state.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "3"
	  >The StateT Monad</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><SPAN CLASS = "keyword"
	  >newtype</SPAN
	  > <A NAME = "t%3AStateT"
	  ></A
	  ><B
	  >StateT</B
	  > s m a</TD
	></TR
      ><TR
      ><TD CLASS = "body"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD CLASS = "ndoc"
	      ><P
		>A parameterizable state monad for encapsulating an inner
monad.
</P
		><P
		>The StateT Monad structure is parameterized over two things:
</P
		><UL
		><LI
		  > s - The state.
</LI
		  ><LI
		  > m - The inner monad.
</LI
		  ></UL
		><P
		>Here are some examples of use:
</P
		><P
		>(Parser from ParseLib with Hugs)
</P
		><PRE
		>  type Parser a = StateT String [] a
     ==&gt; StateT (String -&gt; [(a,String)])
</PRE
		><P
		>For example, item can be written as:
</P
		><PRE
		>   item = do (x:xs) &lt;- get
          put xs
          return x

   type BoringState s a = StateT s Indentity a
        ==&gt; StateT (s -&gt; Identity (a,s))

   type StateWithIO s a = StateT s IO a
        ==&gt; StateT (s -&gt; IO (a,s))

   type StateWithErr s a = StateT s Maybe a
        ==&gt; StateT (s -&gt; Maybe (a,s))</PRE
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "section4"
	      >Constructors</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "body"
	      ><TABLE CLASS = "vanilla" CELLSPACING = "5" CELLPADDING = "0"
		><TR
		  ><TD CLASS = "arg"
		    ><A NAME = "v%3AStateT"
		      ></A
		      ><B
		      >StateT</B
		      ></TD
		    ><TD CLASS = "rdoc"
		    ></TD
		    ></TR
		  ><TR
		  ><TD CLASS = "body" COLSPAN = "2"
		    ><TABLE CLASS = "vanilla" CELLSPACING = "1" CELLPADDING = "0"
		      ><TR
			><TD CLASS = "arg"
			  ><A NAME = "v%3ArunStateT"
			    ></A
			    ><B
			    >runStateT</B
			    > :: (s -&gt; m (a, s))</TD
			  ><TD CLASS = "rdoc"
			  ></TD
			  ></TR
			></TABLE
		      ></TD
		    ></TR
		  ></TABLE
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "section4"
	      >Instances</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "body"
	      ><TABLE CLASS = "vanilla" CELLSPACING = "1" CELLPADDING = "0"
		><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.Cont.html#t%3AMonadCont"
		      >MonadCont</A
		      > m =&gt; <A HREF = "Control.Monad.Cont.html#t%3AMonadCont"
		      >MonadCont</A
		      > (<A HREF = "Control.Monad.State.html#t%3AStateT"
		      >StateT</A
		      > s m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.Error.html#t%3AMonadError"
		      >MonadError</A
		      > e m =&gt; <A HREF = "Control.Monad.Error.html#t%3AMonadError"
		      >MonadError</A
		      > e (<A HREF = "Control.Monad.State.html#t%3AStateT"
		      >StateT</A
		      > s m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "GHC.Base.html#t%3AMonad"
		      >Monad</A
		      > m =&gt; <A HREF = "GHC.Base.html#t%3AFunctor"
		      >Functor</A
		      > (<A HREF = "Control.Monad.State.html#t%3AStateT"
		      >StateT</A
		      > s m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "GHC.Base.html#t%3AMonad"
		      >Monad</A
		      > m =&gt; <A HREF = "GHC.Base.html#t%3AMonad"
		      >Monad</A
		      > (<A HREF = "Control.Monad.State.html#t%3AStateT"
		      >StateT</A
		      > s m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.html#t%3AMonadPlus"
		      >MonadPlus</A
		      > m =&gt; <A HREF = "Control.Monad.html#t%3AMonadPlus"
		      >MonadPlus</A
		      > (<A HREF = "Control.Monad.State.html#t%3AStateT"
		      >StateT</A
		      > s m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.Fix.html#t%3AMonadFix"
		      >MonadFix</A
		      > m =&gt; <A HREF = "Control.Monad.Fix.html#t%3AMonadFix"
		      >MonadFix</A
		      > (<A HREF = "Control.Monad.State.html#t%3AStateT"
		      >StateT</A
		      > s m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "GHC.Base.html#t%3AMonad"
		      >Monad</A
		      > m =&gt; <A HREF = "Control.Monad.State.html#t%3AMonadState"
		      >MonadState</A
		      > s (<A HREF = "Control.Monad.State.html#t%3AStateT"
		      >StateT</A
		      > s m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.Trans.html#t%3AMonadTrans"
		      >MonadTrans</A
		      > (<A HREF = "Control.Monad.State.html#t%3AStateT"
		      >StateT</A
		      > s)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.Trans.html#t%3AMonadIO"
		      >MonadIO</A
		      > m =&gt; <A HREF = "Control.Monad.Trans.html#t%3AMonadIO"
		      >MonadIO</A
		      > (<A HREF = "Control.Monad.State.html#t%3AStateT"
		      >StateT</A
		      > s m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.Reader.html#t%3AMonadReader"
		      >MonadReader</A
		      > r m =&gt; <A HREF = "Control.Monad.Reader.html#t%3AMonadReader"
		      >MonadReader</A
		      > r (<A HREF = "Control.Monad.State.html#t%3AStateT"
		      >StateT</A
		      > s m)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.Writer.html#t%3AMonadWriter"
		      >MonadWriter</A
		      > w m =&gt; <A HREF = "Control.Monad.Writer.html#t%3AMonadWriter"
		      >MonadWriter</A
		      > w (<A HREF = "Control.Monad.State.html#t%3AStateT"
		      >StateT</A
		      > s m)</TD
		    ></TR
		  ></TABLE
		></TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AevalStateT"
	  ></A
	  ><B
	  >evalStateT</B
	  > :: <A HREF = "GHC.Base.html#t%3AMonad"
	  >Monad</A
	  > m =&gt; <A HREF = "Control.Monad.State.html#t%3AStateT"
	  >StateT</A
	  > s m a -&gt; s -&gt; m a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Similar to <TT
	  ><A HREF = "Control.Monad.State.html#v%3AevalState"
	    >evalState</A
	    ></TT
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AexecStateT"
	  ></A
	  ><B
	  >execStateT</B
	  > :: <A HREF = "GHC.Base.html#t%3AMonad"
	  >Monad</A
	  > m =&gt; <A HREF = "Control.Monad.State.html#t%3AStateT"
	  >StateT</A
	  > s m a -&gt; s -&gt; m s</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Similar to <TT
	  ><A HREF = "Control.Monad.State.html#v%3AexecState"
	    >execState</A
	    ></TT
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AmapStateT"
	  ></A
	  ><B
	  >mapStateT</B
	  > :: (m (a, s) -&gt; n (b, s)) -&gt; <A HREF = "Control.Monad.State.html#t%3AStateT"
	  >StateT</A
	  > s m a -&gt; <A HREF = "Control.Monad.State.html#t%3AStateT"
	  >StateT</A
	  > s n b</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Similar to <TT
	  ><A HREF = "Control.Monad.State.html#v%3AmapState"
	    >mapState</A
	    ></TT
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AwithStateT"
	  ></A
	  ><B
	  >withStateT</B
	  > :: (s -&gt; s) -&gt; <A HREF = "Control.Monad.State.html#t%3AStateT"
	  >StateT</A
	  > s m a -&gt; <A HREF = "Control.Monad.State.html#t%3AStateT"
	  >StateT</A
	  > s m a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Similar to <TT
	  ><A HREF = "Control.Monad.State.html#v%3AwithState"
	    >withState</A
	    ></TT
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	>module <A HREF = "Control.Monad.html"
	  >Control.Monad</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	>module <A HREF = "Control.Monad.Fix.html"
	  >Control.Monad.Fix</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	>module <A HREF = "Control.Monad.Trans.html"
	  >Control.Monad.Trans</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "4"
	  >Examples</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >A function to increment a counter.  Taken from the paper
<EM
	    >Generalising Monads to Arrows</EM
	    >, John
Hughes (<A HREF = "http://www.math.chalmers.se/~rjmh/"
	    >http://www.math.chalmers.se/~rjmh/</A
	    >), November 1998:
</P
	  ><PRE
	  > tick :: State Int Int
 tick = do n &lt;- get
           put (n+1)
           return n
</PRE
	  ><P
	  >Add one to the given number using the state monad:
</P
	  ><PRE
	  > plusOne :: Int -&gt; Int
 plusOne n = execState tick n
</PRE
	  ><P
	  >A contrived addition example. Works only with positive numbers:
</P
	  ><PRE
	  > plus :: Int -&gt; Int -&gt; Int
 plus n x = execState (sequence $ replicate n tick) x
</PRE
	  ><P
	  >An example from <EM
	    >The Craft of Functional Programming</EM
	    >, Simon
Thompson (<A HREF = "http://www.cs.kent.ac.uk/people/staff/sjt/"
	    >http://www.cs.kent.ac.uk/people/staff/sjt/</A
	    >),
Addison-Wesley 1999: &quot;Given an arbitrary tree, transform it to a
tree of integers in which the original elements are replaced by
natural numbers, starting from 0.  The same element has to be
replaced by the same number at every occurrence, and when we meet
an as-yet-unvisited element we have to find a new number to match
it with:&quot;
</P
	  ><PRE
	  > data Tree a = Nil | Node a (Tree a) (Tree a) deriving (Show, Eq)
 type Table a = [a]
</PRE
	  ><PRE
	  > numberTree :: Eq a =&gt; Tree a -&gt; State (Table a) (Tree Int)
 numberTree Nil = return Nil
 numberTree (Node x t1 t2) 
        =  do num &lt;- numberNode x
              nt1 &lt;- numberTree t1
              nt2 &lt;- numberTree t2
              return (Node num nt1 nt2)
     where 
     numberNode :: Eq a =&gt; a -&gt; State (Table a) Int
     numberNode x
        = do table &lt;- get
             (newTable, newPos) &lt;- return (nNode x table)
             put newTable
             return newPos
     nNode::  (Eq a) =&gt; a -&gt; Table a -&gt; (Table a, Int)
     nNode x table
        = case (findIndexInList (== x) table) of
          Nothing -&gt; (table ++ [x], length table)
          Just i  -&gt; (table, i)
     findIndexInList :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe Int
     findIndexInList = findIndexInListHelp 0
     findIndexInListHelp _ _ [] = Nothing
     findIndexInListHelp count f (h:t)
        = if (f h)
          then Just count
          else findIndexInListHelp (count+1) f t
</PRE
	  ><P
	  >numTree applies numberTree with an initial state:
</P
	  ><PRE
	  > numTree :: (Eq a) =&gt; Tree a -&gt; Tree Int
 numTree t = evalState (numberTree t) []
</PRE
	  ><PRE
	  > testTree = Node &quot;Zero&quot; (Node &quot;One&quot; (Node &quot;Two&quot; Nil Nil) (Node &quot;One&quot; (Node &quot;Zero&quot; Nil Nil) Nil)) Nil
 numTree testTree =&gt; Node 0 (Node 1 (Node 2 Nil Nil) (Node 1 (Node 0 Nil Nil) Nil)) Nil
</PRE
	  ><P
	  >sumTree is a little helper function that does not use the State monad:
</P
	  ><PRE
	  > sumTree :: (Num a) =&gt; Tree a -&gt; a
 sumTree Nil = 0
 sumTree (Node e t1 t2) = e + (sumTree t1) + (sumTree t2)</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "botbar"
	>Produced by <A HREF = "http://www.haskell.org/haddock/"
	  >Haddock</A
	  > version 0.6</TD
	></TR
      ></TABLE
    ></BODY
  ></HTML
>
