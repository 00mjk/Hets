<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--Rendered using the Haskell Html Library v0.2-->
<HTML
><HEAD
  ><TITLE
    >Text.ParserCombinators.ReadP</TITLE
    ><LINK HREF = "haddock.css" REL = "stylesheet" TYPE = "text/css"
    ></HEAD
  ><BODY
  ><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
    ><TR
      ><TD CLASS = "topbar"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD
	      ><IMG SRC = "haskell_icon.gif" WIDTH = "16" HEIGHT = "16" ALT = " "
		></TD
	      ><TD CLASS = "title"
	      >Haskell Hierarchical Libraries (base package)</TD
	      ><TD CLASS = "topbut"
	      ><A HREF = "../index.html"
		>Contents</A
		></TD
	      ><TD CLASS = "topbut"
	      ><A HREF = "../doc-index.html"
		>Index</A
		></TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "modulebar"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD
	      ><FONT SIZE = "6"
		>Text.ParserCombinators.ReadP</FONT
		></TD
	      ><TD ALIGN = "right"
	      ><TABLE CLASS = "narrow" CELLSPACING = "0" CELLPADDING = "0"
		><TR
		  ><TD CLASS = "infohead"
		    >Portability</TD
		    ><TD CLASS = "infoval"
		    >  non-portable (local universal quantification)</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "infohead"
		    >Stability</TD
		    ><TD CLASS = "infoval"
		    >  provisional</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "infohead"
		    >Maintainer</TD
		    ><TD CLASS = "infoval"
		    >  libraries@haskell.org</TD
		    ></TR
		  ></TABLE
		></TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD CLASS = "section4"
	      ><B
		>Contents</B
		></TD
	      ></TR
	    ><TR
	    ><TD
	      ><DL
		><DT
		  ><A HREF = "#1"
		    >The <TT
		      ><A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
			>ReadP</A
			></TT
		      > type</A
		    ></DT
		  ><DT
		  ><A HREF = "#2"
		    >Primitive operations</A
		    ></DT
		  ><DT
		  ><A HREF = "#3"
		    >Other operations</A
		    ></DT
		  ><DT
		  ><A HREF = "#4"
		    >Running a parser</A
		    ></DT
		  ><DT
		  ><A HREF = "#5"
		    >Properties</A
		    ></DT
		  ></DL
		></TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	>Description</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>This is a library of parser combinators, originally written by Koen Claessen.
It parses all alternatives in parallel, so it never keeps hold of 
the beginning of the input string, a common source of space leaks with
other parsers.  The '(+++)' choice combinator is genuinely commutative;
it makes no difference which branch is &quot;shorter&quot;.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	>Synopsis</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "body"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD CLASS = "decl"
	      ><SPAN CLASS = "keyword"
		>data</SPAN
		> <A HREF = "#t%3AReadP"
		>ReadP</A
		> a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aget"
		>get</A
		> :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> <A HREF = "GHC.Base.html#t%3AChar"
		>Char</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Alook"
		>look</A
		> :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> <A HREF = "GHC.Base.html#t%3AString"
		>String</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3A%2B%2B%2B"
		>(+++)</A
		> :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> a -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> a -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3A%3C%2B%2B"
		>(&lt;++)</A
		> :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> a -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> a -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Agather"
		>gather</A
		> :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> a -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> (<A HREF = "GHC.Base.html#t%3AString"
		>String</A
		>, a)</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Apfail"
		>pfail</A
		> :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Asatisfy"
		>satisfy</A
		> :: (<A HREF = "GHC.Base.html#t%3AChar"
		>Char</A
		> -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> <A HREF = "GHC.Base.html#t%3AChar"
		>Char</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Achar"
		>char</A
		> :: <A HREF = "GHC.Base.html#t%3AChar"
		>Char</A
		> -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> <A HREF = "GHC.Base.html#t%3AChar"
		>Char</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Astring"
		>string</A
		> :: <A HREF = "GHC.Base.html#t%3AString"
		>String</A
		> -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> <A HREF = "GHC.Base.html#t%3AString"
		>String</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Amunch"
		>munch</A
		> :: (<A HREF = "GHC.Base.html#t%3AChar"
		>Char</A
		> -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> <A HREF = "GHC.Base.html#t%3AString"
		>String</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Amunch1"
		>munch1</A
		> :: (<A HREF = "GHC.Base.html#t%3AChar"
		>Char</A
		> -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> <A HREF = "GHC.Base.html#t%3AString"
		>String</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AskipSpaces"
		>skipSpaces</A
		> :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> ()</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Achoice"
		>choice</A
		> :: [<A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> a] -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><SPAN CLASS = "keyword"
		>type</SPAN
		> <A HREF = "#t%3AReadS"
		>ReadS</A
		> a = <A HREF = "GHC.Base.html#t%3AString"
		>String</A
		> -&gt; [(a, <A HREF = "GHC.Base.html#t%3AString"
		>String</A
		>)]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AreadP_to_S"
		>readP_to_S</A
		> :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> a -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadS"
		>ReadS</A
		> a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AreadS_to_P"
		>readS_to_P</A
		> :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadS"
		>ReadS</A
		> a -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		>ReadP</A
		> a</TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "1"
	  >The <TT
	    ><A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	      >ReadP</A
	      ></TT
	    > type</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><SPAN CLASS = "keyword"
	  >data</SPAN
	  > <A NAME = "t%3AReadP"
	  ></A
	  ><B
	  >ReadP</B
	  > a</TD
	></TR
      ><TR
      ><TD CLASS = "body"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD CLASS = "section4"
	      >Instances</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "body"
	      ><TABLE CLASS = "vanilla" CELLSPACING = "1" CELLPADDING = "0"
		><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "GHC.Base.html#t%3AFunctor"
		      >Functor</A
		      > <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		      >ReadP</A
		      ></TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "GHC.Base.html#t%3AMonad"
		      >Monad</A
		      > <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		      >ReadP</A
		      ></TD
		    ></TR
		  ><TR
		  ><TD CLASS = "decl"
		    ><A HREF = "Control.Monad.html#t%3AMonadPlus"
		      >MonadPlus</A
		      > <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
		      >ReadP</A
		      ></TD
		    ></TR
		  ></TABLE
		></TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "2"
	  >Primitive operations</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aget"
	  ></A
	  ><B
	  >get</B
	  > :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > <A HREF = "GHC.Base.html#t%3AChar"
	  >Char</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Consumes and returns the next character.
Fails if there is no input left.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Alook"
	  ></A
	  ><B
	  >look</B
	  > :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > <A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Look-ahead: returns the part of the input that is left, without
consuming it.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3A%2B%2B%2B"
	  ></A
	  ><B
	  >(+++)</B
	  > :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > a -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > a -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Symmetric choice.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3A%3C%2B%2B"
	  ></A
	  ><B
	  >(&lt;++)</B
	  > :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > a -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > a -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Local, exclusive, left-biased choice: If left parser
locally produces any result at all, then right parser is
not used.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Agather"
	  ></A
	  ><B
	  >gather</B
	  > :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > a -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > (<A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  >, a)</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Transforms a parser into one that does the same, but
in addition returns the exact characters read.
IMPORTANT NOTE: <TT
	  ><A HREF = "Text.ParserCombinators.ReadP.html#v%3Agather"
	    >gather</A
	    ></TT
	  > gives a runtime error if its first argument
is built using any occurrences of readS_to_P. </TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "3"
	  >Other operations</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Apfail"
	  ></A
	  ><B
	  >pfail</B
	  > :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Always fails.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Asatisfy"
	  ></A
	  ><B
	  >satisfy</B
	  > :: (<A HREF = "GHC.Base.html#t%3AChar"
	  >Char</A
	  > -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > <A HREF = "GHC.Base.html#t%3AChar"
	  >Char</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Consumes and returns the next character, if it satisfies the
specified predicate.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Achar"
	  ></A
	  ><B
	  >char</B
	  > :: <A HREF = "GHC.Base.html#t%3AChar"
	  >Char</A
	  > -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > <A HREF = "GHC.Base.html#t%3AChar"
	  >Char</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Parses and returns the specified character.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Astring"
	  ></A
	  ><B
	  >string</B
	  > :: <A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  > -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > <A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Parses and returns the specified string.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Amunch"
	  ></A
	  ><B
	  >munch</B
	  > :: (<A HREF = "GHC.Base.html#t%3AChar"
	  >Char</A
	  > -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > <A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Parses the first zero or more characters satisfying the predicate.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Amunch1"
	  ></A
	  ><B
	  >munch1</B
	  > :: (<A HREF = "GHC.Base.html#t%3AChar"
	  >Char</A
	  > -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > <A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Parses the first one or more characters satisfying the predicate.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AskipSpaces"
	  ></A
	  ><B
	  >skipSpaces</B
	  > :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > ()</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Skips all whitespace.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Achoice"
	  ></A
	  ><B
	  >choice</B
	  > :: [<A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > a] -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Combines all parsers in the specified list.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "4"
	  >Running a parser</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><SPAN CLASS = "keyword"
	  >type</SPAN
	  > <A NAME = "t%3AReadS"
	  ></A
	  ><B
	  >ReadS</B
	  > a = <A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  > -&gt; [(a, <A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  >)]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>A parser for a type <TT
	  >a</TT
	  >, represented as a function that takes a
<TT
	  ><A HREF = "GHC.Base.html#t%3AString"
	    >String</A
	    ></TT
	  > and returns a list of possible parses <TT
	  >(a,<TT
	    ><A HREF = "GHC.Base.html#t%3AString"
	      >String</A
	      ></TT
	    >)</TT
	  > pairs.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AreadP_to_S"
	  ></A
	  ><B
	  >readP_to_S</B
	  > :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > a -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadS"
	  >ReadS</A
	  > a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Converts a parser into a Haskell ReadS-style function.
This is the main way in which you can &quot;run&quot; a <TT
	  ><A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	    >ReadP</A
	    ></TT
	  > parser:
the expanded type is
<TT
	  > readP_to_S :: ReadP a -&gt; String -&gt; [(a,String)] </TT
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AreadS_to_P"
	  ></A
	  ><B
	  >readS_to_P</B
	  > :: <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadS"
	  >ReadS</A
	  > a -&gt; <A HREF = "Text.ParserCombinators.ReadP.html#t%3AReadP"
	  >ReadP</A
	  > a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Converts a Haskell ReadS-style function into a parser.
Warning: This introduces local backtracking in the resulting
parser, and therefore a possible inefficiency.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "5"
	  >Properties</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >The following are QuickCheck specifications of what the combinators do.
These can be seen as formal specifications of the behavior of the
combinators.
</P
	  ><P
	  >We use bags to give semantics to the combinators.
</P
	  ><PRE
	  >  type Bag a = [a]
</PRE
	  ><P
	  >Equality on bags does not care about the order of elements.
</P
	  ><PRE
	  >  (=~) :: Ord a =&gt; Bag a -&gt; Bag a -&gt; Bool
  xs =~ ys = sort xs == sort ys
</PRE
	  ><P
	  >A special equality operator to avoid unresolved overloading
when testing the properties.
</P
	  ><PRE
	  >  (=~.) :: Bag (Int,String) -&gt; Bag (Int,String) -&gt; Bool
  (=~.) = (=~)
</PRE
	  ><P
	  >Here follow the properties:
</P
	  ><PRE
	  >  prop_Get_Nil =
    readP_to_S get [] =~ []

  prop_Get_Cons c s =
    readP_to_S get (c:s) =~ [(c,s)]

  prop_Look s =
    readP_to_S look s =~ [(s,s)]

  prop_Fail s =
    readP_to_S pfail s =~. []

  prop_Return x s =
    readP_to_S (return x) s =~. [(x,s)]

  prop_Bind p k s =
    readP_to_S (p &gt;&gt;= k) s =~.
      [ ys''
      | (x,s') &lt;- readP_to_S p s
      , ys''   &lt;- readP_to_S (k (x::Int)) s'
      ]

  prop_Plus p q s =
    readP_to_S (p +++ q) s =~.
      (readP_to_S p s ++ readP_to_S q s)

  prop_LeftPlus p q s =
    readP_to_S (p &lt;++ q) s =~.
      (readP_to_S p s +&lt;+ readP_to_S q s)
   where
    [] +&lt;+ ys = ys
    xs +&lt;+ _  = xs

  prop_Gather s =
    forAll readPWithoutReadS $ \p -&gt; 
      readP_to_S (gather p) s =~
	 [ ((pre,x::Int),s')
	 | (x,s') &lt;- readP_to_S p s
	 , let pre = take (length s - length s') s
	 ]

  prop_String_Yes this s =
    readP_to_S (string this) (this ++ s) =~
      [(this,s)]

  prop_String_Maybe this s =
    readP_to_S (string this) s =~
      [(this, drop (length this) s) | this `isPrefixOf` s]

  prop_Munch p s =
    readP_to_S (munch p) s =~
      [(takeWhile p s, dropWhile p s)]

  prop_Munch1 p s =
    readP_to_S (munch1 p) s =~
      [(res,s') | let (res,s') = (takeWhile p s, dropWhile p s), not (null res)]

  prop_Choice ps s =
    readP_to_S (choice ps) s =~.
      readP_to_S (foldr (+++) pfail ps) s

  prop_ReadS r s =
    readP_to_S (readS_to_P r) s =~. r s
</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "botbar"
	>Produced by <A HREF = "http://www.haskell.org/haddock/"
	  >Haddock</A
	  > version 0.6</TD
	></TR
      ></TABLE
    ></BODY
  ></HTML
>
