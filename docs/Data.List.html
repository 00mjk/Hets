<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--Rendered using the Haskell Html Library v0.2-->
<HTML
><HEAD
  ><TITLE
    >Data.List</TITLE
    ><LINK HREF = "haddock.css" REL = "stylesheet" TYPE = "text/css"
    ></HEAD
  ><BODY
  ><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
    ><TR
      ><TD CLASS = "topbar"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD
	      ><IMG SRC = "haskell_icon.gif" WIDTH = "16" HEIGHT = "16" ALT = " "
		></TD
	      ><TD CLASS = "title"
	      >Haskell Hierarchical Libraries (base package)</TD
	      ><TD CLASS = "topbut"
	      ><A HREF = "../index.html"
		>Contents</A
		></TD
	      ><TD CLASS = "topbut"
	      ><A HREF = "../doc-index.html"
		>Index</A
		></TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "modulebar"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD
	      ><FONT SIZE = "6"
		>Data.List</FONT
		></TD
	      ><TD ALIGN = "right"
	      ><TABLE CLASS = "narrow" CELLSPACING = "0" CELLPADDING = "0"
		><TR
		  ><TD CLASS = "infohead"
		    >Portability</TD
		    ><TD CLASS = "infoval"
		    >  portable</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "infohead"
		    >Stability</TD
		    ><TD CLASS = "infoval"
		    >  stable</TD
		    ></TR
		  ><TR
		  ><TD CLASS = "infohead"
		    >Maintainer</TD
		    ><TD CLASS = "infoval"
		    >  libraries@haskell.org</TD
		    ></TR
		  ></TABLE
		></TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD CLASS = "section4"
	      ><B
		>Contents</B
		></TD
	      ></TR
	    ><TR
	    ><TD
	      ><DL
		><DT
		  ><A HREF = "#1"
		    >Basic functions</A
		    ></DT
		  ><DT
		  ><A HREF = "#2"
		    >List transformations</A
		    ></DT
		  ><DT
		  ><A HREF = "#3"
		    >Reducing lists (folds)</A
		    ></DT
		  ><DD
		  ><DL
		    ><DT
		      ><A HREF = "#4"
			>Special folds</A
			></DT
		      ></DL
		    ></DD
		  ><DT
		  ><A HREF = "#5"
		    >Building lists</A
		    ></DT
		  ><DD
		  ><DL
		    ><DT
		      ><A HREF = "#6"
			>Scans</A
			></DT
		      ><DT
		      ><A HREF = "#7"
			>Accumulating maps</A
			></DT
		      ><DT
		      ><A HREF = "#8"
			>Infinite lists</A
			></DT
		      ><DT
		      ><A HREF = "#9"
			>Unfolding</A
			></DT
		      ></DL
		    ></DD
		  ><DT
		  ><A HREF = "#10"
		    >Sublists</A
		    ></DT
		  ><DD
		  ><DL
		    ><DT
		      ><A HREF = "#11"
			>Extracting sublists</A
			></DT
		      ><DT
		      ><A HREF = "#12"
			>Predicates</A
			></DT
		      ></DL
		    ></DD
		  ><DT
		  ><A HREF = "#13"
		    >Searching lists</A
		    ></DT
		  ><DD
		  ><DL
		    ><DT
		      ><A HREF = "#14"
			>Searching by equality</A
			></DT
		      ><DT
		      ><A HREF = "#15"
			>Searching with a predicate</A
			></DT
		      ></DL
		    ></DD
		  ><DT
		  ><A HREF = "#16"
		    >Indexing lists</A
		    ></DT
		  ><DT
		  ><A HREF = "#17"
		    >Zipping and unzipping lists</A
		    ></DT
		  ><DT
		  ><A HREF = "#18"
		    >Special lists</A
		    ></DT
		  ><DD
		  ><DL
		    ><DT
		      ><A HREF = "#19"
			>Functions on strings</A
			></DT
		      ><DT
		      ><A HREF = "#20"
			>&quot;Set&quot; operations</A
			></DT
		      ><DT
		      ><A HREF = "#21"
			>Ordered lists</A
			></DT
		      ></DL
		    ></DD
		  ><DT
		  ><A HREF = "#22"
		    >Generalized functions</A
		    ></DT
		  ><DD
		  ><DL
		    ><DT
		      ><A HREF = "#23"
			>The &quot;<TT
			  >By</TT
			  >&quot; operations</A
			></DT
		      ><DD
		      ><DL
			><DT
			  ><A HREF = "#24"
			    >User-supplied equality (replacing an <TT
			      >Eq</TT
			      > context)</A
			    ></DT
			  ><DT
			  ><A HREF = "#25"
			    >User-supplied comparison (replacing an <TT
			      >Ord</TT
			      > context)</A
			    ></DT
			  ></DL
			></DD
		      ><DT
		      ><A HREF = "#26"
			>The &quot;<TT
			  >generic</TT
			  >&quot; operations</A
			></DT
		      ></DL
		    ></DD
		  ></DL
		></TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	>Description</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Operations on lists.
</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	>Synopsis</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "body"
	><TABLE CLASS = "vanilla" CELLSPACING = "0" CELLPADDING = "0"
	  ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3A%2B%2B"
		>(++)</A
		> :: [a] -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Ahead"
		>head</A
		> :: [a] -&gt; a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Alast"
		>last</A
		> :: [a] -&gt; a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Atail"
		>tail</A
		> :: [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Ainit"
		>init</A
		> :: [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Anull"
		>null</A
		> :: [a] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Alength"
		>length</A
		> :: [a] -&gt; <A HREF = "GHC.Base.html#t%3AInt"
		>Int</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Amap"
		>map</A
		> :: (a -&gt; b) -&gt; [a] -&gt; [b]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Areverse"
		>reverse</A
		> :: [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aintersperse"
		>intersperse</A
		> :: a -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Atranspose"
		>transpose</A
		> :: [[a]] -&gt; [[a]]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Afoldl"
		>foldl</A
		> :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Afoldl'"
		>foldl'</A
		> :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Afoldl1"
		>foldl1</A
		> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Afoldr"
		>foldr</A
		> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Afoldr1"
		>foldr1</A
		> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aconcat"
		>concat</A
		> :: [[a]] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AconcatMap"
		>concatMap</A
		> :: (a -&gt; [b]) -&gt; [a] -&gt; [b]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aand"
		>and</A
		> :: [<A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aor"
		>or</A
		> :: [<A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aany"
		>any</A
		> :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aall"
		>all</A
		> :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Asum"
		>sum</A
		> :: <A HREF = "GHC.Num.html#t%3ANum"
		>Num</A
		> a =&gt; [a] -&gt; a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aproduct"
		>product</A
		> :: <A HREF = "GHC.Num.html#t%3ANum"
		>Num</A
		> a =&gt; [a] -&gt; a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Amaximum"
		>maximum</A
		> :: <A HREF = "GHC.Base.html#t%3AOrd"
		>Ord</A
		> a =&gt; [a] -&gt; a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aminimum"
		>minimum</A
		> :: <A HREF = "GHC.Base.html#t%3AOrd"
		>Ord</A
		> a =&gt; [a] -&gt; a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Ascanl"
		>scanl</A
		> :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Ascanl1"
		>scanl1</A
		> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Ascanr"
		>scanr</A
		> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Ascanr1"
		>scanr1</A
		> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AmapAccumL"
		>mapAccumL</A
		> :: (acc -&gt; x -&gt; (acc, y)) -&gt; acc -&gt; [x] -&gt; (acc, [y])</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AmapAccumR"
		>mapAccumR</A
		> :: (acc -&gt; x -&gt; (acc, y)) -&gt; acc -&gt; [x] -&gt; (acc, [y])</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aiterate"
		>iterate</A
		> :: (a -&gt; a) -&gt; a -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Arepeat"
		>repeat</A
		> :: a -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Areplicate"
		>replicate</A
		> :: <A HREF = "GHC.Base.html#t%3AInt"
		>Int</A
		> -&gt; a -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Acycle"
		>cycle</A
		> :: [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aunfoldr"
		>unfoldr</A
		> :: (b -&gt; <A HREF = "Data.Maybe.html#t%3AMaybe"
		>Maybe</A
		> (a, b)) -&gt; b -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Atake"
		>take</A
		> :: <A HREF = "GHC.Base.html#t%3AInt"
		>Int</A
		> -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Adrop"
		>drop</A
		> :: <A HREF = "GHC.Base.html#t%3AInt"
		>Int</A
		> -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AsplitAt"
		>splitAt</A
		> :: <A HREF = "GHC.Base.html#t%3AInt"
		>Int</A
		> -&gt; [a] -&gt; ([a], [a])</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AtakeWhile"
		>takeWhile</A
		> :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AdropWhile"
		>dropWhile</A
		> :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aspan"
		>span</A
		> :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; ([a], [a])</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Abreak"
		>break</A
		> :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; ([a], [a])</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Agroup"
		>group</A
		> :: <A HREF = "GHC.Base.html#t%3AEq"
		>Eq</A
		> a =&gt; [a] -&gt; [[a]]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Ainits"
		>inits</A
		> :: [a] -&gt; [[a]]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Atails"
		>tails</A
		> :: [a] -&gt; [[a]]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AisPrefixOf"
		>isPrefixOf</A
		> :: <A HREF = "GHC.Base.html#t%3AEq"
		>Eq</A
		> a =&gt; [a] -&gt; [a] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AisSuffixOf"
		>isSuffixOf</A
		> :: <A HREF = "GHC.Base.html#t%3AEq"
		>Eq</A
		> a =&gt; [a] -&gt; [a] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aelem"
		>elem</A
		> :: <A HREF = "GHC.Base.html#t%3AEq"
		>Eq</A
		> a =&gt; a -&gt; [a] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AnotElem"
		>notElem</A
		> :: <A HREF = "GHC.Base.html#t%3AEq"
		>Eq</A
		> a =&gt; a -&gt; [a] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Alookup"
		>lookup</A
		> :: <A HREF = "GHC.Base.html#t%3AEq"
		>Eq</A
		> a =&gt; a -&gt; [(a, b)] -&gt; <A HREF = "Data.Maybe.html#t%3AMaybe"
		>Maybe</A
		> b</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Afind"
		>find</A
		> :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; <A HREF = "Data.Maybe.html#t%3AMaybe"
		>Maybe</A
		> a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Afilter"
		>filter</A
		> :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Apartition"
		>partition</A
		> :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; ([a], [a])</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3A!!"
		>(!!)</A
		> :: [a] -&gt; <A HREF = "GHC.Base.html#t%3AInt"
		>Int</A
		> -&gt; a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AelemIndex"
		>elemIndex</A
		> :: <A HREF = "GHC.Base.html#t%3AEq"
		>Eq</A
		> a =&gt; a -&gt; [a] -&gt; <A HREF = "Data.Maybe.html#t%3AMaybe"
		>Maybe</A
		> <A HREF = "GHC.Base.html#t%3AInt"
		>Int</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AelemIndices"
		>elemIndices</A
		> :: <A HREF = "GHC.Base.html#t%3AEq"
		>Eq</A
		> a =&gt; a -&gt; [a] -&gt; [<A HREF = "GHC.Base.html#t%3AInt"
		>Int</A
		>]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AfindIndex"
		>findIndex</A
		> :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; <A HREF = "Data.Maybe.html#t%3AMaybe"
		>Maybe</A
		> <A HREF = "GHC.Base.html#t%3AInt"
		>Int</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AfindIndices"
		>findIndices</A
		> :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; [<A HREF = "GHC.Base.html#t%3AInt"
		>Int</A
		>]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Azip"
		>zip</A
		> :: [a] -&gt; [b] -&gt; [(a, b)]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Azip3"
		>zip3</A
		> :: [a] -&gt; [b] -&gt; [c] -&gt; [(a, b, c)]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Azip4"
		>zip4</A
		> :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [(a, b, c, d)]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Azip5"
		>zip5</A
		> :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [(a, b, c, d, e)]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Azip6"
		>zip6</A
		> :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [(a, b, c, d, e, f)]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Azip7"
		>zip7</A
		> :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [g] -&gt; [(a, b, c, d, e, f, g)]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AzipWith"
		>zipWith</A
		> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AzipWith3"
		>zipWith3</A
		> :: (a -&gt; b -&gt; c -&gt; d) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AzipWith4"
		>zipWith4</A
		> :: (a -&gt; b -&gt; c -&gt; d -&gt; e) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AzipWith5"
		>zipWith5</A
		> :: (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AzipWith6"
		>zipWith6</A
		> :: (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [g]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AzipWith7"
		>zipWith7</A
		> :: (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [g] -&gt; [h]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aunzip"
		>unzip</A
		> :: [(a, b)] -&gt; ([a], [b])</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aunzip3"
		>unzip3</A
		> :: [(a, b, c)] -&gt; ([a], [b], [c])</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aunzip4"
		>unzip4</A
		> :: [(a, b, c, d)] -&gt; ([a], [b], [c], [d])</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aunzip5"
		>unzip5</A
		> :: [(a, b, c, d, e)] -&gt; ([a], [b], [c], [d], [e])</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aunzip6"
		>unzip6</A
		> :: [(a, b, c, d, e, f)] -&gt; ([a], [b], [c], [d], [e], [f])</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aunzip7"
		>unzip7</A
		> :: [(a, b, c, d, e, f, g)] -&gt; ([a], [b], [c], [d], [e], [f], [g])</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Alines"
		>lines</A
		> :: <A HREF = "GHC.Base.html#t%3AString"
		>String</A
		> -&gt; [<A HREF = "GHC.Base.html#t%3AString"
		>String</A
		>]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Awords"
		>words</A
		> :: <A HREF = "GHC.Base.html#t%3AString"
		>String</A
		> -&gt; [<A HREF = "GHC.Base.html#t%3AString"
		>String</A
		>]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aunlines"
		>unlines</A
		> :: [<A HREF = "GHC.Base.html#t%3AString"
		>String</A
		>] -&gt; <A HREF = "GHC.Base.html#t%3AString"
		>String</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aunwords"
		>unwords</A
		> :: [<A HREF = "GHC.Base.html#t%3AString"
		>String</A
		>] -&gt; <A HREF = "GHC.Base.html#t%3AString"
		>String</A
		></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Anub"
		>nub</A
		> :: <A HREF = "GHC.Base.html#t%3AEq"
		>Eq</A
		> a =&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Adelete"
		>delete</A
		> :: <A HREF = "GHC.Base.html#t%3AEq"
		>Eq</A
		> a =&gt; a -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3A%5C%5C"
		>(\\)</A
		> :: <A HREF = "GHC.Base.html#t%3AEq"
		>Eq</A
		> a =&gt; [a] -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aunion"
		>union</A
		> :: <A HREF = "GHC.Base.html#t%3AEq"
		>Eq</A
		> a =&gt; [a] -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Aintersect"
		>intersect</A
		> :: <A HREF = "GHC.Base.html#t%3AEq"
		>Eq</A
		> a =&gt; [a] -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Asort"
		>sort</A
		> :: <A HREF = "GHC.Base.html#t%3AOrd"
		>Ord</A
		> a =&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3Ainsert"
		>insert</A
		> :: <A HREF = "GHC.Base.html#t%3AOrd"
		>Ord</A
		> a =&gt; a -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AnubBy"
		>nubBy</A
		> :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AdeleteBy"
		>deleteBy</A
		> :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; a -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AdeleteFirstsBy"
		>deleteFirstsBy</A
		> :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AunionBy"
		>unionBy</A
		> :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AintersectBy"
		>intersectBy</A
		> :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AgroupBy"
		>groupBy</A
		> :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
		>Bool</A
		>) -&gt; [a] -&gt; [[a]]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AsortBy"
		>sortBy</A
		> :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3AOrdering"
		>Ordering</A
		>) -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AinsertBy"
		>insertBy</A
		> :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3AOrdering"
		>Ordering</A
		>) -&gt; a -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AmaximumBy"
		>maximumBy</A
		> :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3AOrdering"
		>Ordering</A
		>) -&gt; [a] -&gt; a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AminimumBy"
		>minimumBy</A
		> :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3AOrdering"
		>Ordering</A
		>) -&gt; [a] -&gt; a</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AgenericLength"
		>genericLength</A
		> :: <A HREF = "GHC.Num.html#t%3ANum"
		>Num</A
		> i =&gt; [b] -&gt; i</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AgenericTake"
		>genericTake</A
		> :: <A HREF = "GHC.Real.html#t%3AIntegral"
		>Integral</A
		> i =&gt; i -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AgenericDrop"
		>genericDrop</A
		> :: <A HREF = "GHC.Real.html#t%3AIntegral"
		>Integral</A
		> i =&gt; i -&gt; [a] -&gt; [a]</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AgenericSplitAt"
		>genericSplitAt</A
		> :: <A HREF = "GHC.Real.html#t%3AIntegral"
		>Integral</A
		> i =&gt; i -&gt; [b] -&gt; ([b], [b])</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AgenericIndex"
		>genericIndex</A
		> :: <A HREF = "GHC.Real.html#t%3AIntegral"
		>Integral</A
		> a =&gt; [b] -&gt; a -&gt; b</TD
	      ></TR
	    ><TR
	    ><TD CLASS = "s8"
	      ></TD
	      ></TR
	    ><TR
	    ><TD CLASS = "decl"
	      ><A HREF = "#v%3AgenericReplicate"
		>genericReplicate</A
		> :: <A HREF = "GHC.Real.html#t%3AIntegral"
		>Integral</A
		> i =&gt; i -&gt; a -&gt; [a]</TD
	      ></TR
	    ></TABLE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "1"
	  >Basic functions</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3A%2B%2B"
	  ></A
	  ><B
	  >(++)</B
	  > :: [a] -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >Append two lists, i.e.,
</P
	  ><PRE
	  > [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
 [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
</PRE
	  ><P
	  >If the first list is not finite, the result is the first list.</P
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Ahead"
	  ></A
	  ><B
	  >head</B
	  > :: [a] -&gt; a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Extract the first element of a list, which must be non-empty.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Alast"
	  ></A
	  ><B
	  >last</B
	  > :: [a] -&gt; a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Extract the last element of a list, which must be finite and non-empty.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Atail"
	  ></A
	  ><B
	  >tail</B
	  > :: [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Extract the elements after the head of a list, which must be non-empty.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Ainit"
	  ></A
	  ><B
	  >init</B
	  > :: [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Return all the elements of a list except the last one.
The list must be finite and non-empty.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Anull"
	  ></A
	  ><B
	  >null</B
	  > :: [a] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Test whether a list is empty.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Alength"
	  ></A
	  ><B
	  >length</B
	  > :: [a] -&gt; <A HREF = "GHC.Base.html#t%3AInt"
	  >Int</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Alength"
	    >length</A
	    ></TT
	  > returns the length of a finite list as an <TT
	  ><A HREF = "GHC.Base.html#t%3AInt"
	    >Int</A
	    ></TT
	  >.
It is an instance of the more general <TT
	  ><A HREF = "Data.List.html#v%3AgenericLength"
	    >genericLength</A
	    ></TT
	  >,
the result type of which may be any kind of number.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "2"
	  >List transformations</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Amap"
	  ></A
	  ><B
	  >map</B
	  > :: (a -&gt; b) -&gt; [a] -&gt; [b]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  ><TT
	    ><A HREF = "Data.List.html#v%3Amap"
	      >map</A
	      ></TT
	    > <TT
	    >f xs</TT
	    > is the list obtained by applying <TT
	    >f</TT
	    > to each element
of <TT
	    >xs</TT
	    >, i.e.,
</P
	  ><PRE
	  > map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
 map f [x1, x2, ...] == [f x1, f x2, ...]</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Areverse"
	  ></A
	  ><B
	  >reverse</B
	  > :: [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Areverse"
	    >reverse</A
	    ></TT
	  > <TT
	  >xs</TT
	  > returns the elements of <TT
	  >xs</TT
	  > in reverse order.
<TT
	  >xs</TT
	  > must be finite.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aintersperse"
	  ></A
	  ><B
	  >intersperse</B
	  > :: a -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >The <TT
	    ><A HREF = "Data.List.html#v%3Aintersperse"
	      >intersperse</A
	      ></TT
	    > function takes an element and a list and
`intersperses' that element between the elements of the list.
For example,
</P
	  ><PRE
	  > intersperse ',' &quot;abcde&quot; == &quot;a,b,c,d,e&quot;</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Atranspose"
	  ></A
	  ><B
	  >transpose</B
	  > :: [[a]] -&gt; [[a]]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >The <TT
	    ><A HREF = "Data.List.html#v%3Atranspose"
	      >transpose</A
	      ></TT
	    > function transposes the rows and columns of its argument.
For example,
</P
	  ><PRE
	  > transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "3"
	  >Reducing lists (folds)</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Afoldl"
	  ></A
	  ><B
	  >foldl</B
	  > :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  ><TT
	    ><A HREF = "Data.List.html#v%3Afoldl"
	      >foldl</A
	      ></TT
	    >, applied to a binary operator, a starting value (typically
the left-identity of the operator), and a list, reduces the list
using the binary operator, from left to right:
</P
	  ><PRE
	  > foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
</PRE
	  ><P
	  >The list must be finite.</P
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Afoldl'"
	  ></A
	  ><B
	  >foldl'</B
	  > :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>A strict version of <TT
	  ><A HREF = "Data.List.html#v%3Afoldl"
	    >foldl</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Afoldl1"
	  ></A
	  ><B
	  >foldl1</B
	  > :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Afoldl1"
	    >foldl1</A
	    ></TT
	  > is a variant of <TT
	  ><A HREF = "Data.List.html#v%3Afoldl"
	    >foldl</A
	    ></TT
	  > that has no starting value argument,
and thus must be applied to non-empty lists.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Afoldr"
	  ></A
	  ><B
	  >foldr</B
	  > :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  ><TT
	    ><A HREF = "Data.List.html#v%3Afoldr"
	      >foldr</A
	      ></TT
	    >, applied to a binary operator, a starting value (typically
the right-identity of the operator), and a list, reduces the list
using the binary operator, from right to left:
</P
	  ><PRE
	  > foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Afoldr1"
	  ></A
	  ><B
	  >foldr1</B
	  > :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Afoldr1"
	    >foldr1</A
	    ></TT
	  > is a variant of <TT
	  ><A HREF = "Data.List.html#v%3Afoldr"
	    >foldr</A
	    ></TT
	  > that has no starting value argument,
and thus must be applied to non-empty lists.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section2"
	><A NAME = "4"
	  >Special folds</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aconcat"
	  ></A
	  ><B
	  >concat</B
	  > :: [[a]] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Concatenate a list of lists.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AconcatMap"
	  ></A
	  ><B
	  >concatMap</B
	  > :: (a -&gt; [b]) -&gt; [a] -&gt; [b]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Map a function over a list and concatenate the results.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aand"
	  ></A
	  ><B
	  >and</B
	  > :: [<A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Aand"
	    >and</A
	    ></TT
	  > returns the conjunction of a Boolean list.  For the result to be
<TT
	  ><A HREF = "GHC.Base.html#v%3ATrue"
	    >True</A
	    ></TT
	  >, the list must be finite; <TT
	  ><A HREF = "GHC.Base.html#v%3AFalse"
	    >False</A
	    ></TT
	  >, however, results from a <TT
	  ><A HREF = "GHC.Base.html#v%3AFalse"
	    >False</A
	    ></TT
	  >
value at a finite index of a finite or infinite list.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aor"
	  ></A
	  ><B
	  >or</B
	  > :: [<A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Aor"
	    >or</A
	    ></TT
	  > returns the disjunction of a Boolean list.  For the result to be
<TT
	  ><A HREF = "GHC.Base.html#v%3AFalse"
	    >False</A
	    ></TT
	  >, the list must be finite; <TT
	  ><A HREF = "GHC.Base.html#v%3ATrue"
	    >True</A
	    ></TT
	  >, however, results from a <TT
	  ><A HREF = "GHC.Base.html#v%3ATrue"
	    >True</A
	    ></TT
	  >
value at a finite index of a finite or infinite list.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aany"
	  ></A
	  ><B
	  >any</B
	  > :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Applied to a predicate and a list, <TT
	  ><A HREF = "Data.List.html#v%3Aany"
	    >any</A
	    ></TT
	  > determines if any element
of the list satisfies the predicate.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aall"
	  ></A
	  ><B
	  >all</B
	  > :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>Applied to a predicate and a list, <TT
	  ><A HREF = "Data.List.html#v%3Aall"
	    >all</A
	    ></TT
	  > determines if all elements
of the list satisfy the predicate.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Asum"
	  ></A
	  ><B
	  >sum</B
	  > :: <A HREF = "GHC.Num.html#t%3ANum"
	  >Num</A
	  > a =&gt; [a] -&gt; a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Asum"
	    >sum</A
	    ></TT
	  > function computes the sum of a finite list of numbers.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aproduct"
	  ></A
	  ><B
	  >product</B
	  > :: <A HREF = "GHC.Num.html#t%3ANum"
	  >Num</A
	  > a =&gt; [a] -&gt; a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Aproduct"
	    >product</A
	    ></TT
	  > function computes the product of a finite list of numbers.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Amaximum"
	  ></A
	  ><B
	  >maximum</B
	  > :: <A HREF = "GHC.Base.html#t%3AOrd"
	  >Ord</A
	  > a =&gt; [a] -&gt; a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Amaximum"
	    >maximum</A
	    ></TT
	  > returns the maximum value from a list,
which must be non-empty, finite, and of an ordered type.
It is a special case of <TT
	  ><A HREF = "Data.List.html#v%3AmaximumBy"
	    >maximumBy</A
	    ></TT
	  >, which allows the
programmer to supply their own comparison function.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aminimum"
	  ></A
	  ><B
	  >minimum</B
	  > :: <A HREF = "GHC.Base.html#t%3AOrd"
	  >Ord</A
	  > a =&gt; [a] -&gt; a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Aminimum"
	    >minimum</A
	    ></TT
	  > returns the minimum value from a list,
which must be non-empty, finite, and of an ordered type.
It is a special case of <TT
	  ><A HREF = "Data.List.html#v%3AminimumBy"
	    >minimumBy</A
	    ></TT
	  >, which allows the
programmer to supply their own comparison function.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "5"
	  >Building lists</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section2"
	><A NAME = "6"
	  >Scans</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Ascanl"
	  ></A
	  ><B
	  >scanl</B
	  > :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  ><TT
	    ><A HREF = "Data.List.html#v%3Ascanl"
	      >scanl</A
	      ></TT
	    > is similar to <TT
	    ><A HREF = "Data.List.html#v%3Afoldl"
	      >foldl</A
	      ></TT
	    >, but returns a list of successive
reduced values from the left:
</P
	  ><PRE
	  > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
</PRE
	  ><P
	  >Note that
</P
	  ><PRE
	  > last (scanl f z xs) == foldl f z xs.</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Ascanl1"
	  ></A
	  ><B
	  >scanl1</B
	  > :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  ><TT
	    ><A HREF = "Data.List.html#v%3Ascanl1"
	      >scanl1</A
	      ></TT
	    > is a variant of <TT
	    ><A HREF = "Data.List.html#v%3Ascanl"
	      >scanl</A
	      ></TT
	    > that has no starting value argument:
</P
	  ><PRE
	  > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Ascanr"
	  ></A
	  ><B
	  >scanr</B
	  > :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  ><TT
	    ><A HREF = "Data.List.html#v%3Ascanr"
	      >scanr</A
	      ></TT
	    > is the right-to-left dual of <TT
	    ><A HREF = "Data.List.html#v%3Ascanl"
	      >scanl</A
	      ></TT
	    >.
Note that
</P
	  ><PRE
	  > head (scanr f z xs) == foldr f z xs.</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Ascanr1"
	  ></A
	  ><B
	  >scanr1</B
	  > :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Ascanr1"
	    >scanr1</A
	    ></TT
	  > is a variant of <TT
	  ><A HREF = "Data.List.html#v%3Ascanr"
	    >scanr</A
	    ></TT
	  > that has no starting value argument.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section2"
	><A NAME = "7"
	  >Accumulating maps</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AmapAccumL"
	  ></A
	  ><B
	  >mapAccumL</B
	  > :: (acc -&gt; x -&gt; (acc, y)) -&gt; acc -&gt; [x] -&gt; (acc, [y])</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AmapAccumL"
	    >mapAccumL</A
	    ></TT
	  > function behaves like a combination of <TT
	  ><A HREF = "Data.List.html#v%3Amap"
	    >map</A
	    ></TT
	  > and
<TT
	  ><A HREF = "Data.List.html#v%3Afoldl"
	    >foldl</A
	    ></TT
	  >; it applies a function to each element of a list, passing
an accumulating parameter from left to right, and returning a final
value of this accumulator together with the new list.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AmapAccumR"
	  ></A
	  ><B
	  >mapAccumR</B
	  > :: (acc -&gt; x -&gt; (acc, y)) -&gt; acc -&gt; [x] -&gt; (acc, [y])</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AmapAccumR"
	    >mapAccumR</A
	    ></TT
	  > function behaves like a combination of <TT
	  ><A HREF = "Data.List.html#v%3Amap"
	    >map</A
	    ></TT
	  > and
<TT
	  ><A HREF = "Data.List.html#v%3Afoldr"
	    >foldr</A
	    ></TT
	  >; it applies a function to each element of a list, passing
an accumulating parameter from right to left, and returning a final
value of this accumulator together with the new list.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section2"
	><A NAME = "8"
	  >Infinite lists</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aiterate"
	  ></A
	  ><B
	  >iterate</B
	  > :: (a -&gt; a) -&gt; a -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  ><TT
	    ><A HREF = "Data.List.html#v%3Aiterate"
	      >iterate</A
	      ></TT
	    > <TT
	    >f x</TT
	    > returns an infinite list of repeated applications
of <TT
	    >f</TT
	    > to <TT
	    >x</TT
	    >:
</P
	  ><PRE
	  > iterate f x == [x, f x, f (f x), ...]</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Arepeat"
	  ></A
	  ><B
	  >repeat</B
	  > :: a -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Arepeat"
	    >repeat</A
	    ></TT
	  > <TT
	  >x</TT
	  > is an infinite list, with <TT
	  >x</TT
	  > the value of every element.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Areplicate"
	  ></A
	  ><B
	  >replicate</B
	  > :: <A HREF = "GHC.Base.html#t%3AInt"
	  >Int</A
	  > -&gt; a -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Areplicate"
	    >replicate</A
	    ></TT
	  > <TT
	  >n x</TT
	  > is a list of length <TT
	  >n</TT
	  > with <TT
	  >x</TT
	  > the value of
every element.
It is an instance of the more general <TT
	  ><A HREF = "Data.List.html#v%3AgenericReplicate"
	    >genericReplicate</A
	    ></TT
	  >,
in which <TT
	  >n</TT
	  > may be of any integral type.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Acycle"
	  ></A
	  ><B
	  >cycle</B
	  > :: [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Acycle"
	    >cycle</A
	    ></TT
	  > ties a finite list into a circular one, or equivalently,
the infinite repetition of the original list.  It is the identity
on infinite lists.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section2"
	><A NAME = "9"
	  >Unfolding</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aunfoldr"
	  ></A
	  ><B
	  >unfoldr</B
	  > :: (b -&gt; <A HREF = "Data.Maybe.html#t%3AMaybe"
	  >Maybe</A
	  > (a, b)) -&gt; b -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >The <TT
	    ><A HREF = "Data.List.html#v%3Aunfoldr"
	      >unfoldr</A
	      ></TT
	    > function is a `dual' to <TT
	    ><A HREF = "Data.List.html#v%3Afoldr"
	      >foldr</A
	      ></TT
	    >: while <TT
	    ><A HREF = "Data.List.html#v%3Afoldr"
	      >foldr</A
	      ></TT
	    >
reduces a list to a summary value, <TT
	    ><A HREF = "Data.List.html#v%3Aunfoldr"
	      >unfoldr</A
	      ></TT
	    > builds a list from
a seed value.  The function takes the element and returns <TT
	    ><A HREF = "Data.Maybe.html#v%3ANothing"
	      >Nothing</A
	      ></TT
	    >
if it is done producing the list or returns <TT
	    ><A HREF = "Data.Maybe.html#v%3AJust"
	      >Just</A
	      ></TT
	    > <TT
	    >(a,b)</TT
	    >, in which
case, <TT
	    >a</TT
	    > is a prepended to the list and <TT
	    >b</TT
	    > is used as the next
element in a recursive call.  For example,
</P
	  ><PRE
	  > iterate f == unfoldr (\x -&gt; Just (x, f x))
</PRE
	  ><P
	  >In some cases, <TT
	    ><A HREF = "Data.List.html#v%3Aunfoldr"
	      >unfoldr</A
	      ></TT
	    > can undo a <TT
	    ><A HREF = "Data.List.html#v%3Afoldr"
	      >foldr</A
	      ></TT
	    > operation:
</P
	  ><PRE
	  > unfoldr f' (foldr f z xs) == xs
</PRE
	  ><P
	  >if the following holds:
</P
	  ><PRE
	  > f' (f x y) = Just (x,y)
 f' z       = Nothing</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "10"
	  >Sublists</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section2"
	><A NAME = "11"
	  >Extracting sublists</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Atake"
	  ></A
	  ><B
	  >take</B
	  > :: <A HREF = "GHC.Base.html#t%3AInt"
	  >Int</A
	  > -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Atake"
	    >take</A
	    ></TT
	  > <TT
	  >n</TT
	  >, applied to a list <TT
	  >xs</TT
	  >, returns the prefix of <TT
	  >xs</TT
	  >
of length <TT
	  >n</TT
	  >, or <TT
	  >xs</TT
	  > itself if <TT
	  >n &gt; <TT
	    ><A HREF = "Data.List.html#v%3Alength"
	      >length</A
	      ></TT
	    > xs</TT
	  >.
It is an instance of the more general <TT
	  ><A HREF = "Data.List.html#v%3AgenericTake"
	    >genericTake</A
	    ></TT
	  >,
in which <TT
	  >n</TT
	  > may be of any integral type.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Adrop"
	  ></A
	  ><B
	  >drop</B
	  > :: <A HREF = "GHC.Base.html#t%3AInt"
	  >Int</A
	  > -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Adrop"
	    >drop</A
	    ></TT
	  > <TT
	  >n xs</TT
	  > returns the suffix of <TT
	  >xs</TT
	  >
after the first <TT
	  >n</TT
	  > elements, or <TT
	  >[]</TT
	  > if <TT
	  >n &gt; <TT
	    ><A HREF = "Data.List.html#v%3Alength"
	      >length</A
	      ></TT
	    > xs</TT
	  >.
It is an instance of the more general <TT
	  ><A HREF = "Data.List.html#v%3AgenericDrop"
	    >genericDrop</A
	    ></TT
	  >,
in which <TT
	  >n</TT
	  > may be of any integral type.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AsplitAt"
	  ></A
	  ><B
	  >splitAt</B
	  > :: <A HREF = "GHC.Base.html#t%3AInt"
	  >Int</A
	  > -&gt; [a] -&gt; ([a], [a])</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3AsplitAt"
	    >splitAt</A
	    ></TT
	  > <TT
	  >n xs</TT
	  > is equivalent to <TT
	  >(<TT
	    ><A HREF = "Data.List.html#v%3Atake"
	      >take</A
	      ></TT
	    > n xs, <TT
	    ><A HREF = "Data.List.html#v%3Adrop"
	      >drop</A
	      ></TT
	    > n xs)</TT
	  >.
It is an instance of the more general <TT
	  ><A HREF = "Data.List.html#v%3AgenericSplitAt"
	    >genericSplitAt</A
	    ></TT
	  >,
in which <TT
	  >n</TT
	  > may be of any integral type.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AtakeWhile"
	  ></A
	  ><B
	  >takeWhile</B
	  > :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3AtakeWhile"
	    >takeWhile</A
	    ></TT
	  >, applied to a predicate <TT
	  >p</TT
	  > and a list <TT
	  >xs</TT
	  >, returns the
longest prefix (possibly empty) of <TT
	  >xs</TT
	  > of elements that satisfy <TT
	  >p</TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AdropWhile"
	  ></A
	  ><B
	  >dropWhile</B
	  > :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3AdropWhile"
	    >dropWhile</A
	    ></TT
	  > <TT
	  >p xs</TT
	  > returns the suffix remaining after <TT
	  ><A HREF = "Data.List.html#v%3AtakeWhile"
	    >takeWhile</A
	    ></TT
	  > <TT
	  >p xs</TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aspan"
	  ></A
	  ><B
	  >span</B
	  > :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; ([a], [a])</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Aspan"
	    >span</A
	    ></TT
	  > <TT
	  >p xs</TT
	  > is equivalent to <TT
	  >(<TT
	    ><A HREF = "Data.List.html#v%3AtakeWhile"
	      >takeWhile</A
	      ></TT
	    > p xs, <TT
	    ><A HREF = "Data.List.html#v%3AdropWhile"
	      >dropWhile</A
	      ></TT
	    > p xs)</TT
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Abreak"
	  ></A
	  ><B
	  >break</B
	  > :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; ([a], [a])</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Abreak"
	    >break</A
	    ></TT
	  > <TT
	  >p</TT
	  > is equivalent to <TT
	  ><TT
	    ><A HREF = "Data.List.html#v%3Aspan"
	      >span</A
	      ></TT
	    > (<TT
	    ><A HREF = "GHC.Base.html#v%3Anot"
	      >not</A
	      ></TT
	    > . p)</TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Agroup"
	  ></A
	  ><B
	  >group</B
	  > :: <A HREF = "GHC.Base.html#t%3AEq"
	  >Eq</A
	  > a =&gt; [a] -&gt; [[a]]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >The <TT
	    ><A HREF = "Data.List.html#v%3Agroup"
	      >group</A
	      ></TT
	    > function takes a list and returns a list of lists such
that the concatenation of the result is equal to the argument.  Moreover,
each sublist in the result contains only equal elements.  For example,
</P
	  ><PRE
	  > group &quot;Mississippi&quot; = [&quot;M&quot;,&quot;i&quot;,&quot;ss&quot;,&quot;i&quot;,&quot;ss&quot;,&quot;i&quot;,&quot;pp&quot;,&quot;i&quot;]
</PRE
	  ><P
	  >It is a special case of <TT
	    ><A HREF = "Data.List.html#v%3AgroupBy"
	      >groupBy</A
	      ></TT
	    >, which allows the programmer to supply
their own equality test.</P
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Ainits"
	  ></A
	  ><B
	  >inits</B
	  > :: [a] -&gt; [[a]]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >The <TT
	    ><A HREF = "Data.List.html#v%3Ainits"
	      >inits</A
	      ></TT
	    > function returns all initial segments of the argument,
shortest first.  For example,
</P
	  ><PRE
	  > inits &quot;abc&quot; == [&quot;&quot;,&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;]
</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Atails"
	  ></A
	  ><B
	  >tails</B
	  > :: [a] -&gt; [[a]]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >The <TT
	    ><A HREF = "Data.List.html#v%3Atails"
	      >tails</A
	      ></TT
	    > function returns all final segments of the argument,
longest first.  For example,
</P
	  ><PRE
	  > tails &quot;abc&quot; == [&quot;abc&quot;, &quot;bc&quot;, &quot;c&quot;,&quot;&quot;]
</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section2"
	><A NAME = "12"
	  >Predicates</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AisPrefixOf"
	  ></A
	  ><B
	  >isPrefixOf</B
	  > :: <A HREF = "GHC.Base.html#t%3AEq"
	  >Eq</A
	  > a =&gt; [a] -&gt; [a] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AisPrefixOf"
	    >isPrefixOf</A
	    ></TT
	  > function takes two lists and returns <TT
	  ><A HREF = "GHC.Base.html#v%3ATrue"
	    >True</A
	    ></TT
	  >
iff the first list is a prefix of the second.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AisSuffixOf"
	  ></A
	  ><B
	  >isSuffixOf</B
	  > :: <A HREF = "GHC.Base.html#t%3AEq"
	  >Eq</A
	  > a =&gt; [a] -&gt; [a] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AisSuffixOf"
	    >isSuffixOf</A
	    ></TT
	  > function takes two lists and returns <TT
	  ><A HREF = "GHC.Base.html#v%3ATrue"
	    >True</A
	    ></TT
	  >
iff the first list is a suffix of the second.
Both lists must be finite.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "13"
	  >Searching lists</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section2"
	><A NAME = "14"
	  >Searching by equality</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aelem"
	  ></A
	  ><B
	  >elem</B
	  > :: <A HREF = "GHC.Base.html#t%3AEq"
	  >Eq</A
	  > a =&gt; a -&gt; [a] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Aelem"
	    >elem</A
	    ></TT
	  > is the list membership predicate, usually written in infix form,
e.g., <TT
	  >x <TT
	    ><A HREF = "Data.List.html#v%3Aelem"
	      >elem</A
	      ></TT
	    > xs</TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AnotElem"
	  ></A
	  ><B
	  >notElem</B
	  > :: <A HREF = "GHC.Base.html#t%3AEq"
	  >Eq</A
	  > a =&gt; a -&gt; [a] -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3AnotElem"
	    >notElem</A
	    ></TT
	  > is the negation of <TT
	  ><A HREF = "Data.List.html#v%3Aelem"
	    >elem</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Alookup"
	  ></A
	  ><B
	  >lookup</B
	  > :: <A HREF = "GHC.Base.html#t%3AEq"
	  >Eq</A
	  > a =&gt; a -&gt; [(a, b)] -&gt; <A HREF = "Data.Maybe.html#t%3AMaybe"
	  >Maybe</A
	  > b</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Alookup"
	    >lookup</A
	    ></TT
	  > <TT
	  >key assocs</TT
	  > looks up a key in an association list.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section2"
	><A NAME = "15"
	  >Searching with a predicate</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Afind"
	  ></A
	  ><B
	  >find</B
	  > :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; <A HREF = "Data.Maybe.html#t%3AMaybe"
	  >Maybe</A
	  > a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Afind"
	    >find</A
	    ></TT
	  > function takes a predicate and a list and returns the
first element in the list matching the predicate, or <TT
	  ><A HREF = "Data.Maybe.html#v%3ANothing"
	    >Nothing</A
	    ></TT
	  > if
there is no such element.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Afilter"
	  ></A
	  ><B
	  >filter</B
	  > :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  ><TT
	    ><A HREF = "Data.List.html#v%3Afilter"
	      >filter</A
	      ></TT
	    >, applied to a predicate and a list, returns the list of
those elements that satisfy the predicate; i.e.,
</P
	  ><PRE
	  > filter p xs = [ x | x &lt;- xs, p x]</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Apartition"
	  ></A
	  ><B
	  >partition</B
	  > :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; ([a], [a])</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >The <TT
	    ><A HREF = "Data.List.html#v%3Apartition"
	      >partition</A
	      ></TT
	    > function takes a predicate a list and returns
the pair of lists of elements which do and do not satisfy the
predicate, respectively; i.e.,
</P
	  ><PRE
	  > partition p xs == (filter p xs, filter (not . p) xs)</PRE
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "16"
	  >Indexing lists</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>These functions treat a list <TT
	  >xs</TT
	  > as a indexed collection,
with indices ranging from 0 to <TT
	  ><TT
	    ><A HREF = "Data.List.html#v%3Alength"
	      >length</A
	      ></TT
	    > xs - 1</TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3A!!"
	  ></A
	  ><B
	  >(!!)</B
	  > :: [a] -&gt; <A HREF = "GHC.Base.html#t%3AInt"
	  >Int</A
	  > -&gt; a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>List index (subscript) operator, starting from 0.
It is an instance of the more general <TT
	  ><A HREF = "Data.List.html#v%3AgenericIndex"
	    >genericIndex</A
	    ></TT
	  >,
which takes an index of any integral type.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AelemIndex"
	  ></A
	  ><B
	  >elemIndex</B
	  > :: <A HREF = "GHC.Base.html#t%3AEq"
	  >Eq</A
	  > a =&gt; a -&gt; [a] -&gt; <A HREF = "Data.Maybe.html#t%3AMaybe"
	  >Maybe</A
	  > <A HREF = "GHC.Base.html#t%3AInt"
	  >Int</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AelemIndex"
	    >elemIndex</A
	    ></TT
	  > function returns the index of the first element
in the given list which is equal (by <TT
	  ><A HREF = "GHC.Base.html#v%3A%3D%3D"
	    >==</A
	    ></TT
	  >) to the query element,
or <TT
	  ><A HREF = "Data.Maybe.html#v%3ANothing"
	    >Nothing</A
	    ></TT
	  > if there is no such element.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AelemIndices"
	  ></A
	  ><B
	  >elemIndices</B
	  > :: <A HREF = "GHC.Base.html#t%3AEq"
	  >Eq</A
	  > a =&gt; a -&gt; [a] -&gt; [<A HREF = "GHC.Base.html#t%3AInt"
	  >Int</A
	  >]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AelemIndices"
	    >elemIndices</A
	    ></TT
	  > function extends <TT
	  ><A HREF = "Data.List.html#v%3AelemIndex"
	    >elemIndex</A
	    ></TT
	  >, by returning the
indices of all elements equal to the query element, in ascending order.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AfindIndex"
	  ></A
	  ><B
	  >findIndex</B
	  > :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; <A HREF = "Data.Maybe.html#t%3AMaybe"
	  >Maybe</A
	  > <A HREF = "GHC.Base.html#t%3AInt"
	  >Int</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AfindIndex"
	    >findIndex</A
	    ></TT
	  > function takes a predicate and a list and returns
the index of the first element in the list satisfying the predicate,
or <TT
	  ><A HREF = "Data.Maybe.html#v%3ANothing"
	    >Nothing</A
	    ></TT
	  > if there is no such element.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AfindIndices"
	  ></A
	  ><B
	  >findIndices</B
	  > :: (a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; [<A HREF = "GHC.Base.html#t%3AInt"
	  >Int</A
	  >]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AfindIndices"
	    >findIndices</A
	    ></TT
	  > function extends <TT
	  ><A HREF = "Data.List.html#v%3AfindIndex"
	    >findIndex</A
	    ></TT
	  >, by returning the
indices of all elements satisfying the predicate, in ascending order.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "17"
	  >Zipping and unzipping lists</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Azip"
	  ></A
	  ><B
	  >zip</B
	  > :: [a] -&gt; [b] -&gt; [(a, b)]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Azip"
	    >zip</A
	    ></TT
	  > takes two lists and returns a list of corresponding pairs.
If one input list is short, excess elements of the longer list are
discarded.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Azip3"
	  ></A
	  ><B
	  >zip3</B
	  > :: [a] -&gt; [b] -&gt; [c] -&gt; [(a, b, c)]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Azip3"
	    >zip3</A
	    ></TT
	  > takes three lists and returns a list of triples, analogous to
<TT
	  ><A HREF = "Data.List.html#v%3Azip"
	    >zip</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Azip4"
	  ></A
	  ><B
	  >zip4</B
	  > :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [(a, b, c, d)]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Azip4"
	    >zip4</A
	    ></TT
	  > function takes four lists and returns a list of
quadruples, analogous to <TT
	  ><A HREF = "Data.List.html#v%3Azip"
	    >zip</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Azip5"
	  ></A
	  ><B
	  >zip5</B
	  > :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [(a, b, c, d, e)]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Azip5"
	    >zip5</A
	    ></TT
	  > function takes five lists and returns a list of
five-tuples, analogous to <TT
	  ><A HREF = "Data.List.html#v%3Azip"
	    >zip</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Azip6"
	  ></A
	  ><B
	  >zip6</B
	  > :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [(a, b, c, d, e, f)]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Azip6"
	    >zip6</A
	    ></TT
	  > function takes six lists and returns a list of six-tuples,
analogous to <TT
	  ><A HREF = "Data.List.html#v%3Azip"
	    >zip</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Azip7"
	  ></A
	  ><B
	  >zip7</B
	  > :: [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [g] -&gt; [(a, b, c, d, e, f, g)]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Azip7"
	    >zip7</A
	    ></TT
	  > function takes seven lists and returns a list of
seven-tuples, analogous to <TT
	  ><A HREF = "Data.List.html#v%3Azip"
	    >zip</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AzipWith"
	  ></A
	  ><B
	  >zipWith</B
	  > :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3AzipWith"
	    >zipWith</A
	    ></TT
	  > generalises <TT
	  ><A HREF = "Data.List.html#v%3Azip"
	    >zip</A
	    ></TT
	  > by zipping with the function given
as the first argument, instead of a tupling function.
For example, <TT
	  ><TT
	    ><A HREF = "Data.List.html#v%3AzipWith"
	      >zipWith</A
	      ></TT
	    > (+)</TT
	  > is applied to two lists to produce the
list of corresponding sums.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AzipWith3"
	  ></A
	  ><B
	  >zipWith3</B
	  > :: (a -&gt; b -&gt; c -&gt; d) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AzipWith3"
	    >zipWith3</A
	    ></TT
	  > function takes a function which combines three
elements, as well as three lists and returns a list of their point-wise
combination, analogous to <TT
	  ><A HREF = "Data.List.html#v%3AzipWith"
	    >zipWith</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AzipWith4"
	  ></A
	  ><B
	  >zipWith4</B
	  > :: (a -&gt; b -&gt; c -&gt; d -&gt; e) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AzipWith4"
	    >zipWith4</A
	    ></TT
	  > function takes a function which combines four
elements, as well as four lists and returns a list of their point-wise
combination, analogous to <TT
	  ><A HREF = "Data.List.html#v%3AzipWith"
	    >zipWith</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AzipWith5"
	  ></A
	  ><B
	  >zipWith5</B
	  > :: (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AzipWith5"
	    >zipWith5</A
	    ></TT
	  > function takes a function which combines five
elements, as well as five lists and returns a list of their point-wise
combination, analogous to <TT
	  ><A HREF = "Data.List.html#v%3AzipWith"
	    >zipWith</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AzipWith6"
	  ></A
	  ><B
	  >zipWith6</B
	  > :: (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [g]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AzipWith6"
	    >zipWith6</A
	    ></TT
	  > function takes a function which combines six
elements, as well as six lists and returns a list of their point-wise
combination, analogous to <TT
	  ><A HREF = "Data.List.html#v%3AzipWith"
	    >zipWith</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AzipWith7"
	  ></A
	  ><B
	  >zipWith7</B
	  > :: (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; f -&gt; g -&gt; h) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] -&gt; [e] -&gt; [f] -&gt; [g] -&gt; [h]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AzipWith7"
	    >zipWith7</A
	    ></TT
	  > function takes a function which combines seven
elements, as well as seven lists and returns a list of their point-wise
combination, analogous to <TT
	  ><A HREF = "Data.List.html#v%3AzipWith"
	    >zipWith</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aunzip"
	  ></A
	  ><B
	  >unzip</B
	  > :: [(a, b)] -&gt; ([a], [b])</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Aunzip"
	    >unzip</A
	    ></TT
	  > transforms a list of pairs into a list of first components
and a list of second components.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aunzip3"
	  ></A
	  ><B
	  >unzip3</B
	  > :: [(a, b, c)] -&gt; ([a], [b], [c])</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Aunzip3"
	    >unzip3</A
	    ></TT
	  > function takes a list of triples and returns three
lists, analogous to <TT
	  ><A HREF = "Data.List.html#v%3Aunzip"
	    >unzip</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aunzip4"
	  ></A
	  ><B
	  >unzip4</B
	  > :: [(a, b, c, d)] -&gt; ([a], [b], [c], [d])</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Aunzip4"
	    >unzip4</A
	    ></TT
	  > function takes a list of quadruples and returns four
lists, analogous to <TT
	  ><A HREF = "Data.List.html#v%3Aunzip"
	    >unzip</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aunzip5"
	  ></A
	  ><B
	  >unzip5</B
	  > :: [(a, b, c, d, e)] -&gt; ([a], [b], [c], [d], [e])</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Aunzip5"
	    >unzip5</A
	    ></TT
	  > function takes a list of five-tuples and returns five
lists, analogous to <TT
	  ><A HREF = "Data.List.html#v%3Aunzip"
	    >unzip</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aunzip6"
	  ></A
	  ><B
	  >unzip6</B
	  > :: [(a, b, c, d, e, f)] -&gt; ([a], [b], [c], [d], [e], [f])</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Aunzip6"
	    >unzip6</A
	    ></TT
	  > function takes a list of six-tuples and returns six
lists, analogous to <TT
	  ><A HREF = "Data.List.html#v%3Aunzip"
	    >unzip</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aunzip7"
	  ></A
	  ><B
	  >unzip7</B
	  > :: [(a, b, c, d, e, f, g)] -&gt; ([a], [b], [c], [d], [e], [f], [g])</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Aunzip7"
	    >unzip7</A
	    ></TT
	  > function takes a list of seven-tuples and returns
seven lists, analogous to <TT
	  ><A HREF = "Data.List.html#v%3Aunzip"
	    >unzip</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "18"
	  >Special lists</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section2"
	><A NAME = "19"
	  >Functions on strings</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Alines"
	  ></A
	  ><B
	  >lines</B
	  > :: <A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  > -&gt; [<A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  >]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Alines"
	    >lines</A
	    ></TT
	  > breaks a string up into a list of strings at newline
characters.  The resulting strings do not contain newlines.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Awords"
	  ></A
	  ><B
	  >words</B
	  > :: <A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  > -&gt; [<A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  >]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Awords"
	    >words</A
	    ></TT
	  > breaks a string up into a list of words, which were delimited
by white space.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aunlines"
	  ></A
	  ><B
	  >unlines</B
	  > :: [<A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  >] -&gt; <A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Aunlines"
	    >unlines</A
	    ></TT
	  > is an inverse operation to <TT
	  ><A HREF = "Data.List.html#v%3Alines"
	    >lines</A
	    ></TT
	  >.
It joins lines, after appending a terminating newline to each.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aunwords"
	  ></A
	  ><B
	  >unwords</B
	  > :: [<A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  >] -&gt; <A HREF = "GHC.Base.html#t%3AString"
	  >String</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><TT
	  ><A HREF = "Data.List.html#v%3Aunwords"
	    >unwords</A
	    ></TT
	  > is an inverse operation to <TT
	  ><A HREF = "Data.List.html#v%3Awords"
	    >words</A
	    ></TT
	  >.
It joins words with separating spaces.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section2"
	><A NAME = "20"
	  >&quot;Set&quot; operations</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Anub"
	  ></A
	  ><B
	  >nub</B
	  > :: <A HREF = "GHC.Base.html#t%3AEq"
	  >Eq</A
	  > a =&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Anub"
	    >nub</A
	    ></TT
	  > function removes duplicate elements from a list.
In particular, it keeps only the first occurrence of each element.
(The name <TT
	  ><A HREF = "Data.List.html#v%3Anub"
	    >nub</A
	    ></TT
	  > means `essence'.)
It is a special case of <TT
	  ><A HREF = "Data.List.html#v%3AnubBy"
	    >nubBy</A
	    ></TT
	  >, which allows the programmer to supply
their own equality test.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Adelete"
	  ></A
	  ><B
	  >delete</B
	  > :: <A HREF = "GHC.Base.html#t%3AEq"
	  >Eq</A
	  > a =&gt; a -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  ><TT
	    ><A HREF = "Data.List.html#v%3Adelete"
	      >delete</A
	      ></TT
	    > <TT
	    >x</TT
	    > removes the first occurrence of <TT
	    >x</TT
	    > from its list argument.
For example,
</P
	  ><PRE
	  > delete 'a' &quot;banana&quot; == &quot;bnana&quot;
</PRE
	  ><P
	  >It is a special case of <TT
	    ><A HREF = "Data.List.html#v%3AdeleteBy"
	      >deleteBy</A
	      ></TT
	    >, which allows the programmer to
supply their own equality test.</P
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3A%5C%5C"
	  ></A
	  ><B
	  >(\\)</B
	  > :: <A HREF = "GHC.Base.html#t%3AEq"
	  >Eq</A
	  > a =&gt; [a] -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >The <TT
	    ><A HREF = "Data.List.html#v%3A%5C%5C"
	      >\\</A
	      ></TT
	    > function is list difference ((non-associative).
In the result of <TT
	    >xs</TT
	    > <TT
	    ><A HREF = "Data.List.html#v%3A%5C%5C"
	      >\\</A
	      ></TT
	    > <TT
	    >ys</TT
	    >, the first occurrence of each element of
<TT
	    >ys</TT
	    > in turn (if any) has been removed from <TT
	    >xs</TT
	    >.  Thus
</P
	  ><PRE
	  > (xs ++ ys) \\ xs == ys.
</PRE
	  ><P
	  >It is a special case of <TT
	    ><A HREF = "Data.List.html#v%3AdeleteFirstsBy"
	      >deleteFirstsBy</A
	      ></TT
	    >, which allows the programmer
to supply their own equality test.</P
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aunion"
	  ></A
	  ><B
	  >union</B
	  > :: <A HREF = "GHC.Base.html#t%3AEq"
	  >Eq</A
	  > a =&gt; [a] -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >The <TT
	    ><A HREF = "Data.List.html#v%3Aunion"
	      >union</A
	      ></TT
	    > function returns the list union of the two lists.
For example,
</P
	  ><PRE
	  > &quot;dog&quot; `union` &quot;cow&quot; == &quot;dogcw&quot;
</PRE
	  ><P
	  >Duplicates, and elements of the first list, are removed from the
the second list, but if the first list contains duplicates, so will
the result.
It is a special case of <TT
	    ><A HREF = "Data.List.html#v%3AunionBy"
	      >unionBy</A
	      ></TT
	    >, which allows the programmer to supply
their own equality test.</P
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Aintersect"
	  ></A
	  ><B
	  >intersect</B
	  > :: <A HREF = "GHC.Base.html#t%3AEq"
	  >Eq</A
	  > a =&gt; [a] -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	><P
	  >The <TT
	    ><A HREF = "Data.List.html#v%3Aintersect"
	      >intersect</A
	      ></TT
	    > function takes the list intersection of two lists.
For example,
</P
	  ><PRE
	  > [1,2,3,4] `intersect` [2,4,6,8] == [2,4]
</PRE
	  ><P
	  >If the first list contains duplicates, so will the result.
It is a special case of <TT
	    ><A HREF = "Data.List.html#v%3AintersectBy"
	      >intersectBy</A
	      ></TT
	    >, which allows the programmer to
supply their own equality test.</P
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section2"
	><A NAME = "21"
	  >Ordered lists</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Asort"
	  ></A
	  ><B
	  >sort</B
	  > :: <A HREF = "GHC.Base.html#t%3AOrd"
	  >Ord</A
	  > a =&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Asort"
	    >sort</A
	    ></TT
	  > function implements a stable sorting algorithm.
It is a special case of <TT
	  ><A HREF = "Data.List.html#v%3AsortBy"
	    >sortBy</A
	    ></TT
	  >, which allows the programmer to supply
their own comparison function.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3Ainsert"
	  ></A
	  ><B
	  >insert</B
	  > :: <A HREF = "GHC.Base.html#t%3AOrd"
	  >Ord</A
	  > a =&gt; a -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3Ainsert"
	    >insert</A
	    ></TT
	  > function takes an element and a list and inserts the
element into the list at the last position where it is still less
than or equal to the next element.  In particular, if the list
is sorted before the call, the result will also be sorted.
It is a special case of <TT
	  ><A HREF = "Data.List.html#v%3AinsertBy"
	    >insertBy</A
	    ></TT
	  >, which allows the programmer to
supply their own comparison function.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section1"
	><A NAME = "22"
	  >Generalized functions</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section2"
	><A NAME = "23"
	  >The &quot;<TT
	    >By</TT
	    >&quot; operations</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>By convention, overloaded functions have a non-overloaded
counterpart whose name is suffixed with `<TT
	  >By</TT
	  >'.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section3"
	><A NAME = "24"
	  >User-supplied equality (replacing an <TT
	    >Eq</TT
	    > context)</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The predicate is assumed to define an equivalence.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AnubBy"
	  ></A
	  ><B
	  >nubBy</B
	  > :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AnubBy"
	    >nubBy</A
	    ></TT
	  > function behaves just like <TT
	  ><A HREF = "Data.List.html#v%3Anub"
	    >nub</A
	    ></TT
	  >, except it uses a
user-supplied equality predicate instead of the overloaded <TT
	  ><A HREF = "GHC.Base.html#v%3A%3D%3D"
	    >==</A
	    ></TT
	  >
function.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AdeleteBy"
	  ></A
	  ><B
	  >deleteBy</B
	  > :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; a -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AdeleteBy"
	    >deleteBy</A
	    ></TT
	  > function behaves like <TT
	  ><A HREF = "Data.List.html#v%3Adelete"
	    >delete</A
	    ></TT
	  >, but takes a
user-supplied equality predicate.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AdeleteFirstsBy"
	  ></A
	  ><B
	  >deleteFirstsBy</B
	  > :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AdeleteFirstsBy"
	    >deleteFirstsBy</A
	    ></TT
	  > function takes a predicate and two lists and
returns the first list with the first occurrence of each element of
the second list removed.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AunionBy"
	  ></A
	  ><B
	  >unionBy</B
	  > :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AunionBy"
	    >unionBy</A
	    ></TT
	  > function is the non-overloaded version of <TT
	  ><A HREF = "Data.List.html#v%3Aunion"
	    >union</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AintersectBy"
	  ></A
	  ><B
	  >intersectBy</B
	  > :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AintersectBy"
	    >intersectBy</A
	    ></TT
	  > function is the non-overloaded version of <TT
	  ><A HREF = "Data.List.html#v%3Aintersect"
	    >intersect</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AgroupBy"
	  ></A
	  ><B
	  >groupBy</B
	  > :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3ABool"
	  >Bool</A
	  >) -&gt; [a] -&gt; [[a]]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AgroupBy"
	    >groupBy</A
	    ></TT
	  > function is the non-overloaded version of <TT
	  ><A HREF = "Data.List.html#v%3Agroup"
	    >group</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section3"
	><A NAME = "25"
	  >User-supplied comparison (replacing an <TT
	    >Ord</TT
	    > context)</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The function is assumed to define a total ordering.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AsortBy"
	  ></A
	  ><B
	  >sortBy</B
	  > :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3AOrdering"
	  >Ordering</A
	  >) -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AsortBy"
	    >sortBy</A
	    ></TT
	  > function is the non-overloaded version of <TT
	  ><A HREF = "Data.List.html#v%3Asort"
	    >sort</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AinsertBy"
	  ></A
	  ><B
	  >insertBy</B
	  > :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3AOrdering"
	  >Ordering</A
	  >) -&gt; a -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The non-overloaded version of <TT
	  ><A HREF = "Data.List.html#v%3Ainsert"
	    >insert</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AmaximumBy"
	  ></A
	  ><B
	  >maximumBy</B
	  > :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3AOrdering"
	  >Ordering</A
	  >) -&gt; [a] -&gt; a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AmaximumBy"
	    >maximumBy</A
	    ></TT
	  > function takes a comparison function and a list
and returns the greatest element of the list by the comparison function.
The list must be finite and non-empty.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AminimumBy"
	  ></A
	  ><B
	  >minimumBy</B
	  > :: (a -&gt; a -&gt; <A HREF = "GHC.Base.html#t%3AOrdering"
	  >Ordering</A
	  >) -&gt; [a] -&gt; a</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AminimumBy"
	    >minimumBy</A
	    ></TT
	  > function takes a comparison function and a list
and returns the least element of the list by the comparison function.
The list must be finite and non-empty.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "section2"
	><A NAME = "26"
	  >The &quot;<TT
	    >generic</TT
	    >&quot; operations</A
	  ></TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The prefix `<TT
	  >generic</TT
	  >' indicates an overloaded function that
is a generalized version of a <A HREF = "Prelude.html"
	  >Prelude</A
	  > function.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AgenericLength"
	  ></A
	  ><B
	  >genericLength</B
	  > :: <A HREF = "GHC.Num.html#t%3ANum"
	  >Num</A
	  > i =&gt; [b] -&gt; i</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AgenericLength"
	    >genericLength</A
	    ></TT
	  > function is an overloaded version of <TT
	  ><A HREF = "Data.List.html#v%3Alength"
	    >length</A
	    ></TT
	  >.  In
particular, instead of returning an <TT
	  ><A HREF = "GHC.Base.html#t%3AInt"
	    >Int</A
	    ></TT
	  >, it returns any type which is
an instance of <TT
	  ><A HREF = "GHC.Num.html#t%3ANum"
	    >Num</A
	    ></TT
	  >.  It is, however, less efficient than <TT
	  ><A HREF = "Data.List.html#v%3Alength"
	    >length</A
	    ></TT
	  >.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AgenericTake"
	  ></A
	  ><B
	  >genericTake</B
	  > :: <A HREF = "GHC.Real.html#t%3AIntegral"
	  >Integral</A
	  > i =&gt; i -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AgenericTake"
	    >genericTake</A
	    ></TT
	  > function is an overloaded version of <TT
	  ><A HREF = "Data.List.html#v%3Atake"
	    >take</A
	    ></TT
	  >, which
accepts any <TT
	  ><A HREF = "GHC.Real.html#t%3AIntegral"
	    >Integral</A
	    ></TT
	  > value as the number of elements to take.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AgenericDrop"
	  ></A
	  ><B
	  >genericDrop</B
	  > :: <A HREF = "GHC.Real.html#t%3AIntegral"
	  >Integral</A
	  > i =&gt; i -&gt; [a] -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AgenericDrop"
	    >genericDrop</A
	    ></TT
	  > function is an overloaded version of <TT
	  ><A HREF = "Data.List.html#v%3Adrop"
	    >drop</A
	    ></TT
	  >, which
accepts any <TT
	  ><A HREF = "GHC.Real.html#t%3AIntegral"
	    >Integral</A
	    ></TT
	  > value as the number of elements to drop.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AgenericSplitAt"
	  ></A
	  ><B
	  >genericSplitAt</B
	  > :: <A HREF = "GHC.Real.html#t%3AIntegral"
	  >Integral</A
	  > i =&gt; i -&gt; [b] -&gt; ([b], [b])</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AgenericSplitAt"
	    >genericSplitAt</A
	    ></TT
	  > function is an overloaded version of <TT
	  ><A HREF = "Data.List.html#v%3AsplitAt"
	    >splitAt</A
	    ></TT
	  >, which
accepts any <TT
	  ><A HREF = "GHC.Real.html#t%3AIntegral"
	    >Integral</A
	    ></TT
	  > value as the position at which to split.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AgenericIndex"
	  ></A
	  ><B
	  >genericIndex</B
	  > :: <A HREF = "GHC.Real.html#t%3AIntegral"
	  >Integral</A
	  > a =&gt; [b] -&gt; a -&gt; b</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AgenericIndex"
	    >genericIndex</A
	    ></TT
	  > function is an overloaded version of <TT
	  ><A HREF = "Data.List.html#v%3A!!"
	    >!!</A
	    ></TT
	  >, which
accepts any <TT
	  ><A HREF = "GHC.Real.html#t%3AIntegral"
	    >Integral</A
	    ></TT
	  > value as the index.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "decl"
	><A NAME = "v%3AgenericReplicate"
	  ></A
	  ><B
	  >genericReplicate</B
	  > :: <A HREF = "GHC.Real.html#t%3AIntegral"
	  >Integral</A
	  > i =&gt; i -&gt; a -&gt; [a]</TD
	></TR
      ><TR
      ><TD CLASS = "doc"
	>The <TT
	  ><A HREF = "Data.List.html#v%3AgenericReplicate"
	    >genericReplicate</A
	    ></TT
	  > function is an overloaded version of <TT
	  ><A HREF = "Data.List.html#v%3Areplicate"
	    >replicate</A
	    ></TT
	  >,
which accepts any <TT
	  ><A HREF = "GHC.Real.html#t%3AIntegral"
	    >Integral</A
	    ></TT
	  > value as the number of repetitions to make.</TD
	></TR
      ><TR
      ><TD CLASS = "s15"
	></TD
	></TR
      ><TR
      ><TD CLASS = "botbar"
	>Produced by <A HREF = "http://www.haskell.org/haddock/"
	  >Haddock</A
	  > version 0.6</TD
	></TR
      ></TABLE
    ></BODY
  ></HTML
>
