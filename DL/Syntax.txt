CONCEPT ::= CONCEPT-ID
          | CONCEPT 'and' CONCEPT
          | CONCEPT 'that' CONCEPT
          | CONCEPT 'or' CONCEPT
          | CONCEPT 'xor' CONCEPT          
          | 'not' CONCEPT
          | '{' INDIV-ID+ '}
          | RELATION 'some' CONCEPT
          | RELATION 'has' CONCEPT
          | RELATION 'only' CONCEPT
          | RELATION 'min' NUMBER CONCEPT?
          | RELATION 'max' NUMBER CONCEPT?
          | RELATION 'exactly' NUMBER CONCEPT?
          | RELATION 'value' INDIV-ID
          | RELATION 'onlysome' CONCEPT+

RELATION ::= OBJECT-PROP-ID | DATA-PROP-ID

CONCEPT-ID ::= ID
INDIV-ID ::= ID
OBJECT-PROP-ID ::= ID
DATA-PROP-OD ::= ID
NUMBER ::= DIGIT+
DIGIT ::= 0 | ... | 9
STRING ::= ANYCHAR*

CLASS-PROPERTY ::= 'SubclassOf:' CONCEPT
                 | 'EquivalentTo:' CONCEPT
                 | 'DisjointWith:' CONCEPT

TYPE ::= 'Types:' CONCEPT-ID[CONCEPT-ID]*

FATCS ::= 'Facts:' (OBJECT_PROP-ID INDIV-ID | 'not' OBJECT_PROP_ID INDIV-ID)(,
      	  	   (OBJECT_PROP-ID INDIV-ID | 'not' OBJECT_PROP_ID INDIV-ID))*

IND-REL ::= ('SameAs:' INDIV-ID,[INDIV-ID]*,
	         'DifferentFrom:' INDIV-ID,[INDIV-ID]*)*
	     
BASIC-ITEM ::= 'Class:' CONCEPT-ID CLASS-PROPERTY* PARAPHRASE?
	   	   | 'Individual:' INDIV-ID TYPE? FACTS? IND-REL PARAPHRASE?
	       | 'ObjectProperty:' OBJECT-PROP-ID DOMAIN? RANGE?
	   		  [PROPS-REL] 'Characteristics:' CHARACTERISTICS* PARAPHRASE?
	       | 'DataProperty:' DATA-PROP-ID DOMAIN? RANGE?
	          [PROPS-RELD] 'Characteristics: Functional'? PARAPHRASE?
	       | 'Individuals:' INDIV-ID[INDIV-ID]* TYPE? FACTS?
	          ('Equality:' 'Different'|'Same')?
 
CHARACTERISTICS ::= 'Functional' | 'InverseFunctional' | 'Symmetric' | 'Transitive' | 'Reflexive' | 'Irreflexive' 

PARAPRHASE ::= 'Paraphrase:' ("String" [lang: String])(,"String" [lang: String])* | "String"

DOMAIN ::= 'Domain:' CONCEPT   <-- Konzepte || mehrere Defs => Konj.
RANGE  ::= 'Range:'  CONCEPT   <-- Konzepte || mehrere Defs => Disj.

PROPS-REL ::= 'SubPropertyOf:' OBJECT-PROP-ID[,OBJECT-PROP-ID]* |
	          'Inverses:' OBJECT-PROP-ID,[OBJECT-PROP-ID]* |
	          'Equivalent:' OBJECT-PROP-ID,[OBJECT-PROP-ID]* |
	          'Disjoint:' OBJECT-PROP-ID,[OBJECT-PROP-ID]*

PROPS-RELD ::= 'SubPropertyOf:' DATA-PROP-ID[,DATA-PROP-ID]* |
	           'Equivalent:' DATA-PROP-ID,[DATA-PROP-ID]* |
	           'Disjoint:' DATA-PROP-ID,[DATA-PROP-ID]*

BASIC-SPEC ::= {} 
             | BASIC-ITEM+

Comment ::= '%%' String

BlockComment ::= '%{'String'}%'

Offene Frage: 
  - was machen wir mit der Universal Role U
  - Self? fuer lokale reflexivitaet... 
  - ich sehe nicht, wie wir SROIQs role inclusion axioms unterstuetzen koennen
  	- simple / non-simple roles
  	- komposition von Rollen?
  - wie viel reasoning wollen wir betreiben? Ich koennte zum Beipiel (c,c) \in R 
  	mit R irreflexiv zurueckweisen 
