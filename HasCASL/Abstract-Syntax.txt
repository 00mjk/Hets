

BASIC-SPEC       ::= basic-spec BASIC-ITEMS*

BASIC-ITEMS      ::= SIG-ITEMS | CLASS-ITEMS | INSTANCE-ITEMS 
                   | FREE-DATATYPE | SORT-GEN
                   | VAR-ITEMS | LOCAL-VAR-AXIOMS | AXIOM-ITEMS

SIG-ITEMS        ::= SORT-ITEMS | TYPE-ITEMS | OP-ITEMS | PRED-ITEMS
                   | DATATYPE-ITEMS

SORT-ITEMS       ::= sort-items SORT-ITEM+ %% Only for reverse compatibility
SORT-ITEM        ::= SORT-DECL

SORT-DECL        ::= sort-decl TYPE-NAME+ CLASS*

TYPE-ITEMS::= type-constr-items TYPE-ITEM+
TYPE-ITEM ::= TYPE-DECL | TYPE-ALIAS-DEFN 

TYPE-DECL    ::= TYPE-VAL-DECL | TYPE-FUN-DECL
TYPE-VAL-DECL::= type-val-const-decl TYPE-NAME+ KIND
TYPE-FUN-DECL::= type-constr-fun-decl TYPE-PATTERN+ CLASS+
TYPE-PATTERN ::= type-constr-pattern TYPE-NAME TYPE-VAR-OR-DECL* 
TYPE-VAR-OR-DECL    ::= TYPE-VAR | TYPE-ARG-DECL
TYPE-ARG-DECL       ::= type-arg-decl TYPE-VAR EXT-CLASS
TYPE-ALIAS-DEFN     ::= TYPE-ALIAS-VAL-DEFN | TYPE-ALIAS-FUN-DEFN
TYPE-ALIAS-VAL-DEFN ::= type-alias-val-defn TYPE-NAME PSEUDOTYPE
PSEUDOTYPE          ::= TYPE | LAMBDA-TYPE
LAMBDA-TYPE         ::= lambda-type TYPE-VAR-DECL+ TYPE
TYPE-ALIAS-FUN-DEFN ::= type-alias-fun-defn TYPE-PATTERN TYPE

CLASS-ITEMS       ::= class-items CLASS-ITEM+
CLASS-ITEM        ::= CLASS-DECL | SUBCLASS-DECL

CLASS-DECL        ::= class-decl CLASS-NAME+
SUBCLASS-DECL     ::= subclass-decl CLASS-NAME+ CLASS-NAME

INSTANCE-ITEMS    ::= instance-items INSTANCE-ITEM+
INSTANCE-ITEM     ::= INSTANCE-DECL | INSTANCE-DEFN

INSTANCE-DECL     ::= CLASS-INSTANCE | ARITY 
CLASS-INSTANCE    ::= SUB-INSTANCE | VAR-SUB-INSTANCE
SUB-INSTANCE      ::= sub-instance CLASS-NAME CLASS-NAME
VAR-SUB-INSTANCE  ::= var-sub-instance TYPE-VAR CLASS-NAME CLASS-NAME
ARITY             ::= VAL-ARITY | FUN-ARITY | VAR-FUN-ARITY
VAL-ARITY         ::= val-arity TYPE KIND
FUN-ARITY         ::= fun-arity TYPE-NAME CLASS* CLASS
VAR-FUN-ARITY     ::= var-fun-arity TYPE-PATTERN CLASS
INSTANCE-DEFN     ::= instance-defn INSTANCE-DECL BASIC-SPEC

OP-ITEMS         ::= op-items OP-ITEM+
OP-ITEM          ::= OP-DECL | OP-DEFN

OP-DECL          ::= op-decl OP-NAME+ TYPE-SCHEME OP-ATTR*
OP-TYPE, TOTAL-OP-TYPE, PARTIAL-OP-TYPE, SORT-LIST: obsolete
OP-ATTR          ::= BINARY-OP-ATTR | UNIT-OP-ATTR
BINARY-OP-ATTR   ::= assoc-op-attr | comm-op-attr | idem-op-attr
UNIT-OP-ATTR     ::= unit-op-attr TERM

OP-DEFN          ::= OP-FUN-DEFN | OP-VAL-DEFN | OP-REC-VAL-DEFN
OP-FUN-DEFN      ::= op-fun-defn OP-NAME OP-HEAD TERM  %% Not encouraged:
                 %% Equivalent to quantified external formula,
                 %% loose definition due to intensionality
OP-HEAD          ::= TOTAL-OP-HEAD | PARTIAL-OP-HEAD
TOTAL-OP-HEAD    ::= total-op-head ARG-DECL* TYPE
PARTIAL-OP-HEAD  ::= partial-op-head ARG-DECL* TYPE
ARG-DECL         ::= arg-decl VAR+ TYPE
OP-VAL-DEFN      ::= op-val-defn OP-NAME TYPE TERM
OP-REC-VAL-DEFN  ::= op-rec-val-defn OP-NAME TYPE TERM

PRED-ITEMS       ::= pred-items PRED-ITEM+      %% only for compatibility
PRED-ITEM        ::= PRED-DECL | PRED-DEFN

PRED-DECL        ::= pred-decl OP-NAME+ TYPE 
PRED-TYPE: obsolete
PRED-DEFN        ::= PRED-FUN-DEFN | PRED-VAL-DEFN | PRED-REC-VAL-DEFN

PRED-FUN-DEFN    ::= pred-fun-defn OP-NAME PRED-HEAD FORMULA
PRED-HEAD        ::= pred-head ARG-DECL*
PRED-VAL-DEFN    ::= pred-val-defn OP-NAME TYPE TERM
PRED-REC-VAL-DEFN::= pred-rec-val-defn OP-NAME TYPE TERM

DATATYPE-ITEMS   ::= datatype-items DATATYPE-DECL+
DATATYPE-DECL    ::= SIMPLE-DATATYPE-DECL | DERIVING-DATATYPE-DECL

SIMPLE-DATATYPE-DECL
                 ::= simple-datatype-decl TYPE-PATTERN ALTERNATIVE+ 
DERIVING-DATATYPE-DECL
                 ::= deriving-datatype-decl SIMPLE-DATATYPE-DECL CLASS+
ALTERNATIVE      ::= TOTAL-CONSTRUCT | PARTIAL-CONSTRUCT
TOTAL-CONSTRUCT  ::= total-construct   OP-NAME COMPONENTS*
PARTIAL-CONSTRUCT::= partial-construct OP-NAME COMPONENTS+
COMPONENTS       ::= TOTAL-SELECT | PARTIAL-SELECT | TYPE
TOTAL-SELECT     ::= total-select   OP-NAME+ TYPE
PARTIAL-SELECT   ::= partial-select OP-NAME+ TYPE

FREE-DATATYPE    ::= free-datatype DATATYPE-ITEMS

SORT-GEN         ::= sort-gen SIG-ITEMS+

VAR-ITEMS        ::= var-items GEN-VAR-DECL+
GEN-VAR-DECL     ::= VAR-DECL | TYPE-VAR-DECL
VAR-DECL         ::= var-decl VAR+ TYPE
TYPE-VAR-DECL    ::= type-var-decl TYPE-VAR+ CLASS+

LOCAL-VAR-AXIOMS ::= local-var-axioms VAR-DECL+ AXIOM+

AXIOM-ITEMS      ::= axiom-items AXIOM+     

KIND             ::= kind EXT-CLASS* CLASS  %% Argumente, Resultat
EXT-CLASS        ::= CLASS+ | VARIANCE | CLASSES-WITH-VARIANCE
CLASSES-WITH-VARIANCE
                 ::= class-with-variance CLASS+ VARIANCE
VARIANCE         ::= covariant | contravariant | invariant
%% Idee: Varianz von Konstruktoren kann spezifiziert werden,
%% wird bei Datentypen ausserdem inferiert (?). Irrtuemer geben
%% dann eben Inkonsistenzen.


CLASS            ::= UNIVERSE | DOWNSET | CLASS-NAME
UNIVERSE         ::= type 
DOWNSET          ::= downset TYPE

TYPE-SCHEME      ::= TYPE | POLYMORPHIC-TYPE
POLYMORPHIC-TYPE ::= polymorphic-type TYPE-VAR-DECL+ TYPE  

TYPE             ::= TYPE-VAR | PROD-TYPE | TOTAL-FUN-TYPE 
                   | PARTIAL-FUN-TYPE | TOTAL-CONT-TYPE
                   | PARTIAL-CONT-TYPE | PRED-TYPE | UNIT-TYPE 
                   | TYPE-APPL

PROD-TYPE        ::= prod-type TYPE+
TOTAL-FUN-TYPE   ::= total-funp-type TYPE TYPE
PARTIAL-FUN-TYPE ::= partial-fun-type TYPE TYPE
TOTAL-CONT-TYPE  ::= total-cont-type TYPE TYPE
PARTIAL-CONT-TYPE::= partial-cont-type TYPE TYPE
PRED-TYPE        ::= pred-type TYPE
UNIT-TYPE        ::= unit-type
TYPE-APPL ::= type-constr-application TYPE-NAME TYPE*



AXIOM            ::= EXT-FORMULA | TYPE-QUANTIFICATION
TYPE-QUANTIFICATION   
                 ::= type-quantification TYPE-VAR-DECL+ EXT-FORMULA
EXT-FORMULA      ::= FORMULA | REC-EQUATION

FORMULA          ::= QUANTIFICATION | CONJUNCTION | DISJUNCTION 
                   | IMPLICATION | EQUIVALENCE | NEGATION | ATOM
QUANTIFICATION   ::= quantification QUANTIFIER VAR-DECL+ FORMULA
QUANTIFIER       ::= universal | existential | unique-existential
CONJUNCTION      ::= conjunction FORMULA+
DISJUNCTION      ::= disjunction FORMULA+
IMPLICATION      ::= implication FORMULA FORMULA
EQUIVALENCE      ::= equivalence FORMULA FORMULA
NEGATION         ::= negation FORMULA

REC-EQUATION    ::= rec-equation OP-NAME TERM

ATOM             ::= TRUTH | EXISTL-EQUATION | STRONG-EQUATION 
                    | INTERNAL-FORMULA   %% !!!
TRUTH            ::= true-atom | false-atom
PREDICATION, PRED-SYMB, QUAL-PRED-NAME: obsolete
EXISTL-EQUATION  ::= existl-equation TERM TERM
STRONG-EQUATION  ::= strong-equation TERM TERM
INT-FORMULA      ::= TERM  %% Of type unit -->  static analysis

TERMS: obsolete
TERM             ::= VAR | QUAL-VAR | APPLICATION
                   | TYPED-TERM | CONDITIONAL | TOTAL-LAMBDA-TERM 
                   | PARTIAL-LAMBDA-TERM | PRED-LAMBDA-TERM 
                   | POLY-LAMBDA-TERM | PROJECTION1-TERM
                   | ... | PROJECTIONN-TERM | UNIT-TERM | TUPLE-TERM 
                   | CONSTANT-TERM | CASE-TERM | RES-TERM
                   | FIX-TERM | LOGIC-TERM
%% Checking that abstractions don't contain conditionals is left to the
%% static analysis!

QUAL-VAR         ::= qual-var VAR TYPE
APPLICATION      ::= application TERM TERM 
OP-SYMB          ::= OP-NAME | QUAL-OP-NAME
QUAL-OP-NAME     ::= qual-op-name OP-NAME OP-TYPE
TYPED-TERM       ::= typed-term TERM TYPE
CONDITIONAL      ::= conditional FORMULA TERM TERM
DEFINEDNESS      ::= definedness TERM
TOTAL-LAMBDA-TERM::= total-lambda-term VAR-DECL+ TERM
PARTIAL-LAMBDA-TERM 
                 ::= partial-lambda-term VAR-DECL+ TERM
PRED-LAMBDA-TERM ::= pred-lambda-term VAR-DECL+ INT-FORMULA  
PROJECTION1-TERM ::= projection1-term TERM
...
PROJECTIONN-TERM ::= projectionn-term TERM
UNIT-TERM        ::= unit-term 
TUPLE-TERM       ::= tuple-term TERM TERM+
CONSTANT-TERM    ::= constant-term OP-NAME TYPE*
CASE-TERM        ::= case-term TERM CASE+
CASE             ::= case OP-NAME TOTAL-OP-HEAD TERM
RES-TERM         ::= res-term TERM TERM
FIX-TERM         ::= fix-term TERM
LOGIC-TERM       ::= INT-TRUTH 
                   | INT-NEGATION
                   | INT-CONJUNCTION
                   | INT-DISJUNCTION
                   | INT-IMPLICATION
                   | INT-EQUIVALENCE
                   | INT-QUANTIFICATION

INT-TRUTH        ::= SIMPLE-INT-TRUTH | TYPED-INT-TRUTH
TYPED-INT-TRUTH  ::= typed-int-truth SIMPLE-INT-TRUTH TYPE
SIMPLE-INT-TRUTH ::= tt | ff
INT-NEGATION     ::= int-negation INT-FORMULA
INT-CONJUNCTION  ::= int-conjunction INT-FORMULA INT-FORMULA+
INT-DISJUNCTION  ::= int-disjunction INT-FORMULA INT-FORMULA+
INT-IMPLICATION  ::= int-implication INT-FORMULA INT-FORMULA
INT-EQUIVALENCE  ::= int-equivalence INT-FORMULA INT-FORMULA
INT-QUANTIFICATION
                 ::= SIMPLE-INT-QUANTIFICATION
                   | TYPED-INT-QUANTIFICATION
TYPED-INT-QUANTIFICATION 
                 ::= typed-int-quantification SIMPLE-INT-QUANTIFICATION TYPE
SIMPLE-INT-QUANTIFICATION
                 ::= simple-int-quantification INT-QUANTIFIER TERM
INT-QUANTIFIER   ::= int-all | int-exists | int-exists-uniquely



SORT: obsolete
CLASS-NAME       ::= TOKEN-ID
TYPE-NAME ::= ID 
OP-NAME          ::= ID
PRED-NAME: obsolete
VAR              ::= SIMPLE-ID
TYPE-VAR         ::= SIMPLE-ID
         
SIMPLE-ID        ::= WORDS
ID               ::= TOKEN-ID | MIXFIX-ID
TOKEN-ID         ::= TOKEN
TOKEN            ::= WORDS | DOT-WORDS | SIGNS | DIGIT | QUOTED-CHAR
MIXFIX-ID        ::= TOKEN-PLACES
TOKEN-PLACES     ::= token-places TOKEN-OR-PLACE+
TOKEN-OR-PLACE   ::= TOKEN | PLACE

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% With subsorting                                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SORT-ITEM        ::= ... | SUBSORT-DECL | ISO-DECL | SUBSORT-DEFN
                         %% again: only for compatibility

SUBSORT-DECL     ::= subsort-decl TYPE-NAME+ TYPE
ISO-DECL         ::= iso-decl TYPE-NAME+
SUBSORT-DEFN     ::= subsort-defn TYPE-NAME+ VAR 
                                  TYPE FORMULA

TYPE-ITEM ::= ...
                 | SUBTYPE-DECL | TYPE-ISO-DECL | SUBTYPE-DEFN

SUBTYPE-DECL     ::= SUBTYPE-VAL-DECL | SUBTYPE-FUN-DECL
SUBTYPE-VAL-DECL ::= subtype-val-decl TYPE-NAME PSEUDOTYPE
SUBTYPE-FUN-DECL ::= subtype-fun-decl TYPE-PATTERN+ TYPE 
TYPE-ISO-DECL    ::= TYPE-ISO-VAL-DECL | TYPE-ISO-FUN-DECL
TYPE-ISO-VAL-DECL::= type-iso-val-decl TYPE-NAME+
TYPE-ISO-FUN-DECL::= type-iso-fun-decl TYPE-PATTERN+
SUBTYPE-DEFN     ::= subtype-defn TYPE-PATTERN VAR TYPE FORMULA 
%% alias < type must be caught by the static semantics ! 


ALTERNATIVE      ::= ... | SUBTYPE
SUBTYPE         ::= subtype TYPE

TERM             ::= ... | MEMBERSHIP
MEMBERSHIP       ::= membership TERM TYPE

TERM             ::= ... | CAST
CAST             ::= cast TERM TYPE









Concrete Syntax
===============


BASIC-SPEC      ::= BASIC-ITEMS...BASIC-ITEMS  |  { }

BASIC-ITEMS     ::= SIG-ITEMS  
                  | class/classes CLASS-DECL ;...; CLASS-DECL ;/
                  | instance/instances INSTANCE-DECL ;...; INSTANCE-DECL ;/
                  | free      type/types DATATYPE-DECL ;...; DATATYPE-DECL ;/
                  | generated type/types DATATYPE-DECL ;...; DATATYPE-DECL ;/
                  | generated { SIG-ITEMS...SIG-ITEMS } ;/
                  | var/vars GEN-VAR-DECL ;...; GEN-VAR-DECL ;/
                  | forall GEN-VAR-DECL ;...; GEN-VAR-DECL
                             "." AXIOM "."..."." AXIOM ;/ 
                  | "." AXIOM "."..."." AXIOM ;/ 

The following alternative concrete syntax productions:

BASIC-ITEMS     ::=  var/vars GEN-VAR-DECL ;...; GEN-VAR-DECL 
                              "." AXIOM "."..."." AXIOM ;/
                  |  axiom/axioms AXIOM ;...; AXIOM ;/

are included for backwards compatibility with CASL v1.0, but may be
removed in some future version.

SIG-ITEMS       ::= sort/sorts SORT-ITEM ;...; SORT-ITEM ;/
                  | type/types TYPE-ITEM;...; TYPE-ITEM ;/
                  | op/ops OP-ITEM ;...; OP-ITEM ;/
                  | pred/preds PRED-ITEM ;...; PRED-ITEM  ;/
                  | type/types DATATYPE-DECL ;...; DATATYPE-DECL ;/

SORT-ITEM       ::= TYPE-NAME ,..., TYPE-NAME 
                  | TYPE-NAME ,..., TYPE-NAME < TYPE-NAME 
                  | TYPE-NAME = { VAR : TYPE "." FORMULA } 
                  | TYPE-NAME =...= TYPE-NAME   

TYPE-ITEM::= TYPE-NAME ,..., TYPE-NAME: KIND
                  | TYPE-PATTERN ,..., TYPE-PATTERN: 
                                CLASS ,..., CLASS
                  | TYPE-NAME = PSEUDOTYPE
                  | TYPE-PATTERN = TYPE

TYPE-PATTERN
                ::= TYPE-NAME
                  | TYPE-NAME(TYPE-VAR-OR-DECL ;...; TYPE-VAR-OR-DECL)
                  | TYPE-NAME TYPE-VAR-OR-DECL ... TYPE-VAR-OR-DECL
TYPE-VAR-OR-DECL::= TYPE-VAR | TYPE-VAR: EXT-CLASS
PSEUDOTYPE      ::= TYPE 
                  | \ TYPE-VAR-DECL ;...; TYPE-VAR-DECL "." TYPE

CLASS-ITEMS     ::= class/classes CLASS-ITEM; ...; CLASS-ITEM
CLASS-ITEM      ::= CLASS-NAME 
                  | CLASS-NAME ,..., CLASS-NAME < CLASS-NAME

INSTANCE-ITEMS  ::= instance/instances INSTANCE-ITEM ;...; INSTANCE-ITEM
INSTANCE-ITEM   ::= INSTANCE-DECL | INSTANCE-DEFN
INSTANCE-DECL   ::= CLASS-NAME < CLASS-NAME
                | TYPE-VAR: CLASS-NAME < CLASS-NAME
                | TYPE: KIND
                | TYPE(CLASS, ...,CLASS): CLASS
                | TYPE-PATTERN: CLASS
INSTANCE-DEFN   ::= INSTANCE-DECL { BASIC-SPEC }

OP-ITEM         ::= OP-NAME, ..., OP-NAME: TYPE-SCHEME
                  | OP-NAME ,..., OP-NAME : TYPE-SCHEME , 
                            OP-ATTR ,..., OP-ATTR 
                  | OP-NAME: TYPE = TERM
                  | OP-NAME: TYPE =rec TERM
                  | OP-NAME OP-HEAD = TERM        %% This form is 
                                                  %% not encouraged
OP-HEAD         ::= ( ARG-DECL ;...; ARG-DECL ) : TYPE    
                  | ARG-DECL ... ARG-DECL : TYPE 
                  |  : TYPE   
                  | ( ARG-DECL ;...; ARG-DECL ) : ? TYPE  
                  | ARG-DECL ... ARG-DECL : ? TYPE 
                  |  : ? TYPE 
ARG-DECL        ::= VAR ,..., VAR : TYPE

OP-TYPE: obsolete

SOME-SORTS: obsolete 

OP-ATTR         ::= assoc  |  comm  |  idem  |  unit TERM

PRED-ITEM       ::= OP-NAME, ..., OP-NAME: TYPE
                  | OP-NAME PRED-HEAD <=> FORMULA  %% This form is 
                                                 %% not encouraged.
                  | OP-NAME <=> FORMULA          %% Nor is this one.
                  | OP-NAME: TYPE = TERM
                  | OP-NAME: TYPE =rec TERM
PRED-TYPE: obsolete

PRED-HEAD       ::= ( ARG-DECL ;...; ARG-DECL ) 
                  | ARG-DECL ... ARG-DECL

DATATYPE-DECL   ::= SIMPLE-DATATYPE-DECL | DERIVING-DATATYPE-DECL

SIMPLE-DATATYPE-DECL   
                ::= TYPE-PATTERN "::=" 
                                ALTERNATIVE "|"..."|" ALTERNATIVE
DERIVING-DATATYPE-DECL
                ::= SIMPLE-DATATYPE-DECL deriving CLASS ,..., CLASS

ALTERNATIVE     ::= OP-NAME  ( COMPONENT ;...; COMPONENT )    
                  | OP-NAME  ( COMPONENT ;...; COMPONENT ) ?   
                  | OP-NAME                           
                  | sort/sorts TYPE-NAME ,..., TYPE-NAME
                  | type/types TYPE ,..., TYPE                  

COMPONENT       ::= OP-NAME ,..., OP-NAME : TYPE
                  | OP-NAME ,..., OP-NAME : ? TYPE               
                  | TYPE                                        


GEN-VAR-DECL    ::= VAR-DECL | TYPE-VAR-DECL
VAR-DECL        ::= VAR ,..., VAR : TYPE
TYPE-VAR-DECL   ::= TYPE-VAR, ..., TYPE-VAR: CLASS ,..., CLASS |
                    TYPE-VAR, ...,TYPE-VAR < TYPE

KIND            ::= EXT-CLASS * ... * EXT-CLASS -> CLASS
EXT-CLASS       ::= CLASS ,..., CLASS
                  | VARIANCE
                  | CLASS ,..., CLASS(VARIANCE)
VARIANCE        ::= covariant | contravariant | invariant

CLASS           ::= type | {a. a < TYPE} | CLASS-NAME

TYPE-SCHEME     ::= TYPE | forall TYPE-VAR-DECL;...;TYPE-VAR-DECL. TYPE

TYPE            ::= TYPE-VAR 
                  | TYPE * ... * TYPE
                  | TYPE -> TYPE
                  | TYPE ->? TYPE
                  | TCont TYPE TYPE | TCont(TYPE,TYPE)
                  | PCont TYPE TYPE | PCont(TYPE,TYPE)
                  | pred(TYPE)
                  | ()
                  | TYPE-NAME TYPE ... TYPE
                  | TYPE-NAME(TYPE ,..., TYPE)


AXIOM           ::= EXT-FORMULA | TYPE-QUANTIFICATION
TYPE-QUANTIFICATION
                ::= forall TYPE-VAR-DECL ;...; TYPE-VAR-DECL "." EXT-FORMULA
EXT-FORMULA     ::= FORMULA | OP-NAME =rec TERM

FORMULA         ::= QUANTIFIER  VAR-DECL ;...; VAR-DECL "." FORMULA
                  | FORMULA /\ FORMULA /\.../\ FORMULA
                  | FORMULA \/ FORMULA \/...\/ FORMULA
                  | FORMULA => FORMULA
                  | FORMULA if FORMULA
                  | FORMULA <=> FORMULA
                  | not FORMULA
                  | true | false
                  | TERM =e= TERM
                  | TERM = TERM
                  | ( FORMULA )
                  | MIXFIX...MIXFIX
                  | TERM

QUANTIFIER      ::= forall  |  exists  |  exists!

TERMS:          obsolete

TERM            ::= MIXFIX...MIXFIX

MIXFIX          ::= NO-BRACKET-TOKEN  |  LITERAL  |  PLACE
                  | QUAL-PRED-NAME  |  QUAL-VAR-NAME  |  QUAL-OP-NAME 
                  | OP-NAME
                  | OP-NAME(TYPE, ..., TYPE)
                  | OP-NAME TYPE ... TYPE
                  | TERM : TYPE
                  | TERM as TYPE
                  | TERM when FORMULA else TERM
                  | TERM ... TERM
                  | ( TERM ,..., TERM )
                  | [ TERM ,..., TERM ]  |  [ ]
                  | { TERM ,..., TERM }  |  { }
                  | pr1(TERM) | ... | prn(TERM)
                  | ()
                  | \ VAR-DECL "." ! TERM       
                  | \ VAR-DECL "."  TERM
                  | case TERM of TERM -> TERM; ... TERM -> TERM ;/
                  | TERM res TERM
                  | tt | tt TYPE | tt(TYPE)
                  | ff | ff TYPE | ff(TYPE)
                  | neg TERM
                  | TERM and ... and TERM
                  | TERM or ... or TERM
                  | TERM impl TERM
                  | TERM equiv TERM
                  | INT-QUANTIFIER TERM | INT-QUANTIFIER TYPE TERM
                  | INT-QUANTIFIER(TYPE) TERM
                  

INT-QUANTIFIER ::= all | ex | ex!

QUAL-VAR-NAME   ::= ( var VAR : TYPE )

QUAL-PRED-NAME  ::= ( pred OP-NAME : TYPE )

QUAL-OP-NAME    ::= ( op OP-NAME : TYPE )

TYPE-NAME::= ID 
OP-NAME         ::= ID
PRED-NAME: obsolete
CLASS-NAME      ::= TOKEN-ID
VAR             ::= SIMPLE-ID 
TYPE-VAR        ::= SIMPLE-ID


SIMPLE-ID       ::= WORDS
ID              ::= TOKEN-ID  |  MIXFIX-ID
TOKEN-ID        ::= TOKEN
MIXFIX-ID       ::= TOKEN-ID PLACE-TOKEN-ID ... PLACE-TOKEN-ID
                  |          PLACE-TOKEN-ID ... PLACE-TOKEN-ID
PLACE-TOKEN-ID  ::= PLACE TOKEN-ID
                  | PLACE
PLACE           ::= __

TOKEN           ::= WORDS  |  DOT-WORDS  |  DIGIT  |  QUOTED-CHAR 
                  | SIGNS
NO-BRACKET-TOKEN::= WORDS  |  DOT-WORDS  |  DIGIT  |  QUOTED-CHAR
                  | NO-BRACKET-SIGNS

SIGNS           ::= NO-BRACKET-SIGNS  |  BRACKET-SIGNS
                  | NO-BRACKET-SIGNS BRACKET-SIGNS
BRACKET-SIGNS   ::= BRACKET SIGNS
                  | BRACKET
BRACKET         ::= [  |  ]  |  {  |  }

LITERAL         ::= DIGITS  |  FRACTION  |  FLOATING  |  STRING


