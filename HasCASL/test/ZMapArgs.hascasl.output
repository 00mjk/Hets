free type Tree(a : Type) ::= Leaf (a) | 
                             Node (Tree a) (a) | 
                             EmptyLeaf
free type Nat ::= Zero | 
                  Suc (Nat)
op caseTree : forall a . Tree Nat -> Tree Nat
forall h : Tree Nat; n : Nat; t : Tree Nat
. ((fun __=__[Tree Nat] : forall a : Type . a * a ->? Unit) :
       Tree Nat * Tree Nat ->? Unit)
    ((op caseTree : Tree Nat -> Tree Nat)(var t : Tree Nat) : Tree Nat,
     (case (var t : Tree Nat) of
          (op EmptyLeaf[Nat] : forall a : Type . Tree a) : Tree Nat ->
              (op EmptyLeaf[_v17] : forall a : Type . Tree a) : Tree _v17 | 
          ((op Leaf[Nat] : forall a : Type . a -> Tree a) : Nat -> Tree Nat)
            (var n : Nat) :
              Tree Nat
            ->
              (op EmptyLeaf[_v17] : forall a : Type . Tree a) : Tree _v17 | 
          (((op Node[Nat] : forall a : Type . Tree a -> a -> Tree a) :
                Tree Nat -> Nat -> Tree Nat)
             ((op EmptyLeaf[Nat] : forall a : Type . Tree a) : Tree Nat) :
               Nat -> Tree Nat)
            (var n : Nat) :
              Tree Nat
            ->
              (op EmptyLeaf[_v17] : forall a : Type . Tree a) : Tree _v17 | 
          (((op Node[Nat] : forall a : Type . Tree a -> a -> Tree a) :
                Tree Nat -> Nat -> Tree Nat)
             ((((op Node[Nat] : forall a : Type . Tree a -> a -> Tree a) :
                    Tree Nat -> Nat -> Tree Nat)
                 (var h : Tree Nat) :
                   Nat -> Tree Nat)
                (var n : Nat) :
                  Tree Nat) :
               Nat -> Tree Nat)
            (var n : Nat) :
              Tree Nat
            ->
              (var h : Tree Nat) | 
          (((op Node[Nat] : forall a : Type . Tree a -> a -> Tree a) :
                Tree Nat -> Nat -> Tree Nat)
             (((op Leaf[Nat] : forall a : Type . a -> Tree a) : Nat -> Tree Nat)
                (var n : Nat) :
                  Tree Nat) :
               Nat -> Tree Nat)
            (var n : Nat) :
              Tree Nat
            ->
              ((op Leaf[Nat] : forall a : Type . a -> Tree a) : Nat -> Tree Nat)
                (var n : Nat) :
                  Tree Nat) :
         Tree Nat) :
      Unit
%% Type Constructors -----------------------------------------------------
? : +Type -> Type
Logical : Type := ? Unit
Nat
  : Type
     %[free type Nat
         ::= Zero : Nat
             Suc : Nat -> Nat (Nat)]%
Pred : -Type -> Type := \ a : -Type . a ->? Unit
Tree
  : Type -> Type
     %[free type Tree(a : Type)
         ::= Leaf : a -> Tree a (a)
             Node : Tree a -> a -> Tree a (Tree a)(a)
             EmptyLeaf : Tree a]%
Unit : Type
__*__ : +Type -> +Type -> Type
__*__*__ : +Type -> +Type -> +Type -> Type
__*__*__*__ : +Type -> +Type -> +Type -> +Type -> Type
__*__*__*__*__ : +Type -> +Type -> +Type -> +Type -> +Type -> Type
__-->__ : -Type -> +Type -> Type < (__-->?__, __->__)
__-->?__ : -Type -> +Type -> Type < __->?__
__->__ : -Type -> +Type -> Type < __->?__
__->?__ : -Type -> +Type -> Type
%% Assumptions -----------------------------------------------------------
EmptyLeaf : forall a : Type . Tree a %(construct Tree)%
Leaf : forall a : Type . a -> Tree a %(construct Tree)%
Node : forall a : Type . Tree a -> a -> Tree a %(construct Tree)%
Suc : Nat -> Nat %(construct Nat)%
Zero : Nat %(construct Nat)%
__/\__ : ? Unit * ? Unit ->? Unit %(fun)%
__<=>__ : ? Unit * ? Unit ->? Unit %(fun)%
__=__ : forall a : Type . a * a ->? Unit %(fun)%
__=>__ : ? Unit * ? Unit ->? Unit %(fun)%
__=e=__ : forall a : Type . a * a ->? Unit %(fun)%
__\/__ : ? Unit * ? Unit ->? Unit %(fun)%
__if__ : ? Unit * ? Unit ->? Unit %(fun)%
__when__else__ : forall a : Type . a * ? Unit * a ->? a %(fun)%
bottom : forall a : Type . a %(fun)%
caseTree : Tree Nat -> Tree Nat %(op)%
def__ : forall a : Type . a ->? Unit %(fun)%
false : Unit %(fun)%
not__ : ? Unit ->? Unit %(fun)%
true : Unit %(fun)%
¬__ : ? Unit ->? Unit %(fun)%
%% Variables -------------------------------------------------------------
h : Tree Nat
n : Nat
t : Tree Nat
%% Sentences -------------------------------------------------------------
free type Tree(a : Type)
  ::= Leaf : a -> Tree a (a)
      Node : Tree a -> a -> Tree a (Tree a)(a)
      EmptyLeaf : Tree a %(ga_Tree)%
free type Nat
  ::= Zero : Nat
      Suc : Nat -> Nat (Nat) %(ga_Nat)%
(__=__ : Tree Nat * Tree Nat ->? Unit)
  (caseTree(t) : Tree Nat,
   (case t of
        EmptyLeaf : Tree Nat -> EmptyLeaf : Tree _v17 | 
        (Leaf : Nat -> Tree Nat)(n) : Tree Nat -> EmptyLeaf : Tree _v17 | 
        ((Node : Tree Nat -> Nat -> Tree Nat)(EmptyLeaf : Tree Nat) :
             Nat -> Tree Nat)
          (n) :
            Tree Nat
          ->
            EmptyLeaf : Tree _v17 | 
        ((Node : Tree Nat -> Nat -> Tree Nat)
           (((Node : Tree Nat -> Nat -> Tree Nat)(h) : Nat -> Tree Nat)(n) :
                Tree Nat) :
             Nat -> Tree Nat)
          (n) :
            Tree Nat
          ->
            h | 
        ((Node : Tree Nat -> Nat -> Tree Nat)
           ((Leaf : Nat -> Tree Nat)(n) : Tree Nat) :
             Nat -> Tree Nat)
          (n) :
            Tree Nat
          ->
            (Leaf : Nat -> Tree Nat)(n) : Tree Nat) :
       Tree Nat) :
    Unit
%% Diagnostics -----------------------------------------------------------
*** Warning 1.18, missing kind for type variable  'a'
*** Warning 4.23, missing kind for type variable  'a'
*** Warning 4.27-4.44, ignoring unused variable(s)
  a in 'Tree Nat -> Tree Nat'
*** Hint 6.9, not a kind 'Tree Nat'
*** Hint 7.9, not a class 'Nat'
*** Hint 7.16, not a kind 'Tree Nat'
*** Hint 10.27, rebound variable 'n'
*** Hint 11.37, rebound variable 'n'
*** Hint 12.33, rebound variable 'h'
*** Hint 12.35, rebound variable 'n'
*** Hint 12.37, rebound variable 'n'
*** Hint 13.33, rebound variable 'n'
*** Hint 13.36, rebound variable 'n'
