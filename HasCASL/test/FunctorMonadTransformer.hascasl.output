class Functor < Type -> Type
      {vars  f : Functor; a, b, c : Type
      op    map : (a -> b) -> f a -> f b
      vars  x : f a; f : a -> b; g : b -> c
      . (map \ y : a .! y) x = x
      . (map \ y : a .! g (f y)) x = map g (map f x);
      }
class Monad < Type -> Type
      {vars  m : Monad; a, b, c : Type
      ops   __>>=__ : m a * (a ->? m b) ->? m b;
            __>>=__ : m a * (a -> m b) -> m b;
            ret : a -> m a
      vars  x, y : a; p : m a; q : a ->? m b; r : b ->? m c; f : a ->? b
      . def q x => ret x >>= q = q x
      . (p >>= \ x : a . ret (f x) >>= r) = p >>= \ x : a . r (f x)
      . p >>= ret = p
      . (p >>= q) >>= r = p >>= \ x : a . q x >>= r
      . (ret x : m a) = ret y => x = y;
      }
class instance Monad < Functor
vars  m : Monad; a, b : Type; f : a -> b; x : m a
. map f x = x >>= \ y : a . ret (f y);
class MonadT < Monad -> Monad
      {vars  t : MonadT; m : Monad; a : Type
      op    lift : m a -> t m a
      vars  x : a; p : m a; b : Type; q : a -> m b
      . lift (ret x) = (ret x : t m a)
      . lift (p >>= q) = lift p >>= \ y : a .! lift (q y) : t m b;
      }
var   state : Type
type instance ST state : Monad
vars  a, b : Type
type  ST state a := state ->? a * state
vars  x : a; p : ST state a; q : a ->? ST state b
%% Classes ---------------------------------------------------------------
Functor < Type -> Type
Monad < Functor
MonadT < Monad -> Monad
%% Type Constructors -----------------------------------------------------
ST : Type -> Monad := \ state : Type . _t1132
_t1132 : Type -> Type := \ a : Type . state ->? a * state
%% Type Variables --------------------------------------------------------
a  : Type %(var_1128)%
b  : Type %(var_1129)%
c  : Type %(var_93)%
f  : Functor %(var_1)%
m  : Monad %(var_790)%
state  : Type %(var_1126)%
t  : MonadT %(var_789)%
%% Assumptions -----------------------------------------------------------
__>>=__
: forall m : Monad; a : Type; b : Type . m a * (a -> m b) -> m b
%(op)%
: forall m : Monad; a : Type; b : Type . m a * (a ->? m b) ->? m b
%(op)%
lift : forall t : MonadT; m : Monad; a : Type . m a -> t m a %(op)%
map
: forall f : Functor; a : Type; b : Type . (a -> b) -> f a -> f b
%(op)%
ret : forall m : Monad; a : Type . a -> m a %(op)%
%% Variables -------------------------------------------------------------
f : a -> b
g : b -> c
p : ST state a
q : a ->? ST state b
r : b ->? m c
x : a
y : a
%% Sentences -------------------------------------------------------------
(map \ y : a .! y) x = x
(map \ y : a .! g (f y)) x = map g (map f x)
def q x => (__>>=__ : m a * (a ->? m b) ->? m b) (ret x, q) = q x
(__>>=__ : m a * (a ->? m c) ->? m c)
(p, \ x . (__>>=__ : m b * (b ->? m c) ->? m c) (ret (f x), r))
= (__>>=__ : m a * (a ->? m c) ->? m c) (p, \ x . r (f x))
(__>>=__ : m a * (a ->? m a) ->? m a) (p, ret) = p
(__>>=__ : m b * (b ->? m c) ->? m c)
((__>>=__ : m a * (a ->? m b) ->? m b) (p, q), r)
= (__>>=__ : m a * (a ->? m c) ->? m c)
  (p, \ x . (__>>=__ : m b * (b ->? m c) ->? m c) (q x, r))
(ret x : m a) = ret y => x = y
map f x
= (__>>=__ : m a * (a ->? m b) ->? m b) (x, \ y . ret (f y))
lift (ret x) = (ret x : t m a)
lift ((__>>=__ : m a * (a ->? m b) ->? m b) (p, q))
= (__>>=__ : t m a * (a ->? t m b) ->? t m b)
  (lift p, \ y .! lift (q y) : t m b)
%% Diagnostics -----------------------------------------------------------
### Hint 2.7, is type variable 'f'
### Hint 2.19, is type variable 'a'
### Hint 2.22, is type variable 'b'
### Hint 2.25, is type variable 'c'
### Hint 4.8, not a kind 'f a'
### Hint 4.16, not a class 'a'
### Hint 4.16, not a class 'b'
### Hint 4.27, not a class 'b'
### Hint 4.27, not a class 'c'
### Hint 9.7, is type variable 'm'
### Hint 9.17, is type variable 'a'
### Hint 9.17, rebound type variable 'a'
### Hint 9.20, is type variable 'b'
### Hint 9.20, rebound type variable 'b'
### Hint 9.23, is type variable 'c'
### Hint 9.23, rebound type variable 'c'
### Hint 13.8, not a class 'a'
### Hint 13.7, rebound variable 'x'
### Hint 13.11, not a class 'a'
### Hint 13.17, not a kind 'm a'
### Hint 13.25, not a kind 'a ->? m b'
### Hint 13.39, not a kind 'b ->? m c'
### Hint 13.53, not a kind 'a ->? b'
### Hint 13.52, rebound variable 'f'
### Hint 14.14-14.24, rejected '__->?__ < __->__' of '((op ret : forall m : Monad; a : Type . a -> m a) (var x : a),
 (var q : a ->? m b))'

### Hint 14.14-14.24, untypable term (with type: _v116_m _v117_a * (_v117_a -> _v116_m _v118_b))
   '(ret x, q)'
### Hint 15.12, rebound variable 'x'
### Hint 15.19-15.33, rejected '__->?__ < __->__' of '((op ret : forall m : Monad; a : Type . a -> m a)
 ((var f : a ->? b) (var x : a)),
 (var r : b ->? m c))'

### Hint 15.19-15.33, untypable term (with type: _v217_m _v218_a * (_v218_a -> _v217_m _v219_b))
   '(ret (f x), r)'
### Hint 15.9-15.33, rejected '__->?__ < __->__' of '((var p : m a),
 \ (var x : a)
 . (op __>>=__ :
    forall m : Monad; a : Type; b : Type . m a * (a ->? m b) ->? m b)
   ((op ret : forall m : Monad; a : Type . a -> m a)
    ((var f : a ->? b) (var x : a)),
    (var r : b ->? m c)))'

### Hint 15.3-15.26, untypable term (with type: _v180_m _v181_a * (_v181_a -> _v180_m _v182_b))
   '(p, \ x : a . ret (f x) >>= r)'
### Hint 15.12, rebound variable 'x'
### Hint 15.19-15.33, rejected '__->?__ < __->__' of '((op ret : forall m : Monad; a : Type . a -> m a)
 ((var f : a ->? b) (var x : a)),
 (var r : b ->? m c))'

### Hint 15.19-15.33, untypable term (with type: _v268_m _v269_a * (_v269_a -> _v268_m _v270_b))
   '(ret (f x), r)'
### Hint 16.13, rebound variable 'x'
### Hint 16.11-16.25, rejected '__->?__ < __->__' of '((var p : m a),
 \ (var x : a)
 . (var r : b ->? m c) ((var f : a ->? b) (var x : a)))'

### Hint 16.5-16.25, untypable term (with type: _v318_m _v319_a * (_v319_a -> _v318_m _v320_b))
   '(p, \ x : a . r (f x))'
### Hint 16.13, rebound variable 'x'
### Hint, rejected '__->?__ < __->__' of '((var p : m a), (var q : a ->? m b))'

### Hint 18.4-18.10, untypable term (with type: _v472_m _v473_a * (_v473_a -> _v472_m _v474_b))
   '(p, q)'
### Hint 18.3-18.17, rejected '__->?__ < __->__' of '((op __>>=__ :
  forall m : Monad; a : Type; b : Type . m a * (a ->? m b) ->? m b)
 ((var p : m a), (var q : a ->? m b)),
 (var r : b ->? m c))'

### Hint 18.3-18.17, untypable term (with type: _v436_m _v437_a * (_v437_a -> _v436_m _v438_b))
   '(p >>= q, r)'
### Hint, rejected '__->?__ < __->__' of '((var p : m a), (var q : a ->? m b))'

### Hint 18.4-18.10, untypable term (with type: _v508_m _v509_a * (_v509_a -> _v508_m _v510_b))
   '(p, q)'
### Hint 18.29, rebound variable 'x'
### Hint 18.44, rejected '__->?__ < __->__' of '((var q : a ->? m b) (var x : a), (var r : b ->? m c))'

### Hint 18.36-18.44, untypable term (with type: _v581_m _v582_a * (_v582_a -> _v581_m _v583_b))
   '(q x, r)'
### Hint 18.27-18.44, rejected '__->?__ < __->__' of '((var p : m a),
 \ (var x : a)
 . (op __>>=__ :
    forall m : Monad; a : Type; b : Type . m a * (a ->? m b) ->? m b)
   ((var q : a ->? m b) (var x : a), (var r : b ->? m c)))'

### Hint 18.21-18.36, untypable term (with type: _v544_m _v545_a * (_v545_a -> _v544_m _v546_b))
   '(p, \ x : a . q x >>= r)'
### Hint 18.29, rebound variable 'x'
### Hint 18.44, rejected '__->?__ < __->__' of '((var q : a ->? m b) (var x : a), (var r : b ->? m c))'

### Hint 18.36-18.44, untypable term (with type: _v626_m _v627_a * (_v627_a -> _v626_m _v628_b))
   '(q x, r)'
### Hint 20.16, refined class 'Monad'
### Hint 21.7, is type variable 'm'
### Hint 21.7, rebound type variable 'm'
### Hint 21.17, is type variable 'a'
### Hint 21.17, rebound type variable 'a'
### Hint 21.20, is type variable 'b'
### Hint 21.20, rebound type variable 'b'
### Hint 21.30, not a class 'a'
### Hint 21.30, not a class 'b'
### Hint 21.29, rebound variable 'f'
### Hint 21.41, not a kind 'm a'
### Hint 21.40, rebound variable 'x'
### Hint 22.21, rebound variable 'y'
### Hint 22.19-22.35, rejected '__->?__ < __->__' of '((var x : m a),
 \ (var y : a)
 . (op ret : forall m : Monad; a : Type . a -> m a)
   ((var f : a -> b) (var y : a)))'

### Hint 22.13-22.35, untypable term (with type: _v733_m _v734_a * (_v734_a -> _v733_m _v735_b))
   '(x, \ y : a . ret (f y))'
### Hint 22.21, rebound variable 'y'
### Hint 25.7, is type variable 't'
### Hint 25.18, is type variable 'm'
### Hint 25.18, rebound type variable 'm'
### Hint 25.28, is type variable 'a'
### Hint 25.28, rebound type variable 'a'
### Hint 27.8, not a class 'a'
### Hint 27.7, rebound variable 'x'
### Hint 27.14, not a kind 'm a'
### Hint 27.13, rebound variable 'p'
### Hint 27.21, is type variable 'b'
### Hint 27.21, rebound type variable 'b'
### Hint 27.31, not a kind 'a -> m b'
### Hint 27.30, rebound variable 'q'
### Hint 29.33, rebound variable 'y'
### Hint 29.33, rebound variable 'y'
### Hint 29.33, rebound variable 'y'
### Hint 29.33, rebound variable 'y'
### Hint 31.7, is type variable 'state'
### Hint 33.7, is type variable 'a'
### Hint 33.7, rebound type variable 'a'
### Hint 33.10, is type variable 'b'
### Hint 33.10, rebound type variable 'b'
### Hint 34.6, redeclared type 'ST'
### Hint 35.8, not a class 'a'
### Hint 35.7, rebound variable 'x'
### Hint 35.14, not a kind 'ST state a'
### Hint 35.13, rebound variable 'p'
### Hint 35.29, not a kind 'a ->? ST state b'
### Hint 35.28, rebound variable 'q'
### Hint, in type of '(var x : a)'
  typename 'a' (35.10)
  is not unifiable with type 'a * state' (36.20)

### Hint 36.7, untypable term (with type: a * state)
   'x'
### Hint 36.3-36.42, untypable term (with type: ? _v1135_a * ? _v1135_a)
   '(ret x : ST state a, \ s : state . (x, s))'
*** Error 36.3, no typing for '(ret x : ST state a) = \ s : state . (x, s)'
### Hint, in type of '((var p : ST state a), (var q : a ->? ST state b))'
  typename 'a' (35.31)
  is not unifiable with type 'a * state' (35.25)

### Hint 37.3-37.9, untypable term (with type: _v1164_m _v1165_a * (_v1165_a -> _v1164_m _v1166_b))
   '(p, q)'
### Hint, in type of '((var p : ST state a), (var q : a ->? ST state b))'
  typename 'a' (35.31)
  is not unifiable with type 'a * state' (35.25)

### Hint 37.3-37.9, untypable term (with type: _v1167_m _v1168_a * (_v1168_a ->? _v1167_m _v1169_b))
   '(p, q)'
### Hint 37.5-37.54, untypable term (with type: ? _v1157_a * ? _v1157_a)
   '(p >>= q, \ s1 : state . let (z, s2) = p s1 in q z s2)'
*** Error 37.5, no typing for 'p >>= q = \ s1 : state . let (z, s2) = p s1 in q z s2'
