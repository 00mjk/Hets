class Functor < Type -> Type
class Monad < Functor
type List : Monad
var a : Type; b : Type
var m : Monad
op fail : m a
op return : a -> m a
var f : Functor
op fmap : (a -> b) -> f a -> f b
op empty : List a
type Set : Functor
op emptySet : Set a
. ((fun __=__[Set _v12] : forall a : Type . a * a ->? Unit) :
       Set _v12 * Set _v12 ->? Unit)
    ((op fail[_v12; Set] : forall a : Type; m : Monad . m a) :
         Set _v12,
     (op emptySet[_v12] : forall a : Type . Set a) : Set _v12) :
      Unit
. ((fun __=__[List _v27] : forall a : Type . a * a ->? Unit) :
       List _v27 * List _v27 ->? Unit)
    ((op fail[_v27; List] : forall a : Type; m : Monad . m a) :
         List _v27,
     (op empty[_v27] : forall a : Type . List a) : List _v27) :
      Unit
op map : (a -> b) -> List a -> List b
op __bind__ : m a * (a -> m b) -> m b
var g : a -> b
var x : m a
. ((fun __=__[List a -> List b]
    : forall a : Type . a * a ->? Unit) :
       (List a -> List b) * (List a -> List b) ->? Unit)
    (((op fmap[a; b; List]
       : forall a : Type; b : Type; f : Functor .
           (a -> b) -> f a -> f b) :
          (a -> b) -> List a -> List b)
       (var g : a -> b) :
         List a -> List b,
     ((op map[a; b]
       : forall a : Type; b : Type . (a -> b) -> List a -> List b) :
          (a -> b) -> List a -> List b)
       (var g : a -> b) :
         List a -> List b) :
      Unit
. ((fun __=__[m b] : forall a : Type . a * a ->? Unit) :
       m b * m b ->? Unit)
    ((((op fmap[a; b; m]
        : forall a : Type; b : Type; f : Functor .
            (a -> b) -> f a -> f b) :
           (a -> b) -> m a -> m b)
        (var g : a -> b) :
          m a -> m b)
       (var x : m a) :
         m b,
     ((op __bind__[a; b; m]
       : forall a : Type; b : Type; m : Monad . m a * (a -> m b) -> m b) :
          m a * (a -> m b) -> m b)
       (var x : m a,
        (\ (var y : a)
           .! ((op return[b; m] : forall a : Type; m : Monad . a -> m a) :
                   b -> m b)
                ((var g : a -> b)(var y : a) : b) :
                  m b) :
            a -> m b) :
         m b) :
      Unit
%% Classes ---------------------------------------------------------------
Functor < Type -> Type
Monad < Functor
%% Type Constructors -----------------------------------------------------
? : +Type -> Type
List : Monad
Logical : Type := ? Unit
Pred : -Type -> Type := \ a : -Type . a ->? Unit
Set : Functor
Unit : Type
__*__ : +Type -> +Type -> Type
__*__*__ : +Type -> +Type -> +Type -> Type
__*__*__*__ : +Type -> +Type -> +Type -> +Type -> Type
__*__*__*__*__ : +Type -> +Type -> +Type -> +Type -> +Type -> Type
__-->__ : -Type -> +Type -> Type < (__-->?__, __->__)
__-->?__ : -Type -> +Type -> Type < __->?__
__->__ : -Type -> +Type -> Type < __->?__
__->?__ : -Type -> +Type -> Type
%% Type Variables --------------------------------------------------------
a  : Type %(var_1)%
b  : Type %(var_2)%
f  : Functor %(var_4)%
m  : Monad %(var_3)%
%% Assumptions -----------------------------------------------------------
__/\__ : ? Unit * ? Unit ->? Unit %(fun)%
__<=>__ : ? Unit * ? Unit ->? Unit %(fun)%
__=__ : forall a : Type . a * a ->? Unit %(fun)%
__=>__ : ? Unit * ? Unit ->? Unit %(fun)%
__=e=__ : forall a : Type . a * a ->? Unit %(fun)%
__\/__ : ? Unit * ? Unit ->? Unit %(fun)%
__bind__
  : forall a : Type; b : Type; m : Monad . m a * (a -> m b) -> m b
    %(op)%
__if__ : ? Unit * ? Unit ->? Unit %(fun)%
__when__else__ : forall a : Type . a * ? Unit * a ->? a %(fun)%
bottom : forall a : Type . a %(fun)%
def__ : forall a : Type . a ->? Unit %(fun)%
empty : forall a : Type . List a %(op)%
emptySet : forall a : Type . Set a %(op)%
fail : forall a : Type; m : Monad . m a %(op)%
false : Unit %(fun)%
fmap
  : forall a : Type; b : Type; f : Functor . (a -> b) -> f a -> f b
    %(op)%
map
  : forall a : Type; b : Type . (a -> b) -> List a -> List b %(op)%
not__ : ? Unit ->? Unit %(fun)%
return : forall a : Type; m : Monad . a -> m a %(op)%
true : Unit %(fun)%
¬__ : ? Unit ->? Unit %(fun)%
%% Variables -------------------------------------------------------------
g : a -> b
x : m a
%% Sentences -------------------------------------------------------------
(__=__ : Set _v12 * Set _v12 ->? Unit)
  (fail : Set _v12, emptySet : Set _v12) :
    Unit
(__=__ : List _v27 * List _v27 ->? Unit)
  (fail : List _v27, empty : List _v27) :
    Unit
(__=__ : (List a -> List b) * (List a -> List b) ->? Unit)
  ((fmap : (a -> b) -> List a -> List b)(g) : List a -> List b,
   (map : (a -> b) -> List a -> List b)(g) : List a -> List b) :
    Unit
(__=__ : m b * m b ->? Unit)
  (((fmap : (a -> b) -> m a -> m b)(g) : m a -> m b)(x) : m b,
   (__bind__ : m a * (a -> m b) -> m b)
     (x, (\ y .! (return : b -> m b)(g(y) : b) : m b) : a -> m b) :
       m b) :
    Unit
%% Diagnostics -----------------------------------------------------------
*** Hint 7.5, is type variable 'a'
*** Hint 7.8, is type variable 'b'
*** Hint 9.5, is type variable 'm'
*** Hint 15.5, is type variable 'f'
*** Hint 25.8, constrain 'Set : Monad' is unprovable
  known kinds are: [ Functor ]
*** Error 25.8, in term'((fun __=__[Set _v12] : forall a : Type . a * a ->? Unit) :
     Set _v12 * Set _v12 ->? Unit)
  ((op fail[_v12; Set] : forall a : Type; m : Monad . m a) :
       Set _v12,
   (op emptySet[_v12] : forall a : Type . Set a) : Set _v12) :
    Unit' of type 'Unit'
 unresolved constraints '{ Set : Monad }'
*** Hint 33.7, not a class 'a'
*** Hint 33.7, not a class 'b'
*** Hint 33.23, not a kind 'm a'
