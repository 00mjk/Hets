%% predefined universe containing all types, 
%% superclass of all other classes
class Type < Type
var s : Type; t : Type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% invisible type "Unit" for formulae
type Unit
     %% flat cpo with bottom
     %% type aliases
type Pred __ : Type -> Type := \ t : Type- . t ->? Unit
type ? __ := \ t : Type . Unit ->? t
pred true, false : Unit
pred __/\__, __\/__, __=>__, __if__, __<=>__ : Unit * Unit
pred not : Unit
pred __=__ : forall s : Type . s * s
     %% =e=
     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
     %% (builtin) type (constructors)
type __->?__ : Type- -> Type+ -> Type
%% nested pairs are different from n-tupels (n > 2)
type __*__ : Type+ -> Type+ -> Type
type  : Type+ -> Type+ -> Type+ -> Type
%% ...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% "pred p args = e" abbreviates "op p args :? unit = e"  
%% CASL requires "<=>" for pred-defn and disallows "()" as result
op def, tt : forall s : Type . Pred s
var x : s
program (op def[_var_1] : forall s : Type . Pred s) =
            \ (var x : s) . ()
        %% def is also total (identical to tt) 
program (op tt[_var_4] : forall s : Type . Pred s) =
            \ (var x : s) . ()
        %% tt is total "op tt(x: s): unit = ()"
program __ und __ (x, y : Unit) : Unit = ()
%% total function type
type __->__ : Type- -> Type+ -> Type
type __->__(s : Type)(t : Type) < s ->? t
%% total functions
op __res__ : s * t ->? s = \ (var x : s, var y : t) .! (var x : s)
op fst : s * t ->? s = \ (var x : s, var y : t) .! (var x : s)
program snd (x : s, y : t) : t = y
%% trivial because its the strict function property
. (fun __=__[s * t ->? _var_18] : forall s : Type . s * s ->? Unit)
    (\ (var x : s, var y : t) . def (x res y),
     \ (var x : s, var y : t) . (def y) und (def x))
. (fun __=__[s * t ->? s] : forall s : Type . s * s ->? Unit)
    (op fst : s * t ->? s, op __res__ : s * t ->? s)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Internal Logic
pred eq : forall s : Type . s * s
. (fun __=__[_var_36 ->? Unit] : forall s : Type . s * s ->? Unit)
    (\ (var x : _var_36)
       . (pred eq[_var_36] : forall s : Type . s * s)
           (var x : _var_36, var x : _var_36),
     op tt[_var_36] : forall s : Type . Pred s)
. (fun __=__[s * s ->? s] : forall s : Type . s * s ->? Unit)
    (\ (var x : s, var y : s)
       . (op __res__ : s * t ->? s)
           (var x : s,
            (pred eq[s] : forall s : Type . s * s)(var x : s, var y : s)),
     \ (var x : s, var y : s)
       . (op __res__ : s * t ->? s)
           (var y : s,
            (pred eq[s] : forall s : Type . s * s)(var x : s, var y : s)))
%% then %def
%% notation "\ ."  abbreviates "\bla:unit." 
%% where "bla" is never used, but only "()" instead
%% for type inference 
%% an implicit cast from s to ?s of a term "e" yields the term "\ . e"
type s < ? s
program all (p : Pred (s)) : Pred Unit = eq (p, tt)
%% the cast from ?s to s is still done manually here (for the strict "und")
program And (x, y : Pred Unit) : Pred Unit = t1 () und t2 ()
%% use "And" instead of "und" to avoid cast from "?unit" to "unit"
program __ impl __ (x, y : Pred Unit) : Pred Unit = eq (x, x And y)
program __ or __ (x, y : Pred Unit) : Pred Unit =
            all (\ r : Pred Unit . ((x impl r) und (y impl r)) impl r)
program ex (p : Pred (s)) : Pred Unit =
            all (\ r : Pred Unit . all (\ x : s . p (x) impl r) impl r)
program ff () : Pred Unit = all (\ r : Pred Unit . r ())
program neg (r : Pred Unit) : Pred Unit = r impl ff
%% the type instance for the first "eq" should be "?t" 
%% this is explicitely enforced by "\ .f(x)"
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Recursion (requires "free type nat ::= 0 | Suc(nat)" and "+"  
type nat
class Cpo < Type
      {var c : Cpo; pred __<<=__ : forall c : Cpo . c * c; ;
       pred isChain(s : nat -> c) :? Unit
              = all (\ n : nat . s (n) <<= s (Suc (n)));
       pred isBound(x : c; s : nat -> c) :? Unit
              = all (\ n : nat . s (n) <<= x);
       op sup : forall c : Cpo . (nat -> c) ->? c;}
class Pcpo < Cpo
      {var p : Pcpo; op bottom : forall p : Pcpo . p;}
class instance Flatcpo < Cpo
               {var f : Flatcpo; program __ <<= [f] __ = eq}
var c : Cpo; d : Cpo
type instance __*__ : Cpo+ -> Cpo+ -> Cpo
var x1 : c; x2 : c; y1 : d; y2 : d
program (pred __<<=__[_var_79 * _var_80] : forall c : Cpo . c * c)
          ((var x1 : _var_79, var y1 : _var_80),
           (var x2 : _var_79, var y2 : _var_80))
          = (x1 <<= x2) und (y1 <<= y2)
type instance __*__ : Pcpo+ -> Pcpo+ -> Pcpo
type Unit : Pcpo
%% Pcont
type instance __-->?__ : Cpo- -> Cpo+ -> Pcpo
type __-->?__(c : Cpo)(d : Cpo) < c ->? d
program f <<= [c -->? d] g =
            all (\ x : c . def (f x) impl f (x) <<= g (x))
%% Tcont
type instance __-->__ : Cpo- -> Cpo+ -> Cpo
type __-->__(c : Cpo)(d : Cpo) < c -->? d
var f : c --> d; g : c --> d
program (pred __<<=__[_var_103] : forall c : Cpo . c * c)
          (var f : _var_103, var g : _var_103)
          = f <<= [c -->? d] g
type instance __-->__ : Cpo- -> Pcpo+ -> Pcpo
op Y : (p -->? p) --> p
op undefined : c -->? p = Y (\ x : c -->? p .! x)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% user stuff
free type bool ::= true | 
                   false
type bool : Flatcpo
type nat : Flatcpo
%% Classes ---------------------------------------------------------------
Cpo < Type
Flatcpo < Cpo
Pcpo < Cpo
%% Type Constructors -----------------------------------------------------
Logical : Type := Unit ->? Unit
Pred : Type -> Type := \ a : Type . a ->? Unit
Unit : Pcpo := Unit
__*__
  : (Pcpo+ -> Pcpo+ -> Pcpo, Cpo+ -> Cpo+ -> Cpo,
     Type+ -> Type+ -> Type)
__-->__
  : (Cpo- -> Pcpo+ -> Pcpo, Cpo- -> Cpo+ -> Cpo,
     Type- -> Type+ -> Type) < c -->? d
__-->?__ : (Cpo- -> Cpo+ -> Pcpo, Type- -> Type+ -> Type) < c ->? d
__->__ : Type- -> Type+ -> Type < s ->? t
__->?__ : Type- -> Type+ -> Type
bool
  : Flatcpo
     %[free type bool
         ::= true : bool
             false : bool]%
c : Cpo %(var)%
d : Cpo %(var)%
f : Flatcpo %(var)%
nat : Flatcpo
p : Pcpo %(var)%
s : Type %(var)%
t : Type %(var)%
%% Assumptions -----------------------------------------------------------
__/\__ : Unit * Unit ->? Unit %(fun)%
__<<=__ : forall c : Cpo . c * c ->? Unit %(pred)%
__<=>__ : Unit * Unit ->? Unit %(fun)%
__=__ : forall s : Type . s * s ->? Unit %(fun)%
__=>__ : Unit * Unit ->? Unit %(fun)%
__=e=__ : forall a : Type . a * a ->? Unit %(fun)%
__\/__ : Unit * Unit ->? Unit %(fun)%
__if__ : Unit * Unit ->? Unit %(fun)%
__res__
  : s * t ->? s %(op)% = \ (var x : s, var y : t) .! (var x : s)
__when__else__ : forall a : Type . a * Unit * a ->? a %(fun)%
bottom : forall p : Pcpo . p %(fun)%
def : forall s : Type . Pred s %(op)%
def__ : forall a : Type . a ->? Unit %(fun)%
eq : forall s : Type . s * s ->? Unit %(pred)%
f : c --> d %(var)%
false
  : bool %(construct bool)%
  : Unit ->? Unit %(pred)%
  : Unit %(fun)%
fst : s * t ->? s %(op)% = \ (var x : s, var y : t) .! (var x : s)
g : c --> d %(var)%
not : Unit ->? Unit %(pred)%
not__ : Unit ->? Unit %(fun)%
sup : forall c : Cpo . (nat -> c) ->? c %(op)%
true
  : bool %(construct bool)%
  : Unit ->? Unit %(pred)%
  : Unit %(fun)%
tt : forall s : Type . Pred s %(op)%
¬__ : Unit ->? Unit %(fun)%
%% Sentences -------------------------------------------------------------
program (op def[_var_1] : forall s : Type . Pred s) =
            \ (var x : s) . () %(pe_def)%
program (op tt[_var_4] : forall s : Type . Pred s) =
            \ (var x : s) . () %(pe_tt)%
forall x : s; y : t
  . (fun __=__ : forall a : Type . a * a ->? Unit)
      ((op __res__ : s * t ->? s)(var x : s, var y : t),
       var x : s) %(def___res__)%
forall x : s; y : t
  . (fun __=__ : forall a : Type . a * a ->? Unit)
      ((op fst : s * t ->? s)(var x : s, var y : t),
       var x : s) %(def_fst)%
(fun __=__[s * t ->? _var_18] : forall s : Type . s * s ->? Unit)
  (\ (var x : s, var y : t) . def (x res y),
   \ (var x : s, var y : t) . (def y) und (def x))
(fun __=__[s * t ->? s] : forall s : Type . s * s ->? Unit)
  (op fst : s * t ->? s, op __res__ : s * t ->? s)
(fun __=__[_var_36 ->? Unit] : forall s : Type . s * s ->? Unit)
  (\ (var x : _var_36)
     . (pred eq[_var_36] : forall s : Type . s * s)
         (var x : _var_36, var x : _var_36),
   op tt[_var_36] : forall s : Type . Pred s)
(fun __=__[s * s ->? s] : forall s : Type . s * s ->? Unit)
  (\ (var x : s, var y : s)
     . (op __res__ : s * t ->? s)
         (var x : s,
          (pred eq[s] : forall s : Type . s * s)(var x : s, var y : s)),
   \ (var x : s, var y : s)
     . (op __res__ : s * t ->? s)
         (var y : s,
          (pred eq[s] : forall s : Type . s * s)(var x : s, var y : s)))
free type bool
  ::= true : bool
      false : bool %(ga_bool)%
%% Diagnostics -----------------------------------------------------------
*** Error 4.7, illegal universe class declaration 'Type'
*** Hint 6.5, is type variable 's'
*** Hint 6.7, is type variable 't'
*** Hint 11.6, redeclared type 'Unit'
*** FatalError 14.11, illegal type pattern argument: __
*** FatalError 15.8, illegal type pattern argument: __
*** Error 17.6, illegal overloading of predefined identifier 'true'
*** Error 17.12, illegal overloading of predefined identifier 'false'
*** Error 19.9, illegal overloading of predefined identifier '__/\__'
*** Error 19.17, illegal overloading of predefined identifier '__\/__'
*** Error 19.25, illegal overloading of predefined identifier '__=>__'
*** Error 19.33, illegal overloading of predefined identifier '__if__'
*** Error 19.40, illegal overloading of predefined identifier '__<=>__'
*** Error 22.8, illegal overloading of predefined identifier '__=__'
*** Hint 27.8, redeclared type '__->?__'
*** Hint 30.8, redeclared type '__*__'
*** FatalError 31.6, illegal type pattern: __ * __ * __
*** Error 46.11, unexpected mixfix token: und
*** Hint 50.8, redeclared type '__->__'
*** Error 52.8, incompatible kind of: __->__
  expected: Type- -> Type+ -> Type
     found: Type -> Type -> Type

*** Error 54.42, ambiguous mixfix term
	def__(f(x))
	def(f)(x)
*** Error 54.32, unexpected mixfix token: all
*** Error 54.6, unexpected mixfix token: :
*** Hint 60.9, no type match for: snd
  with type: '_var_7 ->? t' (60.14)
  known types:
    
*** Hint 60.9, wrong result type 't' (60.28)
  for application 'snd(var x : s, var y : t)'
*** Error 60.9, no typing for 'snd(var x : s, var y : t) : t'
*** Error 65.18, ambiguous mixfix term
	def(__res__(x, y))
	def__(__res__(x, y))
*** Error 65.59, unexpected mixfix token: und
*** Error 65.18, unexpected term 'def (x res y)'
*** Error 65.52, unexpected term '(def y) und (def x)'
*** Hint 85.6, redeclared type 's'
*** Error 85.6, merge: TypeVarDefn of 's'

*** Error 85.11, illegal supertype for variable '? s'
*** Hint 87.9, no type match for: all
  with type: '_var_65 ->? Pred Unit' (87.14)
  known types:
    
*** Hint 87.9, wrong result type 'Pred Unit' (87.28)
  for application 'all(var p : Pred s)'
*** Error 87.9, no typing for 'all(var p : Pred s) : Pred Unit'
*** Hint 90.9, no type match for: And
  with type: '_var_67 ->? Pred Unit' (90.14)
  known types:
    
*** Hint 90.9, wrong result type 'Pred Unit' (90.33)
  for application 'And(var x : _var_66, var y : Pred Unit)'
*** Error 90.9, no typing for 'And(var x : _var_66, var y : Pred Unit) : Pred Unit'
*** Error 93.11, unexpected mixfix token: impl
*** Error 95.11, unexpected mixfix token: or
*** Hint 98.9, no type match for: ex
  with type: '_var_68 ->? Pred Unit' (98.13)
  known types:
    
*** Hint 98.9, wrong result type 'Pred Unit' (98.27)
  for application 'ex(var p : Pred s)'
*** Error 98.9, no typing for 'ex(var p : Pred s) : Pred Unit'
*** Hint 101.9, no type match for: ff
  with type: '_var_69 ->? Pred Unit' (101.17)
  known types:
    
*** Hint 101.9, wrong result type 'Pred Unit' (101.17)
  for application 'ff()'
*** Error 101.9, no typing for 'ff() : Pred Unit'
*** Hint 103.9, no type match for: neg
  with type: '_var_70 ->? Pred Unit' (103.14)
  known types:
    
*** Hint 103.9, wrong result type 'Pred Unit' (103.30)
  for application 'neg(var r : Pred Unit)'
*** Error 103.9, no typing for 'neg(var r : Pred Unit) : Pred Unit'
*** Error 108.51, unexpected mixfix token: impl
*** Error 108.22, unexpected mixfix token: all
*** Error 108.3, unexpected mixfix token: all
*** Hint 117.5, is type variable 'c'
*** Error 121.3, unexpected mixfix token: all
*** Error 122.31, unexpected mixfix token: und
*** Error 122.3, unexpected mixfix token: all
*** Error 123.31, unexpected mixfix token: und
*** Error 123.3, unexpected mixfix token: all
*** Error 125.55, unexpected mixfix token: Suc
*** Error 125.32, unexpected mixfix token: all
*** Error 126.38, unexpected mixfix token: all
*** Error 131.42, unexpected mixfix token: isBound
*** Error 130.32, unexpected mixfix token: impl
*** Error 130.3, unexpected mixfix token: all
*** Error 134.20, unexpected mixfix token: isChain
*** Error 134.3, unexpected mixfix token: all
*** Hint 139.5, is type variable 'p'
*** Error 141.4, illegal overloading of predefined identifier 'bottom'
*** Error 143.3, unexpected mixfix token: all
*** Hint 148.6, is type variable 'f'
*** Error 150.15, unexpected mixfix token: [
*** Hint 153.5, is type variable 'c'
*** Hint 153.5, redeclared type 'c'
*** Hint 153.8, is type variable 'd'
*** Error 159.45, unexpected mixfix token: und
*** Error 169.9, incompatible kind of: __-->?__
  expected: Type- -> Type+ -> Type
     found: Type -> Type -> Type

*** Error 171.35, unexpected mixfix token: und
*** Error 174.45, unexpected mixfix token: +
*** Error 173.40, unexpected mixfix token: und
*** Error 172.28, unexpected mixfix token: isChain
*** Error 171.9, unexpected mixfix token: all
*** Error 170.7, unexpected mixfix token: :
*** Hint 10.18, no type match for: __::__
  with type: '_var_101 ->? _var_100 ->? _var_91' (176.17)
  known types:
    
*** Hint 10.18, wrong result type '_var_100 ->? _var_91' (176.27)
  for application '__::__(c(var -->? : _var_92)(var d : _var_93), [])'
*** Hint 10.18, wrong result type '_var_91' (176.11)
  for application '__::__(c(var -->? : _var_92)(var d : _var_93), [])(var g : _var_94)'
*** Error 176.13, wrongly typed application '__<<=__
  (var f : _var_91,
   __::__(c(var -->? : _var_92)(var d : _var_93), [])
     (var g : _var_94))'
*** Error 176.13, no typing for '__<<=__(var f : _var_91,
        __::__(c(var -->? : _var_92)(var d : _var_93), [])
          (var g : _var_94))'
*** Error 181.9, incompatible kind of: __-->__
  expected: Type- -> Type+ -> Type
     found: Type -> Type -> Type

*** Error 182.46, ambiguous mixfix term
	def__(f(x))
	def(f)(x)
*** Error 182.36, unexpected mixfix token: all
*** Error 182.7, unexpected mixfix token: :
*** Error 186.26, unexpected mixfix token: c
*** Error 190.9, incompatible kind of: p -->? p
  expected: Cpo-
     found: Type

*** Error 193.32, unexpected mixfix token: impl
*** Error 192.27, unexpected mixfix token: Y
*** Error 192.3, unexpected mixfix token: all
*** Error 195.27, unexpected mixfix token: Y
*** Error 200.20, illegal overloading of predefined identifier 'true'
*** Error 200.27, illegal overloading of predefined identifier 'false'
