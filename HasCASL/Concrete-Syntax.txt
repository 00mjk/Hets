
BASIC-SPEC      ::= BASIC-ITEMS ... BASIC-ITEMS  |  { }

BASIC-ITEMS     ::= SIG-ITEMS  
		  | CLASS-ITEMS
                  | free      type/types DATATYPE-DECL ; ... ; DATATYPE-DECL ;/
                  | generated type/types DATATYPE-DECL ; ... ; DATATYPE-DECL ;/
                  | generated { SIG-ITEMS ... SIG-ITEMS } ;/
                  | var/vars GEN-VAR-DECL ; ... ; GENVAR-DECL ;/
                  | forall GEN-VAR-DECL ; ... ; GEN-VAR-DECL
                             "." AXIOM "." ... "." AXIOM ;/ 
                  | "." AXIOM "." ... "." AXIOM ;/ 

%% for backwards compatibility with CASL v1.0
BASIC-ITEMS     ::= axiom/axioms AXIOM ;...; AXIOM ;/

SIG-ITEMS       ::= sort/sorts SORT-ITEM ; ... ; SORT-ITEM ;/
                  | type/types TYPE-ITEM ; ... ; TYPE-ITEM ;/
                  | type instance/instances TYPE-ITEM ; ... ; TYPE-ITEM ;/
                  | op/ops OP-ITEM ; ... ; OP-ITEM ;/
                  | program/programs PROG-EQ ; ... ; PROG-EQ ;/
                  | pred/preds PRED-ITEM ; ... ; PRED-ITEM ;/      %% old style

%% for backwards compatibility with CASL
SORT-ITEM       ::= TYPE-NAME , ... , TYPE-NAME 
                  | TYPE-NAME , ... , TYPE-NAME < TYPE-NAME 
                  | TYPE-NAME = { VAR : TYPE "." FORMULA } 
                  | TYPE-NAME = ... = TYPE-NAME   

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

TYPE-ITEM       ::= TYPE-NAME , ... , TYPE-NAME  %% same as SORT-ITEM
                  | TYPE-DEFN-PATTERN , .... , TYPE-DEFN-PATTERN : KIND
                  | TYPE-PATTERN := PSEUDOTYPE
                  | TYPE-PATTERN , ... , TYPE-PATTERN < TYPE 
                  | TYPE-PATTERN = { VAR : TYPE "." FORMULA }
                  | TYPE-PATTERN = ... = TYPE-PATTERN
		  | DATATYPE-DECL        %% TYPE-DEFN-PATTERN ::= ALTERNATIVES

%% TYPE , ... , TYPE clashes with intersection class without parenthesis

TYPE-DEFN-PATTERN ::= TYPE-NAME 
		    | TYPE-NAME (TYPE-ARGS) ... (TYPE-ARGS)

TYPE-PATTERN      ::= TYPE-DEFN-PATTERN
		    | PRIM-TYPE-PATTERN ... PRIM-TYPE-PATTERN

PRIM-TYPE-PATTERN ::= [ ID , ... , ID ]      %% compound list
		    | NO-BRACKET-TOKEN       %% TYPE-NAME or TYPE-VAR
		    | { PRIM-TYPE-PATTERN ... PRIM-TYPE-PATTERN } | { }
		    | [ PRIM-TYPE-PATTERN ... PRIM-TYPE-PATTERN ] | [ ]
                    | TYPE-EXT-VAR
		    | TYPE-PATTERN-ARG
		    | (TYPE-PATTERN-ARG)
		    | (TYPE-ARGS)            %% remaining arguments 

TYPE-PATTERN-ARG ::=  TYPE-EXT-VAR : CLASS    
		    | TYPE-VAR : EXT-CLASS
		    | TYPE-VAR < TYPE    
		    | TYPE-VAR > TYPE    

TYPE-VARS       ::= TYPE-VAR , ... , TYPE-VAR

TYPE-EXT-VAR    ::= TYPE-VAR | TYPE-VAR + | TYPE-VAR -
TYPE-EXT-VARS   ::= TYPE-EXT-VAR , ... , TYPE-EXT-VAR

TYPE-ARG        ::= TYPE-EXT-VARS           %% globally declared or universe
		  | TYPE-VARS : EXT-CLASS      
		  | TYPE-EXT-VARS : CLASS      
		  | TYPE-EXT-VARS < TYPE 
		  | TYPE-EXT-VARS > TYPE

TYPE-ARGS       :: TYPE-ARG ; ... ; TYPE-ARG

%% curried kind!
PSEUDOTYPE      ::= TYPE 
                  | \ TYPE-ARGS "." PSEUDOTYPE
%% omit?          | \ (TYPE-ARGS) ... (TYPE-ARGS) "." PSEUDOTYPE  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

CLASS-ITEMS     ::= class/classes CLASS-ITEM ; ... ; CLASS-ITEM ;/
                  | class instance/instances CLASS-ITEM ; ... ; CLASS-ITEM ;/

CLASS-ITEM      ::= CLASS-DECL
		  | CLASS-DECL {BASIC-ITEMS ... BASIC-ITEMS}  
%% without "class" and without "type instance" inside

CLASS-DECL      ::= CLASS-NAME , ... , CLASS-NAME
                  | CLASS-NAME , ... , CLASS-NAME < CLASS
                  | CLASS-NAME = CLASS
                  | CLASS-NAME = ... = CLASS-NMAE

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

UNINST-OP-NAME  :: = ID

OP-NAME        ::= UNINST-OP-NAME 
	         | UNINST-OP-NAME TYPE-INST-LIST ... TYPE-INST-LIST

TYPE-INST-LIST ::= [TYPE-INST-DECL; ... ; TYPE-INST-DECL]

TYPE-INST-DECL ::= TYPE-VAR , ... , TYPE-VAR   %% global type vars
                 | TYPE-VAR-DECL

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

OP-ITEM       ::= OP-NAME , ... , OP-NAME : TYPE-SCHEME
                | OP-NAME , ... , OP-NAME : TYPE-SCHEME, OP-ATTR ,..., OP-ATTR 
                | OP-NAME : TYPE-SCHEME = TERM %% real constant (no shortcut)  
                | OP-NAME OP-ARGS : TYPE = TERM    %% This form is 
                | OP-NAME OP-ARGS :? TYPE = TERM   %% not encouraged
                | OP-NAME :? TYPE = TERM   %% shortcut for OP-NAME () :? ...
				             %% strongly discouraged
%% OP-ARGS instead of OP-HEAD 

OP-ATTR         ::= BIN-ATTR |  unit TERM
BIN-ATTR        ::= assoc  |  comm  |  idem 

PRED-ITEM       ::= OP-NAME, ..., OP-NAME: PRODUCT-TYPE  %% no currying!
                  | OP-NAME ARG-DECLS <=> FORMULA  %% This form is 
                                                   %% not encouraged.
                  | OP-NAME <=> FORMULA            %% Nor is this one.

%% PRED-TYPE =  PRODUCT-TYPE

%% curried ARG-DECLs must be put in parenthesis
%% because a TYPE consumes the following input

OP-ARGS         ::= ARG-DECLS ... ARG-DECLS
ARG-DECLS       ::= ( PATTERN ; ... ; PATTERN ) | ()

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% unknown IDs will become new variables
PATTERN         ::= VAR , ... , VAR        % globally declared 
		  | VAR-DECL
		  | MIXFIX-PATTERN , ... , MIXFIX-PATTERN

MIXFIX-PATTERN  ::= AS-PATTERN ... AS-PATTERN
                  | AS-PATTERN ... AS-PATTERN : TYPE

AS-PATTERN      ::= INST-PATTERN
		  | VAR @ INST-PATTERN 
		  | VAR : TYPE @ INST-PATTERN 

INST-PATTERN    ::= SIMPLE-PATTERN 
		  | SIMPLE-PATTERN [TYPE, ... , TYPE]
		  | ( PATTERN ; ... ; PATTERN ) 
		  | ( )   

SIMPLE-PATTERN  ::= "__"
		  | NO-BRACKET-TOKEN          %% VAR or part of ID
                  | [ PATTERN ; ... ; PATTERN ] | [ ]       %% mixfix/compound 
		  | { PATTERN ; ... ; PATTERN } | { }       %% mixfix 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

PROG-EQ         ::= MIXFIX-PATTERN = TERM        %% TERM without formulae

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DATATYPE-DECL   ::= SIMPLE-DATATYPE-DECL | DERIVING-DATATYPE-DECL

SIMPLE-DATATYPE-DECL   
                ::= TYPE-DEFN-PATTERN "::=" ALTERNATIVE "|" ... "|" ALTERNATIVE
                ::= TYPE-DEFN-PATTERN : KIND "::=" 
					    ALTERNATIVE "|" ... "|" ALTERNATIVE
DERIVING-DATATYPE-DECL
                ::= SIMPLE-DATATYPE-DECL deriving CLASS

%% take instance-notation from TYPE-DEFN-PATTERN 
ALTERNATIVE     ::= UNINST-OP-NAME COMPONENTS ... COMPONENTS     
                  | UNINST-OP-NAME COMPONENTS ... COMPONENTS ?   
                  | UNINST-OP-NAME
                  | sort/sorts TYPE-NAME , ... , TYPE-NAME
                  | type/types TYPE , ... , TYPE                  

%% support for nested products
COMPONENTS      ::= ( COMPONENT ; ... ; COMPONENT ) 
COMPONENT       ::= UNINST-OP-NAME , ... , UNINST-OP-NAME : TYPE
                  | UNINST-OP-NAME , ... , UNINST-OP-NAME :? TYPE
                  | TYPE
		  | ( COMPONENT ; ... ; COMPONENT )  

GEN-VAR-DECL    ::= VAR-DECL | TYPE-VAR-DECL
VAR-DECL        ::= VAR ,..., VAR : TYPE

TYPE-VAR-DECL   ::= TYPE-VAR , ... , TYPE-VAR: CLASS
		  | TYPE-VAR , ... , TYPE-VAR < TYPE

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

KIND          ::= CLASS
		| PROD-CLASS -> ... -> PROD-CLASS -> CLASS

PROD-CLASS    ::= EXT-CLASS * ... * EXT-CLASS

EXT-CLASS     ::= CLASS | CLASS + | CLASS -

%% intersection class must be put in parenthesis
CLASS         ::= SIMPLE-CLASS | (CLASS , ... , CLASS)

SIMPLE-CLASS  ::= type | CLASS-NAME 
		| { SIMPLE-ID . SIMPLE-ID < TYPE } 
		| { SIMPLE-ID . SIMPLE-ID > TYPE } 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
TYPE-SCHEME   ::= TYPE 
	        | forall TYPE-VAR-DECL ; ... ; TYPE-VAR-DECL . TYPE-SCHEME

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

PRIM-TYPE     ::= NO-BRACKET-TOKEN    %% TYPE-VAR or TYPE-NAME
	        | [ ID , ... , ID ]   %% compound list 
		| { TYPE } | { }
		| [ TYPE ] | [ ]
	        | ( TYPE )
		| ( )                 %% unit

MIXFIX-TYPE   ::= PRIM-TYPE ... PRIM-TYPE
                | PRIM-TYPE ... PRIM-TYPE : KIND 

PRODUCT-TYPE  ::= MIXFIX-TYPE * ... * MIXFIX-TYPE

%% product-types (possibly) separated by arrows 
TYPE          ::= PRODUCT-TYPE ARROW ... ARROW PRODUCT-TYPE

%% ARROW must be treated like a terminal in the above rule
ARROW         ::= ->? | -> | -->? | -->

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

FORMULA         ::= TERM   %% of type logical or ?unit

%% EQUAL-OP        ::= "=" | =e= (only for backward compatibility)
%% BIN-CONNECT     ::= /\ | \/ | => | if | <=>

%% also Prelude: not, true, false, def, __when__else__

TERM            ::= MIXFIX-TERM
                  | MIXFIX-TERM TYPE-OP TYPE
		  | MIXFIX-TERM QUANT-TERM
		  | QUANT-TERM
		  | MIXFIX-TERM CASE-TERM
		  | CASE-TERM
		  | MIXFIX-TERM LET-TERM
		  | LET-TERM

MIXFIX-TERM     ::= INST-TERM ... INST-TERM

TYPE-OP         ::= ":" | as | in

LET-TERM        ::= let PROG-EQ ; ... ; PROG-EQ in TERM

%% ";" is already used as item-separator
CASE-TERM       ::= case TERM of PATTERN -> TERM "|" ... "|" PATTERN -> TERM

QUANT-TERM      ::= QUANTIFIER VAR-DECL ;...; VAR-DECL "." TERM 
                  | forall TYPE-VAR-DECL ;...; TYPE-VAR-DECL "." TERM 
		  | \ LAMBDA-DOT TERM     % for unit
		  | \ VAR-DECL LAMBDA-DOT TERM
		  | \ (PATTERN) ... (PATTERN) LAMBDA-DOT TERM

%% case/lambda-Terms must be without formula ingredients

LAMBDA-DOT      ::= "." | ".!"
QUANTIFIER      ::= forall  |  exists  |  exists!

INST-TERM       ::= SIMPLE-TERM
		  | SIMPLE-TERM [TYPE, ... , TYPE]
		  | LITERAL
                  | QUAL-PRED-NAME | QUAL-VAR-NAME | QUAL-OP-NAME 
                  | ( TERM , ... , TERM )  |  ( )		  

SIMPLE-TERM     ::= "__"
		  | NO-BRACKET-TOKEN              %% plus formula keywords     
                  | [ TERM , ... , TERM ]  |  [ ]     %% mixfix/compound
                  | { TERM , ... , TERM }  |  { }     %% mixfix

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

QUAL-VAR-NAME   ::= ( var VAR : TYPE )

INST-OP-NAME    ::= ID [TYPE, ... , TYPE] ... [TYPE, ... , TYPE]

QUAL-PRED-NAME  ::= ( pred UNINST-OP-NAME : TYPE-SCHEME )
		  | ( pred INST-OP-NAME : TYPE)

QUAL-OP-NAME    ::= ( op UNINST-OP-NAME : TYPE-SCHEME )
		  | ( op INST-OP-NAME : TYPE)

TYPE-NAME       ::= ID  %% MIXFIX-COMPOUND-ID
%% exluded are arrows, "*", "<", ">" and  ":=" (and ":", ":?", "=", "::=")

CLASS-NAME      ::= SIMPLE-ID 
%% disjoint with TYPE-VAR and TYPE-NAME ingredients

VAR             ::= ID   %% mixfix but not compound
TYPE-VAR        ::= SIMPLE-ID
