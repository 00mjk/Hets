%% predefined universe containing all types, 
%% superclass of all other classes

class type

typevar s,t  : type 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% invisible type "logical" for formulae

free type logical ::= true | false

op true, false: logical

ops __/\__, __\/__, __=>__, __if__,__<=>__ : logical * logical -> logical
op not : logical -> logical

op __=__,__=e=__ : t * t -> logical

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (builtin) type (constructors)

type __->?__ : type- -> type+ -> type

type unit: type  %% flat cpo with bottom

free type unit ::= ()       %% elsewhere "()" is illegal as constructor

%% nested pairs are different from n-tupels (n > 2)
type __*__ : type+ -> type+ -> type
type __*__*__ : type+ -> type+ -> type+ -> type
...

%% type aliases
type pred (t:type-) = t ->? unit 
type ? (t:type+) = unit ->? t

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% "pred p args = e" abbreviates "op p args :? unit = e"  
%% CASL requires "<=>" for pred-defn and disallows "()" as result

pred def (x: s) = () %% def is also total (identical to tt) 

pred tt (x: s) = ()  %% tt is total "op tt(x: s): unit = ()"

pred __and__ (x, y: unit) = ()

%% total function type
type __->__ : type- -> type+ -> type 

type s -> t = {f: s ->? t . all(\x:s. def f(x))}


%% total functions
op __res__ (x: s; y: t) : s = x 
op fst (x: s; y: t) : s = x
op snd (x: s; y: t) : t = y

%% trivial because its the strict function property

. (\x:s; y:t. def (x res y)) =  (\x:s; y:t. (def y) and (def x)) 
. fst = (__ res__)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Internal Logic

pred eq : s * s

. (\x: s. eq(x, x)) = tt
. (\x, y:s. x res eq(x,y)) = (\x, y:s. y res eq(x,y))

%% then %def

%% notation "\ ."  abbreviates "\bla:unit." 
%% where "bla" is never used, but only "()" instead

%% for type inference 
%% an implicit cast from s to ?s of a term "e" yields the term "\ . e"

type s < ?s

pred all (p: pred(s)) = eq(p, tt)

%% the cast from ?s to s is still done manually here (for the strict "and")
pred And (x, y: ?unit) = t1() and t2()

%% use "And" instead of "and" to avoid cast from "?unit" to "unit"
pred __impl__ (x, y: ?unit) = eq(x, x And y)

pred __or__ (x, y: ?unit) = all(\r: ?unit. 
		((x impl r) and (y impl r)) impl r)

pred ex (p: pred(s)) = all(\r: ?unit.
		all(\x:s. p(x) impl r) impl r)

pred ff () = all(\r: ?unit. r())

pred neg (r: ?unit) = r impl ff

%% the type instance for the first "eq" should be "?t" 
%% this is explicitely enforced by "\ .f(x)"

. all(\f,g: s->?t. all(\x:s. eq(\ .f(x), g(x)) impl eq(f, g))))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Recursion (requires "free type nat ::= 0 | Suc(nat)" and "+"  

class Cpo < type

typevar c : Cpo

pred __<=__ : c * c

. all(\x: c. x <= x)                   %(reflexive)%
. all(\x,y,z: c. (\ .(x <= y) and (y <= z)) impl \ .x <= z)   %(transitive)%
. all(\x,y,z: c. (\ .(x <= y) and (y <= x)) impl \ .eq(x,y))  %(antisymmetric)%

pred isChain (s: nat -> c) = all(\n:nat. s(n) <= s(Suc(n)))
pred isBound (x: c; s: nat -> c) = all(\n:nat. s(n) <= x)  

op sup : (nat -> c) ->? c

. all(\s: nat -> c. (\ .def (sup s)) impl
	\ .isBound(sup s, s) and all(\x:c. (\ .isBound(x, s)) impl 
		\ . (sup s) <= x))         %(sup is minimal bound)%

class Pcpo < Cpo

typevar p : Pcpo

op bottom : p 

. all(\x : p. bottom <= x)   

class Flatcpo < Cpo   %instance

typevar f : Flatcpo 

pred __<=__ : f * f = eq  % instance

typevar c, d: Cpo

type __*__ : Cpo+ -> Cpo+ -> Cpo

pred __<=__ ((x1,y1),(x2,y2): c * d) = (x1 <= x2) and (y1 <= y2) %instance   

type __*__ : Pcpo+ -> Pcpo+ -> Pcpo

type unit : Pcpo

%% Pcont
type __-->?__ : Cpo- -> Cpo+ -> Pcpo

type c -->? d  = {f : c ->? d . 
	all(\x,y: c. (def (f x) and x <= y) impl def (f y)) and
	all(\s: nat -> c. (isChain(s) and def f(sup(s))) impl 
		ex(\m:nat. def f(s(m)) and 
			eq(sup(\n:nat.!f(s(n+m))), f(sup(s)))))

pred __<=__ (f,g: c -->? d) = all(\x:c. def (f x) impl f(x) <= g(x)) %instance

%% Tcont
type __-->__ : Cpo- -> Cpo+ -> Cpo 

type c --> d = {f : c -->? d . all(\x:c. def f(x))}
 
pred __<=__ (f,g: c --> d) = f <= g as c -->? d   %instance?

type __-->__ : Cpo- -> Pcpo+ -> Pcpo

op Y : (p -->? p) --> p

. all(\f: p -->? p . eq(f(Y(f)), Y(f)) and
	all(\x:p . eq(f(x), x) impl Y(f) <= x))

op undefined : c -->? p = Y(\x: c -->? p .! x) 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% user stuff

free type bool ::= true | false

type bool : Flatcpo
type nat : Flatcpo

