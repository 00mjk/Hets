%% predefined universe containing all types, 
%% superclass of all other classes

class type

var s,t  : type 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% invisible type "logical" for formulae

free type logical ::= true | false

op true, false: logical

ops __/\__, __\/__, __=>__, __if__,__<=>__ : logical * logical -> logical
op not : logical -> logical

op __=__,__=e=__ : t * t -> logical

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (builtin) type (constructors)

type __->?__ : type- -> type+ -> type

type unit: type  %% flat cpo with bottom

free type unit ::= ()       %% elsewhere "()" is illegal as constructor

%% nested pairs are different from n-tupels (n > 2)
type __*__ : type+ -> type+ -> type
type __*__*__ : type+ -> type+ -> type+ -> type
...

%% type aliases
type pred (t:type-) = t ->? unit 
type ? (t:type+) = unit ->? t

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% "pred p args = e" abbreviates "op p args :? unit = e"  
%% CASL requires "<=>" for pred-defn and disallows "()" as result

op def, tt : pred s
var x : s

program def = \x: s . () %% def is also total (identical to tt) 

program tt = \x: s . ()  %% tt is total "op tt(x: s): unit = ()"

program __and__ (x, y: unit) : unit = ()


%% total function type
type __->__ : type- -> type+ -> type 

type s -> t < s ->? t

. __ in s -> t = \f: s ->? t . all(\x:s. def f(x))


%% total functions
program __res__ (x: s; y: t) : s = x 
program fst (x: s; y: t) : s = x 
program snd (x: s; y: t) : t = y 


%% trivial because its the strict function property

. (\x:s; y:t. def (x res y)) =  (\x:s; y:t. (def y) and (def x)) 
. fst = (__ res__)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Internal Logic

pred eq : s * s

. (\x: s. eq(x, x)) = tt
. (\x, y:s. x res eq(x,y)) = (\x, y:s. y res eq(x,y))

%% then %def

%% notation "\ ."  abbreviates "\bla:unit." 
%% where "bla" is never used, but only "()" instead

%% for type inference 
%% an implicit cast from s to ?s of a term "e" yields the term "\ . e"

type s < ?s

program all (p: pred(s)) :? unit = eq(p, tt)

%% the cast from ?s to s is still done manually here (for the strict "and")
program And (x, y: ?unit) :? unit = t1() and t2()

%% use "And" instead of "and" to avoid cast from "?unit" to "unit"
program __impl__ (x, y: ?unit) = eq(x, x And y)

program __or__ (x, y: ?unit) :? unit = all(\r: ?unit. 
		((x impl r) and (y impl r)) impl r)

program ex (p: pred(s)) :? unit = all(\r: ?unit.
		all(\x:s. p(x) impl r) impl r)

program ff () :? unit = all(\r: ?unit. r())

program neg (r: ?unit) :? unit = r impl ff

%% the type instance for the first "eq" should be "?t" 
%% this is explicitely enforced by "\ .f(x)"

. all(\f,g: s->?t. all(\x:s. eq(\ .f(x), g(x)) impl eq(f, g))))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Recursion (requires "free type nat ::= 0 | Suc(nat)" and "+"  

class Cpo < type
{
var c : Cpo

pred __<<=__ : c * c

. all(\x: c. x <<= x)                   %(reflexive)%
. all(\x,y,z: c. ((x <<= y) and (y <<= z)) impl x <<= z)   %(transitive)%
. all(\x,y,z: c. ((x <<= y) and (y <<= x)) impl eq(x,y))  %(antisymmetric)%

pred isChain (s: nat -> c) = all(\n:nat. s(n) <<= s(Suc(n)))
pred isBound (x: c; s: nat -> c) = all(\n:nat. s(n) <<= x)  

op sup : (nat -> c) ->? c

. all(\s: nat -> c. def(sup s) impl
	(isBound(sup s, s) and all(\x:c. isBound(x, s) impl sup(s) <<= x)))
                                                     %(sup is minimal bound)%

. all(\s:nat -> c. isChain(s) impl def(sup(s)))      %(sup exists)%
}

class Pcpo < Cpo
{
var p : Pcpo

op bottom : p 

. all(\x : p. bottom <<= x)   
}

class instance Flatcpo < Cpo
{
 var f : Flatcpo 

 program __<<=[f]__ = eq
}

var c, d: Cpo

type instance __*__ : Cpo+ -> Cpo+ -> Cpo

var x1,x2 : c; y1, y2 : d 

program (x1, y1) <<= (x2, y2) = (x1 <<= x2) and (y1 <<= y2) 


type instance __*__ : Pcpo+ -> Pcpo+ -> Pcpo      

type unit : Pcpo

%% Pcont
type instance __-->?__ : Cpo- -> Cpo+ -> Pcpo 

 type c -->? d < c ->? d
 . __ in c -->? d  = \f : c ->? d . 
	all(\x,y: c. (def (f x) and x <<= y) impl def (f y)) and
	all(\s: nat -> c. (isChain(s) and def f(sup(s))) impl 
		ex(\m:nat. def f(s(m)) and 
			eq(sup(\n:nat.!f(s(n+m))), f(sup(s)))))

  program f <<=[c -->? d] g = all(\x:c. def (f x) impl f(x) <<= g(x))

%% Tcont
type instance __-->__ : Cpo- -> Cpo+ -> Cpo

 type c --> d < c -->? d 
 . __ in c --> d = \f : c -->? d . all(\x:c. def f(x))

 var f, g : c --> d

 program f <<= g = f <<=[c -->? d] g 

type instance __-->__ : Cpo- -> Pcpo+ -> Pcpo

op Y : (p -->? p) --> p

. all(\f: p -->? p . eq(f(Y(f)), Y(f)) and
	all(\x:p . eq(f(x), x) impl Y(f) <<= x))

op undefined : c -->? p = Y(\x: c -->? p .! x) 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% user stuff

free type bool ::= true | false

type bool : Flatcpo
type nat : Flatcpo

