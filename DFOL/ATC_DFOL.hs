{-# LINE 1 "DFOL/ATC_DFOL.der.hs" #-}
{-# OPTIONS -w #-}
{- |
Module      :  DFOL/ATC_DFOL.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  similar to LGPL, see HetCATS/LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'DFOL.AS_DFOL.BASIC_SPEC'
'DFOL.AS_DFOL.BASIC_ITEM'
'DFOL.AS_DFOL.TYPE'
'DFOL.AS_DFOL.TERM'
'DFOL.AS_DFOL.FORMULA'
'DFOL.AS_DFOL.SYMB_ITEMS'
'DFOL.AS_DFOL.SYMB_MAP_ITEMS'
'DFOL.AS_DFOL.SYMB_OR_MAP'
'DFOL.Sign.Sign'
'DFOL.Morphism.Morphism'
-}
{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
DFOL/AS_DFOL.hs
DFOL/Sign.hs
DFOL/Morphism.hs
-}

module DFOL.ATC_DFOL () where

import DFOL.AS_DFOL
import Common.AS_Annotation
import Common.Id
import Common.Doc
import Common.DocUtils
import DFOL.Utils
import DFOL.Sign
import Common.Doc
import Common.DocUtils
import DFOL.Morphism
import DFOL.Sign
import Common.Result
import Common.Doc
import Common.DocUtils
import Data.Typeable
import Common.ATerm.Lib
import ATC.AS_Annotation

{-! for DFOL.AS_DFOL.BASIC_SPEC derive : Typeable !-}
{-! for DFOL.AS_DFOL.BASIC_ITEM derive : Typeable !-}
{-! for DFOL.AS_DFOL.TYPE derive : Typeable !-}
{-! for DFOL.AS_DFOL.TERM derive : Typeable !-}
{-! for DFOL.AS_DFOL.FORMULA derive : Typeable !-}
{-! for DFOL.AS_DFOL.SYMB_ITEMS derive : Typeable !-}
{-! for DFOL.AS_DFOL.SYMB_MAP_ITEMS derive : Typeable !-}
{-! for DFOL.AS_DFOL.SYMB_OR_MAP derive : Typeable !-}
{-! for DFOL.Sign.Sign derive : Typeable !-}
{-! for DFOL.Morphism.Morphism derive : Typeable !-}

{-! for DFOL.AS_DFOL.BASIC_SPEC derive : ShATermConvertible !-}
{-! for DFOL.AS_DFOL.BASIC_ITEM derive : ShATermConvertible !-}
{-! for DFOL.AS_DFOL.TYPE derive : ShATermConvertible !-}
{-! for DFOL.AS_DFOL.TERM derive : ShATermConvertible !-}
{-! for DFOL.AS_DFOL.FORMULA derive : ShATermConvertible !-}
{-! for DFOL.AS_DFOL.SYMB_ITEMS derive : ShATermConvertible !-}
{-! for DFOL.AS_DFOL.SYMB_MAP_ITEMS derive : ShATermConvertible !-}
{-! for DFOL.AS_DFOL.SYMB_OR_MAP derive : ShATermConvertible !-}
{-! for DFOL.Sign.Sign derive : ShATermConvertible !-}
{-! for DFOL.Morphism.Morphism derive : ShATermConvertible !-}
{- ? Generated by DrIFT : Look, but Don't Touch. ? -}
--  Imported from other files :-

_tc_BASIC_SPECTc = mkTyCon "DFOL.AS_DFOL.BASIC_SPEC"
instance Typeable BASIC_SPEC where
    typeOf _ = mkTyConApp _tc_BASIC_SPECTc []

_tc_BASIC_ITEMTc = mkTyCon "DFOL.AS_DFOL.BASIC_ITEM"
instance Typeable BASIC_ITEM where
    typeOf _ = mkTyConApp _tc_BASIC_ITEMTc []

_tc_TYPETc = mkTyCon "DFOL.AS_DFOL.TYPE"
instance Typeable TYPE where
    typeOf _ = mkTyConApp _tc_TYPETc []

_tc_TERMTc = mkTyCon "DFOL.AS_DFOL.TERM"
instance Typeable TERM where
    typeOf _ = mkTyConApp _tc_TERMTc []

_tc_FORMULATc = mkTyCon "DFOL.AS_DFOL.FORMULA"
instance Typeable FORMULA where
    typeOf _ = mkTyConApp _tc_FORMULATc []

_tc_SYMB_ITEMSTc = mkTyCon "DFOL.AS_DFOL.SYMB_ITEMS"
instance Typeable SYMB_ITEMS where
    typeOf _ = mkTyConApp _tc_SYMB_ITEMSTc []

_tc_SYMB_MAP_ITEMSTc = mkTyCon "DFOL.AS_DFOL.SYMB_MAP_ITEMS"
instance Typeable SYMB_MAP_ITEMS where
    typeOf _ = mkTyConApp _tc_SYMB_MAP_ITEMSTc []

_tc_SYMB_OR_MAPTc = mkTyCon "DFOL.AS_DFOL.SYMB_OR_MAP"
instance Typeable SYMB_OR_MAP where
    typeOf _ = mkTyConApp _tc_SYMB_OR_MAPTc []

_toATC_BASIC_SPEC att0 xv = case xv of
    Basic_spec a -> do
        (att1, a') <- toShATerm' att0 a
        return $ addATerm (ShAAppl "Basic_spec" [a'] []) att1
_fromATC_BASIC_SPEC ix att0 = case getShATerm ix att0 of
    ShAAppl "Basic_spec" [a] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        (att1, Basic_spec a') }
    u -> fromShATermError "BASIC_SPEC" u
instance ShATermConvertible BASIC_SPEC where
    toShATermAux = _toATC_BASIC_SPEC
    fromShATermAux = _fromATC_BASIC_SPEC

_toATC_BASIC_ITEM att0 xv = case xv of
    Decl a b -> do
        (att1, a') <- toShATerm' att0 a
        (att2, b') <- toShATerm' att1 b
        return $ addATerm (ShAAppl "Decl" [a',b'] []) att2
    Axiom a -> do
        (att1, a') <- toShATerm' att0 a
        return $ addATerm (ShAAppl "Axiom" [a'] []) att1
_fromATC_BASIC_ITEM ix att0 = case getShATerm ix att0 of
    ShAAppl "Decl" [a,b] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        case fromShATerm' b att1 of { (att2, b') ->
        (att2, Decl a' b') }}
    ShAAppl "Axiom" [a] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        (att1, Axiom a') }
    u -> fromShATermError "BASIC_ITEM" u
instance ShATermConvertible BASIC_ITEM where
    toShATermAux = _toATC_BASIC_ITEM
    fromShATermAux = _fromATC_BASIC_ITEM

_toATC_TYPE att0 xv = case xv of
    Sort -> return $ addATerm (ShAAppl "Sort" [] []) att0
    Form -> return $ addATerm (ShAAppl "Form" [] []) att0
    Univ a -> do
        (att1, a') <- toShATerm' att0 a
        return $ addATerm (ShAAppl "Univ" [a'] []) att1
    Func a -> do
        (att1, a') <- toShATerm' att0 a
        return $ addATerm (ShAAppl "Func" [a'] []) att1
    Pi a b -> do
        (att1, a') <- toShATerm' att0 a
        (att2, b') <- toShATerm' att1 b
        return $ addATerm (ShAAppl "Pi" [a',b'] []) att2
_fromATC_TYPE ix att0 = case getShATerm ix att0 of
    ShAAppl "Sort" [] _ -> (att0, Sort)
    ShAAppl "Form" [] _ -> (att0, Form)
    ShAAppl "Univ" [a] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        (att1, Univ a') }
    ShAAppl "Func" [a] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        (att1, Func a') }
    ShAAppl "Pi" [a,b] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        case fromShATerm' b att1 of { (att2, b') ->
        (att2, Pi a' b') }}
    u -> fromShATermError "TYPE" u
instance ShATermConvertible TYPE where
    toShATermAux = _toATC_TYPE
    fromShATermAux = _fromATC_TYPE

_toATC_TERM att0 xv = case xv of
    Identifier a -> do
        (att1, a') <- toShATerm' att0 a
        return $ addATerm (ShAAppl "Identifier" [a'] []) att1
    Appl a b -> do
        (att1, a') <- toShATerm' att0 a
        (att2, b') <- toShATerm' att1 b
        return $ addATerm (ShAAppl "Appl" [a',b'] []) att2
_fromATC_TERM ix att0 = case getShATerm ix att0 of
    ShAAppl "Identifier" [a] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        (att1, Identifier a') }
    ShAAppl "Appl" [a,b] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        case fromShATerm' b att1 of { (att2, b') ->
        (att2, Appl a' b') }}
    u -> fromShATermError "TERM" u
instance ShATermConvertible TERM where
    toShATermAux = _toATC_TERM
    fromShATermAux = _fromATC_TERM

_toATC_FORMULA att0 xv = case xv of
    T -> return $ addATerm (ShAAppl "T" [] []) att0
    F -> return $ addATerm (ShAAppl "F" [] []) att0
    Pred a -> do
        (att1, a') <- toShATerm' att0 a
        return $ addATerm (ShAAppl "Pred" [a'] []) att1
    Equality a b -> do
        (att1, a') <- toShATerm' att0 a
        (att2, b') <- toShATerm' att1 b
        return $ addATerm (ShAAppl "Equality" [a',b'] []) att2
    Negation a -> do
        (att1, a') <- toShATerm' att0 a
        return $ addATerm (ShAAppl "Negation" [a'] []) att1
    Conjunction a -> do
        (att1, a') <- toShATerm' att0 a
        return $ addATerm (ShAAppl "Conjunction" [a'] []) att1
    Disjunction a -> do
        (att1, a') <- toShATerm' att0 a
        return $ addATerm (ShAAppl "Disjunction" [a'] []) att1
    Implication a b -> do
        (att1, a') <- toShATerm' att0 a
        (att2, b') <- toShATerm' att1 b
        return $ addATerm (ShAAppl "Implication" [a',b'] []) att2
    Equivalence a b -> do
        (att1, a') <- toShATerm' att0 a
        (att2, b') <- toShATerm' att1 b
        return $ addATerm (ShAAppl "Equivalence" [a',b'] []) att2
    Forall a b -> do
        (att1, a') <- toShATerm' att0 a
        (att2, b') <- toShATerm' att1 b
        return $ addATerm (ShAAppl "Forall" [a',b'] []) att2
    Exists a b -> do
        (att1, a') <- toShATerm' att0 a
        (att2, b') <- toShATerm' att1 b
        return $ addATerm (ShAAppl "Exists" [a',b'] []) att2
_fromATC_FORMULA ix att0 = case getShATerm ix att0 of
    ShAAppl "T" [] _ -> (att0, T)
    ShAAppl "F" [] _ -> (att0, F)
    ShAAppl "Pred" [a] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        (att1, Pred a') }
    ShAAppl "Equality" [a,b] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        case fromShATerm' b att1 of { (att2, b') ->
        (att2, Equality a' b') }}
    ShAAppl "Negation" [a] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        (att1, Negation a') }
    ShAAppl "Conjunction" [a] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        (att1, Conjunction a') }
    ShAAppl "Disjunction" [a] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        (att1, Disjunction a') }
    ShAAppl "Implication" [a,b] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        case fromShATerm' b att1 of { (att2, b') ->
        (att2, Implication a' b') }}
    ShAAppl "Equivalence" [a,b] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        case fromShATerm' b att1 of { (att2, b') ->
        (att2, Equivalence a' b') }}
    ShAAppl "Forall" [a,b] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        case fromShATerm' b att1 of { (att2, b') ->
        (att2, Forall a' b') }}
    ShAAppl "Exists" [a,b] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        case fromShATerm' b att1 of { (att2, b') ->
        (att2, Exists a' b') }}
    u -> fromShATermError "FORMULA" u
instance ShATermConvertible FORMULA where
    toShATermAux = _toATC_FORMULA
    fromShATermAux = _fromATC_FORMULA

_toATC_SYMB_ITEMS att0 xv = case xv of
    Symb_items a -> do
        (att1, a') <- toShATerm' att0 a
        return $ addATerm (ShAAppl "Symb_items" [a'] []) att1
_fromATC_SYMB_ITEMS ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb_items" [a] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        (att1, Symb_items a') }
    u -> fromShATermError "SYMB_ITEMS" u
instance ShATermConvertible SYMB_ITEMS where
    toShATermAux = _toATC_SYMB_ITEMS
    fromShATermAux = _fromATC_SYMB_ITEMS

_toATC_SYMB_MAP_ITEMS att0 xv = case xv of
    Symb_map_items a -> do
        (att1, a') <- toShATerm' att0 a
        return $ addATerm (ShAAppl "Symb_map_items" [a'] []) att1
_fromATC_SYMB_MAP_ITEMS ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb_map_items" [a] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        (att1, Symb_map_items a') }
    u -> fromShATermError "SYMB_MAP_ITEMS" u
instance ShATermConvertible SYMB_MAP_ITEMS where
    toShATermAux = _toATC_SYMB_MAP_ITEMS
    fromShATermAux = _fromATC_SYMB_MAP_ITEMS

_toATC_SYMB_OR_MAP att0 xv = case xv of
    Symb a -> do
        (att1, a') <- toShATerm' att0 a
        return $ addATerm (ShAAppl "Symb" [a'] []) att1
    Symb_map a b -> do
        (att1, a') <- toShATerm' att0 a
        (att2, b') <- toShATerm' att1 b
        return $ addATerm (ShAAppl "Symb_map" [a',b'] []) att2
_fromATC_SYMB_OR_MAP ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb" [a] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        (att1, Symb a') }
    ShAAppl "Symb_map" [a,b] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        case fromShATerm' b att1 of { (att2, b') ->
        (att2, Symb_map a' b') }}
    u -> fromShATermError "SYMB_OR_MAP" u
instance ShATermConvertible SYMB_OR_MAP where
    toShATermAux = _toATC_SYMB_OR_MAP
    fromShATermAux = _fromATC_SYMB_OR_MAP

_tc_SignTc = mkTyCon "DFOL.Sign.Sign"
instance Typeable Sign where
    typeOf _ = mkTyConApp _tc_SignTc []

_toATC_Sign att0 xv = case xv of
    EmptySig -> return $ addATerm (ShAAppl "EmptySig" [] []) att0
_fromATC_Sign ix att0 = case getShATerm ix att0 of
    ShAAppl "EmptySig" [] _ -> (att0, EmptySig)
    u -> fromShATermError "Sign" u
instance ShATermConvertible Sign where
    toShATermAux = _toATC_Sign
    fromShATermAux = _fromATC_Sign

_toATC_Morphism att0 xv = case xv of
    Morphism a -> do
        (att1, a') <- toShATerm' att0 a
        return $ addATerm (ShAAppl "Morphism" [a'] []) att1
_fromATC_Morphism ix att0 = case getShATerm ix att0 of
    ShAAppl "Morphism" [a] _ ->
        case fromShATerm' a att0 of { (att1, a') ->
        (att1, Morphism a') }
    u -> fromShATermError "Morphism" u
instance ShATermConvertible Morphism where
    toShATermAux = _toATC_Morphism
    fromShATermAux = _fromATC_Morphism

_tc_MorphismTc = mkTyCon "DFOL.Morphism.Morphism"
instance Typeable Morphism where
    typeOf _ = mkTyConApp _tc_MorphismTc []
