<omdoc id="usesall" mid="1111111"
       catalogue="../omstd/catalogue.omdoc"
  ><metadata
    ><Title
      >A Feature-Complete OM Document</Title
    ><Creator role="aut"
      >Michael Kohlhase</Creator
    ><Contributor role="clb"
      >Andreas Franke</Contributor
    ><Subject
      >OM Documents</Subject
    ><Description
      >
  An example of OMDoc, that uses everything, to be used for debugging of OMDoc
  tools
  </Description
    ><Publisher
    /><Date action="initial"
      >2000-07-02</Date
    ><Type
    /><Format
    /><Identifier scheme="other"
      >SR-00-02-usesall</Identifier
    ><Source xmlns="http://purl.org/DC"
    /><Language
    /><Rights/></metadata
  ><catalogue
    ><loc theory="poset" omdoc="poset.omdoc"
    /><loc theory="simpletypes" omdoc="../logics/simpletypes.omdoc"
    /><loc theory="tuthval" omdoc="../logics/truthval.omdoc"
    /><loc theory="ind" omdoc="../logics/ind.omdoc"/></catalogue
  ><omtext id="usesall-intro" type="introduction"
    ><CMP xml:lang="en"
      >
   In this document, we use all OMDoc elements as a reference document,
   to test OMDoc tools, such as parsers and for didactic purposes
  </CMP
    ><CMP xml:lang="de"
      >
   In diesem Referenzdokument benutzen wir alle OMDoc Elemente zum Testen von
   OMDoc Tools, z. B. Parsern und fuer didaktische Zwecke</CMP></omtext
  ><omtext id="useall-t1"
    ><CMP xml:lang="en"
      >We will take the theory of monoids, rings  and
  natural numbers as a first example.</CMP></omtext
  ><theory id="monoids"
    ><commonname
      >The theory of monoids</commonname
    ><symbol id="monoid"
      ><commonname xml:lang="en"
	>monoid</commonname
      ><commonname xml:lang="de"
	>Monoid</commonname
      ><commonname xml:lang="it"
	>monoide</commonname
      ><type system="simply-typed"
	><OMOBJ
	  ><OMSTR
	    >set[any] -> (any -> any -> any) -> any -> bool</OMSTR></OMOBJ></type></symbol
    ><definition type="simple" id="mon-d1" for="monoid"
      ><CMP
	> 
    A structure (M,*,e), in which (M,*) is a semi-group 
    with unit e is called a monoid.
   </CMP></definition></theory
  ><example type="for" id="nat-monoid-ex" for="mon-d1"
    ><CMP xml:lang="en"
      >The natural numbers with addition form a monoid</CMP></example
  ><theory id="group"
    ><imports id="group-import" from="monoid" type="global"
    /><axiom id="group-ax"
      ><CMP
	> Every object in 
    
	<OMOBJ
	  ><OMS name="set" cd="monoids"/></OMOBJ
	> has an inverse. 
  </CMP></axiom></theory
  ><theory id="ring"
    ><symbol id="ring.set"
    /><symbol id="ring.plus"
    /><symbol id="ring.times"
    /><symbol id="ring.zero"
    /><symbol id="ring.one"
    /><symbol id="ring.setstar"
    /><imports id="ring.add.import" from="group" type="global"
      ><morphism id="ring.add.import-morph"
	><requation id="ring.add.import-morph-set"
	  ><pattern
	    ><OMOBJ
	      ><OMS name="set" cd="group"/></OMOBJ></pattern
	  ><value
	    ><OMOBJ
	      ><OMS name="ring.set" cd="ring"/></OMOBJ></value></requation
	><requation id="ring.add.import-morph-op"
	  ><pattern
	    ><OMOBJ
	      ><OMS name="op" cd="group"/></OMOBJ></pattern
	  ><value
	    ><OMOBJ
	      ><OMS name="ring.plus" cd="ring"/></OMOBJ></value></requation
	><requation id="ring.add.import-morph-neut"
	  ><pattern
	    ><OMOBJ
	      ><OMS name="neut" cd="group"/></OMOBJ></pattern
	  ><value
	    ><OMOBJ
	      ><OMS name="ring.zero"
		    cd="ring"/></OMOBJ></value></requation></morphism></imports
    ><imports id="ring.mult.import" from="monoid" type="global"
      ><morphism id="ring.mult.import-morph"
	><requation id="ring.mult.import-morph-set"
	  ><pattern
	    ><OMOBJ
	      ><OMS name="set" cd="monoids"/></OMOBJ></pattern
	  ><value
	    ><OMOBJ
	      ><OMS name="ring.setstar" cd="ring"/></OMOBJ></value></requation
	><requation id="ring.mult.import-morph-op"
	  ><pattern
	    ><OMOBJ
	      ><OMS name="op" cd="monoids"/></OMOBJ></pattern
	  ><value
	    ><OMOBJ
	      ><OMS name="ring.times" cd="ring"/></OMOBJ></value></requation
	><requation id="ring.mult.import-morph-neut"
	  ><pattern
	    ><OMOBJ
	      ><OMS name="neut" cd="monoids"/></OMOBJ></pattern
	  ><value
	    ><OMOBJ
	      ><OMS name="ring.one"
		    cd="ring"/></OMOBJ></value></requation></morphism></imports
    ><definition id="Ring.setstar.def" for="ring.setstar"
      ><CMP
	> 
	<OMOBJ
	  ><OMS name="ring.setstar" cd="ring"/></OMOBJ
	> is 
      
	<OMOBJ
	  ><OMS name="ring.set" cd="ring"/></OMOBJ
	> without 
      
	<OMOBJ
	  ><OMS name="ring.zero" cd="ring"/></OMOBJ
	>.  
    </CMP></definition
    ><axiom id="Ring.distribution"
      ><CMP
	><OMOBJ
	  ><OMS name="plus" cd="monoids"/></OMOBJ
	> distributes over 
      
	<OMOBJ
	  ><OMS name="times" cd="monoids"/></OMOBJ
	> 
    </CMP></axiom></theory
  ><theory id="nats"
    ><commonname
      >natural number theory</commonname
    ><CMP
      >The Peano Axiomatization of Natural Numbers</CMP
    ><adt type="free" id="nat-adt"
      ><sortdef id="pos-nat"
	><commonname
	  >the set of positive natural numbers</commonname
	><constructor id="succ"
	  ><commonname
	    >The successor function</commonname
	  ><argument sort="nat"
	    ><selector id="pred" total="yes"
	      ><commonname
		>The predecessor function</commonname></selector></argument></constructor></sortdef
      ><sortdef id="nat"
	><commonname
	  >the set of natural numbers</commonname
	><constructor id="zero"
	/><insort for="pos-nat"/></sortdef></adt
    ><symbol id="plus"
      ><commonname
	>plus</commonname></symbol
    ><definition type="inductive" id="plus-def" for="plus"
      ><CMP
	>The recursive definition of plus</CMP
      ><requation id="nat-plus-base"
	><pattern
	  ><OMOBJ
	    ><OMA
	      ><OMS name="plus" cd="nats"
	      /><OMV name="X"
	      /><OMS name="zero" cd="nats"/></OMA></OMOBJ></pattern
	><value
	  ><OMOBJ
	    ><OMV name="X"/></OMOBJ></value></requation
      ><requation id="nat-plus-step"
	><pattern
	  ><OMOBJ
	    ><OMA
	      ><OMS name="plus" cd="nats"
	      /><OMA
		><OMS name="succ" cd="nats"
		/><OMV name="X"/></OMA
	      ><OMV name="Y"/></OMA></OMOBJ></pattern
	><value
	  ><OMOBJ
	    ><OMA
	      ><OMS name="succ" cd="nats"
	      /><OMA
		><OMS name="plus" cd="nats"
		/><OMV name="X"
		/><OMV name="Y"/></OMA></OMA></OMOBJ></value></requation></definition
    ><symbol id="times"
      ><commonname
	>times</commonname></symbol
    ><symbol id="unary-minus-nat"
      ><commonname
	>minus</commonname></symbol
    ><presentation id="umn" for="unary-minus-nat" parent="OMA"
		   fixity="prefix" precedence="5"
      ><use format="html"
	>-</use></presentation
    ><presentation id="pl" for="plus" parent="OMA" fixity="assoc"
		   precedence="20"
      ><use format="html"
	>+</use></presentation
    ><presentation id="ti" for="times" parent="OMA" fixity="assoc"
		   precedence="10"
      ><use format="html"
	>*</use></presentation
    ><presentation id="ze" for="zero"
      ><use format="html"
	>0</use></presentation
    ><presentation id="su" for="succ" parent="OMA"
      ><use format="html"
	>s</use></presentation
    ><assertion id="prec-test"
      ><CMP
	>
    We will use an arithmetical expression to test the precedence:
   
	<OMOBJ
	  ><OMA
	    ><OMS name="eq" cd="relation1"
	    /><OMA
	      ><OMS name="plus" cd="nats"
	      /><OMA
		><OMS name="times" cd="nats"
		/><OMI
		  >3</OMI
		><OMI
		  >4</OMI></OMA
	      ><OMI
		>7</OMI></OMA
	    ><OMA
	      ><OMS name="unary-minus-nat" cd="nats"
	      /><OMV name="X"/></OMA></OMA></OMOBJ
	>
 this one should not contain any brackets. The next one is a variant of the
 left-hand side, it needs brackets around the sum. 

	<OMOBJ
	  ><OMA
	    ><OMS name="times" cd="nats"
	    /><OMA
	      ><OMS name="plus" cd="nats"
	      /><OMI
		>3</OMI
	      ><OMI
		>4</OMI></OMA
	    ><OMI
	      >7</OMI></OMA></OMOBJ
	>, since in our example, multiplication binds stronger than addition.
   </CMP></assertion></theory
  ><alternative theory="nats" type="inductive" entailed-by="plus-def"
		entails="plus-def" entailed-by-thm="dummy1" entails-thm="dummy2"
		id="nat-plus-def-2" for="plus"
    ><CMP
      >The recursive definition of plus on the second argument</CMP
    ><requation id="nat-plus-2-base"
      ><pattern
	><OMOBJ
	  ><OMA
	    ><OMS name="plus" cd="nats"
	    /><OMS name="zero" cd="nats"
	    /><OMV name="X"/></OMA></OMOBJ></pattern
      ><value
	><OMOBJ
	  ><OMV name="X"/></OMOBJ></value></requation
    ><requation id="nat-plus-2-step"
      ><pattern
	><OMOBJ
	  ><OMA
	    ><OMS name="plus" cd="nats"
	    /><OMV name="Y"
	    /><OMA
	      ><OMS name="succ" cd="nats"
	      /><OMV name="X"/></OMA></OMA></OMOBJ></pattern
      ><value
	><OMOBJ
	  ><OMA
	    ><OMS name="succ" cd="nats"
	    /><OMA
	      ><OMS name="plus" cd="nats"
	      /><OMV name="X"
	      /><OMV name="Y"/></OMA></OMA></OMOBJ></value></requation></alternative
  ><theory id="Param"
    ><imports id="Param-imp" from="poset" type="global"
    /><symbol id="Elem" kind="sort"
    /><symbol id="ord"
    /><axiom id="po-ax"
      ><FMP/></axiom
    ><assertion id="po-ass"
      ><CMP
	> we try to format 3+3 for Mathematica</CMP
      ><FMP/></assertion></theory
  ><assertion id="geq-ord" theory="nats"
    ><CMP
      ><OMOBJ
	><OMS name="geq" cd="nats"/></OMOBJ
      > is a
    partial order on 
      <OMOBJ
	><OMS name="nat" cd="nats"/></OMOBJ
      >
  </CMP></assertion
  ><theory id="list.thy"
    ><imports id="list.im" from="Param" type="global"
    /><symbol id="list-sort" kind="sort"
    /><symbol id="cons"
    /><symbol id="nil"
    /><symbol id="ordered"/></theory
  ><theory id="nat-list"
    ><imports id="nat-list.im-nat" from="nats" type="global"
    /><imports id="nat-list.im-Element" from="List" type="local"
      ><morphism id="elem-nat"
	><requation id="elem-nat-eq"
	  ><pattern
	    ><OMOBJ
	      ><OMS name="Elem" cd="Param"/></OMOBJ></pattern
	  ><value
	    ><OMOBJ
	      ><OMS name="Nat"
		    cd="nats"/></OMOBJ></value></requation></morphism></imports
    ><inclusion via="elem-nat-incl"/></theory
  ><axiom-inclusion id="elem-nat-incl" from="nat.thy" to="Param"
    ><morphism id="elem-nat-incl-morph" base="elem-nat"
    /><path-just local="dummy1"
		 globals="dummy2 dummy3"/></axiom-inclusion
  ><theory id="tpres"
    ><symbol id="nullary"
    /><presentation id="nullary-pres" for="nullary"
      ><use format="TeX" requires="texdefs"
	>\nullary</use
      ><use format="html"
	>N</use></presentation
    ><symbol id="prefix-lisp"
    /><presentation id="prefix-lisp-pres" for="prefix-lisp"
		    parent="OMA" fixity="prefix" lbrack="[" rbrack="]"
		    bracket-style="lisp"
      ><use format="TeX" requires="texdefs"
	>\prefixlisp</use
      ><use format="html"
	>pl</use></presentation
    ><symbol id="prefix-math"
    /><presentation id="prefix-math-pres" for="prefix-math"
		    parent="OMA" fixity="prefix" lbrack="[" rbrack="]"
      ><use format="TeX" requires="texdefs"
	>\prefixmath</use
      ><use format="html"
	>pm</use></presentation
    ><symbol id="infix"
    /><presentation id="infix-pres" for="infix" parent="OMA"
		    fixity="infix" lbrack="\{" rbrack="\}"
      ><use format="TeX" requires="texdefs"
	>{\infix}</use
      ><use format="html"
	>in</use></presentation
    ><symbol id="assoc"
    /><presentation id="assoc-pres" for="assoc" parent="OMA"
		    fixity="assoc" lbrack="!" rbrack="!"
      ><use format="TeX"
	>{:}</use
      ><use format="html"
	>:</use></presentation
    ><symbol id="postfix"
    /><presentation id="postfix-pres" for="postfix" parent="OMA"
		    fixity="postfix"
      ><use format="TeX" requires="texdefs"
	>\postfix</use
      ><use format="TeX"
	>pm</use></presentation
    ><symbol id="mixfix"
    /><presentation id="mixfix-pres" for="mixfix" parent="OMA"
		    lbrack="(" rbrack=")"
      ><use format="html"
	>
  <xsl:apply-templates select="*[2]" mode="html"/>
           |-<xsl:apply-templates select="*[3]" mode="html"/>
           :<xsl:apply-templates select="*[4]" mode="html"/></use
      ><use format="TeX"
	>
  <xsl:apply-templates select="*[2]" mode="html"/>
           \vdash<xsl:apply-templates select="*[3]" mode="html"/>
           :<xsl:apply-templates select="*[4]" mode="html"/></use></presentation></theory
  ><omtext id="test"
    ><CMP
      > Now, that we have set up everything, let us test it.</CMP></omtext
  ><omtext id="test1"
    ><CMP
      > 
    We first test a nullary constant: 
     
      <OMOBJ
	><OMS name="nullary" cd="tpres"/></OMOBJ
      >
     for which we have defined custom markup, and one for which we did not:
     
      <OMOBJ
	><OMS name="generic" cd="tpres"/></OMOBJ
      >
     and then a prefix (math brackets):     
     
      <OMOBJ
	><OMA
	  ><OMS name="prefix-math" cd="tpres"
	  /><OMV name="X"
	  /><OMV name="Y"/></OMA></OMOBJ
      >
    then a prefix with lisp brackets:  
     
      <OMOBJ
	><OMA
	  ><OMS name="prefix-lisp" cd="tpres"
	  /><OMV name="X"
	  /><OMV name="Y"/></OMA></OMOBJ
      >
    an infix operator, (note that this is only defined for binary operators, it
  disregards all other arguments):
     
      <OMOBJ
	><OMA
	  ><OMS name="infix" cd="tpres"
	  /><OMV name="X"
	  /><OMV name="Y"/></OMA></OMOBJ
      >.

and an associative operator (this should duplicate the function between any two arguments):
     
      <OMOBJ
	><OMA
	  ><OMS name="assoc" cd="tpres"
	  /><OMV name="X"
	  /><OMV name="Y"
	  /><OMV name="Z"
	  /><OMV name="U"
	  /><OMV name="V"/></OMA></OMOBJ
      >.

    finally, we test a mixfix operator for which we have defined custom markup
     
      <OMOBJ
	><OMA
	  ><OMS name="mixfix" cd="tpres"
	  /><OMV name="G"
	  /><OMV name="A"
	  /><OMV name="alpha"/></OMA></OMOBJ
      >.

   Of course, we can also have presentation for attributes, for instance for the
   type attribute: 
   
      <OMOBJ
	><OMBIND
	  ><OMS name="forall" cd="quant1"
	  /><OMBVAR
	    ><OMATTR
	      ><OMATP
		><OMS name="type" cd="simpletypes"
		/><OMA
		  ><OMS name="funtype" cd="simpletypes"
		  /><OMS name="bool" cd="truthval"
		  /><OMS name="ind" cd="ind"
		  /><OMV name="alpha"/></OMA></OMATP
	      ><OMV name="X"/></OMATTR></OMBVAR
	  ><OMS name="true" cd="logic1"/></OMBIND></OMOBJ
      >
</CMP></omtext
  ><private id="texdefs"
    ><data format="TeX"/></private></omdoc>
