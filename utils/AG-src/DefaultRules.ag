{- UU_AG
 - Copyright:  S. Doaitse Swierstra, Arthur I. Baars and Andres Loeh
               Department of Computer Science
               Utrecht University
               P.O. Box 80.089
               3508 TB UTRECHT
               the Netherlands
               {swierstra,arthurb,andres}@cs.uu.nl -}
INCLUDE "AbstractSyntax.ag"
INCLUDE "Patterns.ag"
imports
{
import AbstractSyntax
import CommonTypes
import Patterns
import UU_Maps
import UU_Utils
import List (deleteBy,partition)
import UU_Pretty
import Maybe
import ErrorMessages
import UU_Pretty_ext
import Expression
import TokenDef(Pos,noPos)
}
{
attrName fld attr = '_':fld++ "_" ++ attr
locName n         = '_':n
}

-------------------------------------------------------------------------------
--         Passing down corresponding nonterminal and constructor names
----------------------------------------------------------------
ATTR Rule Rules Child Children Alternative Alternatives LocRule LocRules Pattern Patterns [ nt:String | | ]
ATTR Rule Rules Child Children LocRule LocRules Pattern Patterns [ con:String | | ]


-------------------------------------------------------------------------------
--         Errors
-------------------------------------------------------------------------------



-- Everyone that wants to report an error can do this by adding an error message to the
-- stream of errors

ATTR Productions Production Alternatives Alternative
     Child Children LocRule LocRules Rule Rules Pattern Patterns [ | errors:{Errors}| ]

-- initialisation of the error stream
SEM Grammar [ | | errors:{Errors} ]
  | Grammar prods.errors = []

-- threading of errors from right to left
SEM Productions
  | Cons  tl.errors  = @lhs.errors
          hd.errors  = @tl.errors
          lhs.errors = @hd.errors
SEM Alternatives
  | Cons  tl.errors  = @lhs.errors
          hd.errors  = @tl.errors
          lhs.errors = @hd.errors

SEM Children
  | Cons  tl.errors  = @lhs.errors
          hd.errors  = @tl.errors
          lhs.errors = @hd.errors
SEM LocRules
  | Cons  tl.errors  = @lhs.errors
          hd.errors  = @tl.errors
          lhs.errors = @hd.errors
SEM Rules
  | Cons  tl.errors  = @lhs.errors
          hd.errors  = @tl.errors
          lhs.errors = @hd.errors

SEM Patterns
  | Cons  tl.errors  = @lhs.errors
          hd.errors  = @tl.errors
          lhs.errors = @hd.errors

SEM Alternative
  | Alternative locrules.errors = @lhs.errors
                rules.errors    = @locrules.errors
                children.errors = @rules.errors

-------------------------------------------------------------------------------
--
-------------------------------------------------------------------------------

-- Pass down the lhs-attributes and the USE's to each alternative of a production
--
ATTR Productions Production [ useMap : {UseMap} || ]
ATTR Alternatives Alternative [ inh, syn:{[String]} useMap : {(Map Name (String,String))} || ]

SEM Production
  | Production  alts.inh  = getKeys @inh
                alts.syn  = getKeys @syn
                alts.useMap = fromMaybe emptyMap (locateMap @nt @lhs.useMap)

-------------------------------------------------------------------------------
--
-------------------------------------------------------------------------------
types
{
type Environment = Map String String
type Uses = Map Name [Name]
}


ATTR Children [ | | names USE {++} {[]}:{[String]} ]
ATTR Child    [ | | names:{[String]} ]

SEM Child
  | Child lhs.names = [@name]

ATTR Child Children [ locVars : {[String]} | | ]

ATTR Rules Rule [ | mat:{[String]} | ]
-- mat contains attributes for which there is no rule, initially all are rules are missing
SEM Child
  | Child    rules.mat    = getKeys @inh

SEM Rule
  | Rule     lhs.mat      = filter ( /= @attr) @lhs.mat

SEM Alternative
  | Alternative children.env      = list2map  (map (\nm -> (nm,"lhs")) @lhs.inh ++
                                               map (\nm -> (nm,""   )) @children.names
                                              )
                        .locVars  = @locrules.locVars
                -- pass attributes to rules, missing attributes are returned:
                rules.mat         = @lhs.syn
                --
                loc.(uAttr,mAttr) = partition (`contains` @lhs.useMap) @rules.mat
                children.useAttrs = @loc.uAttr
                loc.(rules2,errs) = foldl (prodRules @lhs.nt @con  _LHS @locrules.locVars @children.env)
                                          (@rules.out,@children.errors) @loc.mAttr
                   .newRls        = map (prodUseRule @lhs.useMap @children.uses)  @loc.uAttr ++ @loc.rules2
                lhs.errors        = @errs

ATTR Children Child [ useAttrs:{[Name]} | |  ]


SEM Children [ | | uses:{Uses} ]
  | Cons     lhs.uses     = @hd.uses
             hd.uses      = @tl.uses
  | Nil      lhs.uses     = emptyMap

SEM Child [ | uses:{Uses} |]
  | Child lhs.uses = foldr (\attr us -> if attr `elem` @lhs.useAttrs
                                       then insertComb (++) attr [@name] us
                                       else us
                           ) @lhs.uses (getKeys @syn)
ATTR Child Children [ | env:Environment | ]
SEM Child
  | Child    loc.(newRls,errs) = foldl (prodRules @lhs.nt @lhs.con  @name @lhs.locVars @lhs.env)
                                       (@rules.out,@lhs.errors)  @rules.mat
             lhs.env           = foldr (\attr -> insert attr @name) @lhs.env (getKeys @syn)
                .errors        = @loc.errs
{
prodRules :: String -> String -> String -> [String] -> Environment
          -> (Rules,Errors) -> String -> (Rules,Errors)
prodRules nt con field locals env (rs,err) n =
        let
            (rhs,err') = if n `elem` locals
                            then (Expression noPos $ locName n,err)
                            else maybe undef prhs $ locateMap n env
            prhs t = (case t of
                          ""    -> Expression noPos $ locName n
                          _     -> Expression noPos $ attrName t n
                     ,err)
            undef = (Expression noPos $ "undefined", MissingRule nt con field n:err)
            nr  = Rule n rhs
        in
            (nr : rs ,err')
prodUseRule useMap uses attr =
   let (op,e) = fromMaybe ("","") $ locateMap attr useMap
       chs = fromMaybe [] $ locateMap attr uses
       rhs = case chs of
              [] -> e
              _  -> foldr1 (\e es -> unwords [e, op, es])
                           (map (\fld -> attrName fld attr) chs)
   in Rule attr (Expression noPos rhs)

}
-------------------------------------------------------------------------------
--
-------------------------------------------------------------------------------


ATTR Pattern Patterns LocRule LocRules [ | locVars : {[String]}| ]
ATTR Pattern Patterns [ owrt : {Bool} | | ]

SEM Alternative
  | Alternative locrules.locVars = []


SEM Pattern
  | Var  lhs.locVars = @loc.lv
            .errors  = @loc.es
         loc.(lv,es) = if @name `elem` @lhs.locVars
                           then (@lhs.locVars
                                , if @lhs.owrt
                                     then @lhs.errors
                                     else DupLocal @lhs.nt @lhs.con @name : @lhs.errors
                                )
                           else (@name : @lhs.locVars, @lhs.errors)

  | Alias pat.locVars = @loc.lv
          lhs.errors  = @loc.es
          loc.(lv,es) = if @name `elem` @lhs.locVars
                           then (@lhs.locVars
                                , if @lhs.owrt
                                     then @lhs.errors
                                     else DupLocal @lhs.nt @lhs.con @name : @pat.errors
                                )
                           else (@name : @lhs.locVars, @lhs.errors)

ATTR Pattern LocRule [ | overwritten : {[String]}| ]

SEM LocRules [ || overwritten:{[String]} ]
  | Cons  lhs.overwritten = @hd.overwritten
          hd .overwritten = @tl.overwritten
  | Nil   lhs.overwritten = []

SEM Patterns [ || overwritten:{[String]} ]
  | Cons  lhs.overwritten = @hd.overwritten
          hd .overwritten = @tl.overwritten
  | Nil   lhs.overwritten = []


SEM Pattern
  | Var   lhs.overwritten = if @lhs.owrt
                               then @name : @lhs.overwritten
                               else @lhs.overwritten

  | Alias lhs.overwritten = if @lhs.owrt
                               then @name : @pat.overwritten
                               else @pat.overwritten

-------------------------------------------------------------------------------
--
-------------------------------------------------------------------------------
ATTR Pattern Patterns LocRule [ || containsVars : Bool ]

SEM Pattern
  | Var        lhs.containsVars = not (@name `elem` @lhs.overwritten)
  | Alias      lhs.containsVars = not (@name `elem` @lhs.overwritten)
  | Underscore lhs.containsVars = False

SEM Patterns
  | Cons lhs.containsVars = @hd.containsVars || @tl.containsVars
  | Nil  lhs.containsVars = False



-------------------------------------------------------------------------------
--         Reconstructing the tree
-------------------------------------------------------------------------------

SEM Grammar [ | | out:{Grammar} ]
  | Grammar     lhs.out   = Grammar @typeSyns @useMap @prods.out

SEM Productions [ | | out:{Productions} ]
  | Cons        lhs.out   = @hd.out : @tl.out
  | Nil         lhs.out   = []

SEM Production  [ | | out:{Production} ]
  | Production  lhs.out   = Production @nt @inh @syn @alts.out

SEM Alternatives [ | | out:{Alternatives} ]
  | Cons        lhs.out   = @hd.out : @tl.out
  | Nil         lhs.out   = []

SEM Alternative  [ | | out:{Alternative} ]
  | Alternative lhs.out = Alternative @con @children.out @newRls @locrules.out

SEM Children  [ | | out:{Children} ]
  | Cons        lhs.out = @hd.out : @tl.out
  | Nil         lhs.out = []

SEM Child  [ | | out:{Child} ]
  | Child       lhs.out = Child @name @tp @inh @syn @newRls

SEM Rules [ | | out:{Rules} ]
  | Cons  lhs.out = @hd.out : @tl.out
  | Nil   lhs.out = []

SEM Rule [ | | out:{Rule} ]
  | Rule  lhs.out = Rule @attr @rhs


SEM LocRules [ | | out:{LocRules} ]
  | Cons  lhs.out = if @hd.containsVars
                       then @hd.out : @tl.out
                       else @tl.out
  | Nil   lhs.out = []

SEM LocRule [ | | out:{LocRule} ]
  | LocRule lhs.out = LocRule @pat.out @rhs @owrt

SEM Pattern [ | | out:{Pattern} ]
  | Constr  lhs.out = Constr @pos @name @pats.out
  | Product lhs.out = Product @pos @pats.out
  | Var   lhs.out = if @name `elem` @lhs.overwritten
                       then Underscore @pos
                       else Var @pos @name

  | Alias lhs.out = if @name `elem` @lhs.overwritten
                       then @pat.out
                       else Alias @pos @name @pat.out
  | Underscore lhs.out = Underscore @pos

SEM Patterns [ | | out:{Patterns} ]
  | Cons lhs.out = @hd.out : @tl.out
  | Nil  lhs.out = []