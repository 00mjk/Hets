{- UU_AG
 - Copyright:  S. Doaitse Swierstra, Arthur I. Baars and Andres Loeh
               Department of Computer Science
               Utrecht University
               P.O. Box 80.089
               3508 TB UTRECHT
               the Netherlands
               {swierstra,arthurb,andres}@cs.uu.nl -}
INCLUDE "AbstractSyntax.ag"
INCLUDE "Comments.ag"
INCLUDE "Patterns.ag"
INCLUDE "ExpressionAttr.ag"

imports
{
import CommonTypes
import Patterns
import ErrorMessages
import AbstractSyntax
import Code
import UU_Maps
import Maybe
import UU_Pretty
import UU_Pretty_ext
import UU_Utils
import Expression
}

{
sdtype :: String -> String
sdtype =  ("T_"++)

cataname :: String -> String
cataname =  ("sem_"++)

conname :: Bool -> String -> String -> String
conname rename nt con | rename =  nt ++ "_" ++ con
                      | otherwise = con

semname  :: String -> String -> String
semname nt con = cataname (nt ++ "_" ++ con)

lhsname :: String -> String
lhsname = ("_lhs_"++)

attrname :: String -> String -> String
attrname field attr = '_' : field ++ "_" ++ attr

locname v = '_' : v
}
-------------------------------------------------------------------------------
--         Errors
-------------------------------------------------------------------------------



-- Everyone that wants to report an error can do this by adding an error message to the
-- stream of errors

ATTR Productions Production Alternatives Alternative
     Child Children LocRule LocRules Rule Rules Pattern Patterns [ | errors:{Errors}| ]

-- initialisation of the error stream
SEM Grammar [ | | errors:{Errors} ]
  | Grammar prods.errors = []

-- threading of errors from right to left
SEM Productions
  | Cons  tl.errors  = @lhs.errors
          hd.errors  = @tl.errors
          lhs.errors = @hd.errors
SEM Alternatives
  | Cons  tl.errors  = @lhs.errors
          hd.errors  = @tl.errors
          lhs.errors = @hd.errors

SEM Children
  | Cons  tl.errors  = @lhs.errors
          hd.errors  = @tl.errors
          lhs.errors = @hd.errors
SEM LocRules
  | Cons  tl.errors  = @lhs.errors
          hd.errors  = @tl.errors
          lhs.errors = @hd.errors
SEM Rules
  | Cons  tl.errors  = @lhs.errors
          hd.errors  = @tl.errors
          lhs.errors = @hd.errors

SEM Patterns
  | Cons  tl.errors  = @lhs.errors
          hd.errors  = @tl.errors
          lhs.errors = @hd.errors

SEM Alternative
  | Alternative locrules.errors = @lhs.errors
                rules.errors    = @locrules.errors
                children.errors = @rules.errors
                lhs.errors      = @children.errors
SEM LocRule
  | LocRule rhs.errors = @lhs.errors
            pat.errors = @rhs.errors
            lhs.errors = @pat.errors
-------------------------------------------------------------------------------
--         Distributing name of nonterminal and names of attributes
-------------------------------------------------------------------------------
ATTR Alternatives Alternative Child Children LocRules LocRule Rules Rule [ nt:{String} | | ]
ATTR Child Children LocRules LocRule Rules Rule  [ con:{String} | | ]
ATTR Alternatives Alternative Children [ inh:{[String]} | | ]
ATTR Alternatives Alternative [ syn:{[String]} | | ]

SEM Production
  | Production alts.inh  = getKeys @inh
               alts.syn  = getKeys @syn


-------------------------------------------------------------------------------
--         Distributing options
-------------------------------------------------------------------------------

ATTR Grammar          [ options:{String} | | ]
ATTR Productions Production Alternatives Alternative [ o_cata,o_sig,o_sem,o_rename:{Bool} | | ]
ATTR Productions Production [ o_data:{Bool} | | ]

SEM Grammar
  | Grammar     prods.o_cata    = 'c' `elem` @lhs.options
                     .o_data    = 'd' `elem` @lhs.options
                     .o_sig     = 's' `elem` @lhs.options
                     .o_sem     = 'f' `elem` @lhs.options
                     .o_rename  = 'r' `elem` @lhs.options

-------------------------------------------------------------------------------
--
-------------------------------------------------------------------------------
ATTR Grammar     [ | | prog : {Program} ]
ATTR Productions [ | | decls USE {++} {[]} : {Decls} ]
ATTR Production  [ | | decls : {Decls} ]

SEM Grammar
  | Grammar     lhs.prog = Program @prods.decls


SEM Production
  | Production  lhs.decls = Comment (@nt ++ " " ++ replicate (60 - length @nt) '-') :
                            (if @lhs.o_pretty then @loc.comment : @alts.comments else []) ++
                            (if @lhs.o_data then [@loc.dataDef] else []) ++
                            (if @lhs.o_sig  then @loc.semDom  else []) ++
                            (if @lhs.o_cata then @loc.cataFun else []) ++
                            (if @lhs.o_sem  then @alts.semFuns else [])

-------------------------------------------------------------------------------
--
-------------------------------------------------------------------------------

ATTR Productions Production [ typeSyns : {[(String,String)]} | | ]

SEM Production
  | Production loc.dataDef = let typeSyn tp = Type @nt (List $ SimpleType tp)
                                 dataDef    = Data @nt @alts.dataAlts
                             in maybe dataDef typeSyn $ lookup @nt @lhs.typeSyns

-------------------------------------------------------------------------------
--
-------------------------------------------------------------------------------

SEM Production
  | Production  loc.semDom = let tp = foldr Arr synTps inhTps
                                 synTps = TupleType $ map SimpleType ( getValues @syn)
                                 inhTps = map SimpleType (getValues @inh )
                             in [ Comment "semantic domain"
                                , Type (sdtype @nt) tp
                                ]

-------------------------------------------------------------------------------
--
-------------------------------------------------------------------------------
SEM Production
  | Production loc.cataFun  = let tSig = TSig (cataname @nt)
                                              (SimpleType @nt `Arr` SimpleType (sdtype @nt))
                                  listCata = \tp -> let  cons = SimpleExpr (semname @nt "Cons")
                                                         nil  = SimpleExpr (semname @nt "Nil" )
                                                         arg  = SimpleExpr "list"
                                                         rarg = if tp `elem` @lhs.nts'
                                                                  then SimpleExpr ("(map " ++ (cataname tp) ++ " list)")
                                                                  else arg
                                                         lhs = Fun (cataname @nt) [arg]
                                                         rhs = (App "foldr" [cons,nil,rarg])
                                                     in [Decl lhs rhs]
                              in  Comment "cata" :
                                  (if @lhs.o_sig then [tSig] else []) ++
                                  maybe @alts.cataAlts listCata (lookup @nt @lhs.typeSyns)
-------------------------------------------------------------------------------
--
-------------------------------------------------------------------------------

ATTR Alternatives     [ | | dataAlts : {DataAlts} ]
ATTR Alternative      [ | | dataAlt  : {DataAlt}  ]

SEM Alternatives
  | Cons        lhs.dataAlts  = @hd.dataAlt : @tl.dataAlts
  | Nil         lhs.dataAlts  = []

SEM Alternative
  | Alternative lhs.dataAlt   = DataAlt (conname @lhs.o_rename @lhs.nt @con) (map snd @children.fields)


SEM Child [ | | field : {(String,String)} ]
  | Child lhs.field = (@name, @tp)

SEM Children [ | | fields : {[(String,String)]} ]
  | Cons  lhs.fields = @hd.field : @tl.fields
  | Nil   lhs.fields = []


-------------------------------------------------------------------------------
--         cataAlts
-------------------------------------------------------------------------------
ATTR Alternatives     [ | | cataAlts : {Decls} ]
ATTR Alternative      [ | | cataAlt  : {Decl}  ]


SEM Alternatives
  | Cons lhs.cataAlts = @hd.cataAlt : @tl.cataAlts
  | Nil  lhs.cataAlts = []

SEM Alternative
  | Alternative lhs.cataAlt = let lhs = Fun (cataname @lhs.nt) [lhs_pat]
                                  lhs_pat = App (conname @lhs.o_rename @lhs.nt @con)
                                                (map (SimpleExpr . locname . fst) @children.fields)
                                  rhs = App (semname @lhs.nt @con)
                                            (map argument @children.fields)
                                  argument (nm,tp) | tp `elem` @lhs.nts' = App (cataname tp)
                                                                               [SimpleExpr (locname nm)]
                                                   | otherwise           = SimpleExpr (locname nm)
                              in Decl lhs rhs

-------------------------------------------------------------------------------
--         semFuns
-------------------------------------------------------------------------------
ATTR Alternatives     [ | | semFuns : {Decls} ]
ATTR Alternative      [ | | semFun  : {Decls}  ]


SEM Alternatives
  | Cons lhs.semFuns = @hd.semFun ++ @tl.semFuns
  | Nil  lhs.semFuns = []

SEM Alternative
  | Alternative loc.sFun = let lhs = Fun (semname @lhs.nt @con) lhs_args
                               lhs_args =  map (SimpleExpr . locname . fst) @children.fields
                                        ++ map (SimpleExpr . lhsname)  @lhs.inh

                               rhs = Let (@locrules.decls ++ @children.decls)
                                         (TupleExpr $ map getExpr  @lhs.syn)
                               getExpr attr = let impossible = error $ "This should not happen: attribute not found "
                                                            ++ lhsname attr ++ " of "  ++ @con ++ " of " ++ @lhs.nt
                                              in fromMaybe impossible $ locateMap attr @rules.rMap
                           in Decl lhs rhs

                lhs.semFun = let tsig = TSig (semname @lhs.nt @con) semType
                                 semType = foldr argType
                                                 (SimpleType (sdtype @lhs.nt))
                                                 (map snd @children.fields)
                                 argType tp rec | tp `elem` @lhs.nts' = SimpleType (sdtype tp) `Arr` rec
                                                | otherwise           = SimpleType tp `Arr` rec
                             in if @lhs.o_sig
                                   then [tsig,@loc.sFun]
                                   else [@loc.sFun]




SEM Rules    [ | | rMap : {Map Name Expr}]
  | Cons lhs.rMap = @hd.rMap
         hd.rMap  = @tl.rMap
  | Nil  lhs.rMap = emptyMap

SEM Rule [| rMap : {Map Name Expr}|]
  | Rule lhs.rMap = insert @attr (PP @rhs.pp) @lhs.rMap

ATTR Children [ | | decls USE {++} {[]} : {Decls} ]

SEM Child [ | | decls : {Decls} ]
  | Child lhs.decls = let inhAttrs = getKeys @inh
                          synAttrs = getKeys @syn
                          lhs = TupleLhs  $ map (attrname @name) synAttrs

                          rhs = App (locname @name) (map getExpr inhAttrs)
                          getExpr attr = let impossible =  error $ "This should not happen: attribute not found "
                                                        ++ attrname @name attr
                                         in fromMaybe impossible $ locateMap attr @rules.rMap
                      in if (not.null) synAttrs && @tp `elem` @lhs.nts' then [Decl lhs rhs] else []

SEM LocRules [ | | decls : {Decls} ]
  | Cons lhs.decls = @hd.decl : @tl.decls
  | Nil  lhs.decls = []

SEM LocRule [ | | decl : {Decl} ]
  | LocRule     lhs.decl  = Decl (Pattern @pat.pp) (PP @rhs.pp)


-------------------------------------------------------------------------------
--         Expressions
-------------------------------------------------------------------------------

ATTR Rule LocRule Rules LocRules
     Child Children [locals:{[String]} attrs:{[(String,String)]} | | ]

SEM Alternative
  | Alternative loc.locals = @locrules.locVars ++ map fst @children.fields
                   .attrs  = map ((,) "lhs") @lhs.inh ++ @children.synAttrs

ATTR Children [ | | synAttrs USE {++} {[]} : {[(Name,Name)]} ]
SEM Child [ | | synAttrs:{[(Name,Name)]} ]
  | Child lhs.synAttrs = map ((,) @name) (getKeys @syn)

-------------------------------------------------------------------------------
--  Collect names of types that are considered AG-nonterminals
-------------------------------------------------------------------------------

ATTR Productions Production [ | nts:{[String]} | ]
ATTR Productions Production Alternatives Alternative Children Child [ nts':{[String]} | | ]

SEM Production
  | Production  lhs.nts    = @nt : @lhs.nts

SEM Grammar
  | Grammar     prods.nts' = @prods.nts
                     .nts  = []

-------------------------------------------------------------------------------
--         Pretty printing patterns
-------------------------------------------------------------------------------

SEM Patterns [ | | pps : {[PP_Doc]} ]
  | Cons lhs.pps = @hd.pp : @tl.pps
  | Nil  lhs.pps = []

SEM Pattern [ | | pp:PP_Doc ]
  | Constr  lhs.pp     = pp_parens $ @name >#< hv (map pp_parens @pats.pps)
  | Product lhs.pp     = pp_block "(" ")" "," @pats.pps
  | Var     lhs.pp     = text (locname @name)
  | Alias   lhs.pp     = locname @name >|< "@" >|< @pat.pp
  | Underscore lhs.pp  = text "_"