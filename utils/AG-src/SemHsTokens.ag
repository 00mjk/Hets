{- UU_AG
 - Copyright:  S. Doaitse Swierstra, Arthur I. Baars and Andres Loeh
               Department of Computer Science
               Utrecht University
               P.O. Box 80.089
               3508 TB UTRECHT
               the Netherlands
               {swierstra,arthurb,andres}@cs.uu.nl -}
imports
{
import HsToken
import ErrorMessages
import CommonTypes
import UU_Pretty
import TokenDef
import UU_Pretty
import UU_Pretty_ext
import List
import Char
}

INCLUDE "HsToken.ag"

ATTR HsTokensRoot
     [ nt,con    :{String}
       locals    :{[String]}
       attrs     :{[(String,String)]}
     | errors    :{Errors}
     | usedLocals:{[String]}
       usedAttrs :{[(String,String)]}
       pp        :{PP_Doc}
     ]

-------------------------------------------------------------------------------
--  Errors
-------------------------------------------------------------------------------
ATTR HsTokens HsToken [ |  errors:{Errors} | ]
ATTR HsTokens HsToken [ nt,con   :{String}
                        locals   :{[String]}
                        attrs    :{[(String,String)]}
                      ||
                      ]

SEM HsTokens
  | Cons tl.errors  = @lhs.errors
         hd.errors  = @tl.errors
         lhs.errors = @hd.errors


-------------------------------------------------------------------------------
-- Syntax errors
-------------------------------------------------------------------------------

SEM HsToken
  | Err lhs.errors = let m = text @mesg >#< "at" >#< show @pos >#< "."
                     in CustomError m : @lhs.errors

-------------------------------------------------------------------------------
--  Undefined variables
-------------------------------------------------------------------------------

SEM HsToken
  | AGLocal   lhs.errors = if @var `elem` @lhs.locals
                                 then @lhs.errors
                                 else UndefLocal @pos @lhs.nt @lhs.con @var : @lhs.errors

  | AGField   lhs.errors = if (@field,@attr) `elem` @lhs.attrs
                                 then @lhs.errors
                                 else UndefAttr @pos @lhs.nt @lhs.con @field @attr : @lhs.errors
-------------------------------------------------------------------------------
--         Used variables
-------------------------------------------------------------------------------

ATTR HsTokens HsToken [ | | usedLocals USE {++} {[]} : {[String]}
                            usedAttrs  USE {++} {[]} : {[(String,String)]} ]

SEM HsToken
  | AGLocal lhs.usedLocals = [@var]
  | AGField lhs.usedAttrs  = [(@field,@attr)]
-------------------------------------------------------------------------------
--  Pretty printing
-------------------------------------------------------------------------------

SEM HsTokensRoot
  | HsTokensRoot lhs.pp = let lns = showTokens @tokens.tks
                          in  vlist (map text lns)

SEM HsTokens [ || tks : {[(Pos,String)]} ]
  | Cons lhs.tks = @hd.tok : @tl.tks
  | Nil  lhs.tks = []

SEM HsToken [ || tok:{(Pos,String)}]
   | AGLocal lhs.tok = (@pos, '_' : @var)

   | AGField lhs.tok = (@pos, '_' : @field ++ "_" ++ @attr)

   | HsToken lhs.tok = (@pos, @value)

   | CharToken lhs.tok = (@pos, if null @value
                                   then ""
                                   else showCharShort (head @value)
                         )

   | StrToken  lhs.tok = (@pos, showStrShort @value)
   | Err       lhs.tok = (@pos, "")
{
showTokens :: [(Pos,String)] -> [String]
showTokens [] = []
showTokens xs = map showLine . shiftLeft . getLines $ xs
getLines []         = []
getLines ((p,t):xs) =       let (txs,rest)     = span sameLine xs
                                sameLine (q,_) = line p == line q
                            in ((p,t):txs) : getLines rest
shiftLeft lns =        let sh = let m = minimum . checkEmpty . filter (>=1) . map (column.fst.head) $ lns
                                    checkEmpty [] = [1]
                                    checkEmpty x  = x
                                in if m >= 1 then m-1 else 0
                           shift (p,t) = (if column p >= 1 then p{column = column p - sh} else p, t)
                       in map (map shift) lns
showLine ts =        let f (p,t) r = let ct = column p
                                     in \c -> spaces (ct-c) ++ t ++ r (length t+ct)
                         spaces x | x < 0 = ""
                                  | otherwise = replicate x ' '
                     in foldr f (const "") ts 1


showStrShort xs = "\"" ++ concatMap f xs ++ "\""
  where f '"' = "\\\""
        f x   = showCharShort' x

showCharShort '\'' = "'" ++ "\\'" ++ "'"
showCharShort c    = "'" ++ showCharShort' c ++ "'"

showCharShort' '\a'  = "\\a"
showCharShort' '\b'  = "\\b"
showCharShort' '\t'  = "\\t"
showCharShort' '\n'  = "\\n"
showCharShort' '\r'  = "\\r"
showCharShort' '\f'  = "\\f"
showCharShort' '\v'  = "\\v"
showCharShort' '\\'  = "\\\\"
showCharShort' x | isPrint x = [x]
                 | otherwise = '\\' : show (ord x)
}