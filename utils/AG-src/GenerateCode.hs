-- do not edit; automatically generated by UU_AG
module GenerateCode where

import CommonTypes
import Patterns
import ErrorMessages
import AbstractSyntax
import Code
import UU_Maps
import Maybe
import UU_Pretty
import UU_Pretty_ext
import UU_Utils
import Expression

import CommonTypes
import UU_Pretty
import UU_Maps
import Patterns
import Expression

import List  (intersect, (\\))

import TokenDef(Pos)

import UU_Pretty(PP_Doc)
import Expression
import HsTokenScanner(lexTokens)
import SemHsTokens(sem_HsTokensRoot)
import ErrorMessages
import TokenDef
import CommonTypes
import HsToken

import TokenDef(Pos)

sdtype :: String -> String
sdtype =  ("T_"++)

cataname :: String -> String
cataname =  ("sem_"++)

conname :: Bool -> String -> String -> String
conname rename nt con | rename =  nt ++ "_" ++ con
                      | otherwise = con

semname  :: String -> String -> String
semname nt con = cataname (nt ++ "_" ++ con)

lhsname :: String -> String
lhsname = ("_lhs_"++)

attrname :: String -> String -> String
attrname field attr = '_' : field ++ "_" ++ attr

locname v = '_' : v
-- Alternative -------------------------------------------------
{-
   inherited attributes:
      inh                  : [String]
      nt                   : String
      nts'                 : [String]
      o_cata               : Bool
      o_pretty             : Bool
      o_rename             : Bool
      o_sem                : Bool
      o_sig                : Bool
      syn                  : [String]

   chained attributes:
      errors               : Errors

   synthesised attributes:
      cataAlt              : Decl
      comment              : Decl
      dataAlt              : DataAlt
      semFun               : Decls

-}
{-
   local variables for Alternative.Alternative:
      attrs
      locals
      sFun

-}
-- semantic domain
type T_Alternative = (Errors) ->
                     ([String]) ->
                     (String) ->
                     ([String]) ->
                     (Bool) ->
                     (Bool) ->
                     (Bool) ->
                     (Bool) ->
                     (Bool) ->
                     ([String]) ->
                     ((Decl),(Decl),(DataAlt),(Errors),(Decls))
-- cata
sem_Alternative :: (Alternative) ->
                   (T_Alternative)
sem_Alternative ((Alternative (_con) (_children) (_rules) (_locrules))) =
    (sem_Alternative_Alternative (_con) ((sem_Children (_children))) ((sem_Rules (_rules))) ((sem_LocRules (_locrules))))
sem_Alternative_Alternative :: (String) ->
                               (T_Children) ->
                               (T_Rules) ->
                               (T_LocRules) ->
                               (T_Alternative)
sem_Alternative_Alternative (_con) (_children) (_rules) (_locrules) (_lhs_errors) (_lhs_inh) (_lhs_nt) (_lhs_nts') (_lhs_o_cata) (_lhs_o_pretty) (_lhs_o_rename) (_lhs_o_sem) (_lhs_o_sig) (_lhs_syn) =
    let (_sFun) =
            let lhs = Fun (semname _lhs_nt _con) lhs_args
                lhs_args =  map (SimpleExpr . locname . fst) _children_fields
                         ++ map (SimpleExpr . lhsname)  _lhs_inh
                rhs = Let (_locrules_decls ++ _children_decls)
                          (TupleExpr $ map getExpr  _lhs_syn)
                getExpr attr = let impossible = error $ "This should not happen: attribute not found "
                                             ++ lhsname attr ++ " of "  ++ _con ++ " of " ++ _lhs_nt
                               in fromMaybe impossible $ locateMap attr _rules_rMap
            in Decl lhs rhs
        (_locals) =
            _locrules_locVars ++ map fst _children_fields
        (_attrs) =
            map ((,) "lhs") _lhs_inh ++ _children_synAttrs
        ( _children_decls,_children_errors,_children_fields,_children_synAttrs) =
            (_children (_attrs) (_con) (_rules_errors) (_lhs_inh) (_locals) (_lhs_nt) (_lhs_nts'))
        ( _rules_errors,_rules_rMap) =
            (_rules (_attrs) (_con) (_locrules_errors) (_locals) (_lhs_nt))
        ( _locrules_decls,_locrules_errors,_locrules_locVars) =
            (_locrules (_attrs) (_con) (_lhs_errors) ([]) (_locals) (_lhs_nt))
    in  (let lhs = Fun (cataname _lhs_nt) [lhs_pat]
             lhs_pat = App (conname _lhs_o_rename _lhs_nt _con)
                           (map (SimpleExpr . locname . fst) _children_fields)
             rhs = App (semname _lhs_nt _con)
                       (map argument _children_fields)
             argument (nm,tp) | tp `elem` _lhs_nts' = App (cataname tp)
                                                          [SimpleExpr (locname nm)]
                              | otherwise           = SimpleExpr (locname nm)
         in Decl lhs rhs
        ,Comment . unlines $
            [ replicate 3 ' ' ++ "local variables for " ++ _lhs_nt ++ "." ++ _con ++ ":"
            , unlines . map ((replicate 6 ' ')++) $ _locrules_locVars
            ]
        ,DataAlt (conname _lhs_o_rename _lhs_nt _con) (map snd _children_fields)
        ,_children_errors
        ,let tsig = TSig (semname _lhs_nt _con) semType
             semType = foldr argType
                             (SimpleType (sdtype _lhs_nt))
                             (map snd _children_fields)
             argType tp rec | tp `elem` _lhs_nts' = SimpleType (sdtype tp) `Arr` rec
                            | otherwise           = SimpleType tp `Arr` rec
         in if _lhs_o_sig
               then [tsig,_sFun    ]
               else [_sFun    ]
        )
-- Alternatives ------------------------------------------------
{-
   inherited attributes:
      inh                  : [String]
      nt                   : String
      nts'                 : [String]
      o_cata               : Bool
      o_pretty             : Bool
      o_rename             : Bool
      o_sem                : Bool
      o_sig                : Bool
      syn                  : [String]

   chained attributes:
      errors               : Errors

   synthesised attributes:
      cataAlts             : Decls
      comments             : Decls
      dataAlts             : DataAlts
      semFuns              : Decls

-}
{-
   local variables for Alternatives.Cons:

-}
{-
   local variables for Alternatives.Nil:

-}
-- semantic domain
type T_Alternatives = (Errors) ->
                      ([String]) ->
                      (String) ->
                      ([String]) ->
                      (Bool) ->
                      (Bool) ->
                      (Bool) ->
                      (Bool) ->
                      (Bool) ->
                      ([String]) ->
                      ((Decls),(Decls),(DataAlts),(Errors),(Decls))
-- cata
sem_Alternatives :: (Alternatives) ->
                    (T_Alternatives)
sem_Alternatives (list) =
    (foldr (sem_Alternatives_Cons) (sem_Alternatives_Nil) ((map sem_Alternative list)))
sem_Alternatives_Cons :: (T_Alternative) ->
                         (T_Alternatives) ->
                         (T_Alternatives)
sem_Alternatives_Cons (_hd) (_tl) (_lhs_errors) (_lhs_inh) (_lhs_nt) (_lhs_nts') (_lhs_o_cata) (_lhs_o_pretty) (_lhs_o_rename) (_lhs_o_sem) (_lhs_o_sig) (_lhs_syn) =
    let ( _hd_cataAlt,_hd_comment,_hd_dataAlt,_hd_errors,_hd_semFun) =
            (_hd (_tl_errors) (_lhs_inh) (_lhs_nt) (_lhs_nts') (_lhs_o_cata) (_lhs_o_pretty) (_lhs_o_rename) (_lhs_o_sem) (_lhs_o_sig) (_lhs_syn))
        ( _tl_cataAlts,_tl_comments,_tl_dataAlts,_tl_errors,_tl_semFuns) =
            (_tl (_lhs_errors) (_lhs_inh) (_lhs_nt) (_lhs_nts') (_lhs_o_cata) (_lhs_o_pretty) (_lhs_o_rename) (_lhs_o_sem) (_lhs_o_sig) (_lhs_syn))
    in  (_hd_cataAlt : _tl_cataAlts,_hd_comment : _tl_comments,_hd_dataAlt : _tl_dataAlts,_hd_errors,_hd_semFun ++ _tl_semFuns)
sem_Alternatives_Nil :: (T_Alternatives)
sem_Alternatives_Nil (_lhs_errors) (_lhs_inh) (_lhs_nt) (_lhs_nts') (_lhs_o_cata) (_lhs_o_pretty) (_lhs_o_rename) (_lhs_o_sem) (_lhs_o_sig) (_lhs_syn) =
    let 
    in  ([],[],[],_lhs_errors,[])
-- Child -------------------------------------------------------
{-
   inherited attributes:
      attrs                : [(String,String)]
      con                  : String
      locals               : [String]
      nt                   : String
      nts'                 : [String]

   chained attributes:
      errors               : Errors

   synthesised attributes:
      decls                : Decls
      field                : (String,String)
      synAttrs             : [(Name,Name)]

-}
{-
   local variables for Child.Child:

-}
-- semantic domain
type T_Child = ([(String,String)]) ->
               (String) ->
               (Errors) ->
               ([String]) ->
               (String) ->
               ([String]) ->
               ((Decls),(Errors),((String,String)),([(Name,Name)]))
-- cata
sem_Child :: (Child) ->
             (T_Child)
sem_Child ((Child (_name) (_tp) (_inh) (_syn) (_rules))) =
    (sem_Child_Child (_name) (_tp) (_inh) (_syn) ((sem_Rules (_rules))))
sem_Child_Child :: (String) ->
                   (String) ->
                   (Attributes) ->
                   (Attributes) ->
                   (T_Rules) ->
                   (T_Child)
sem_Child_Child (_name) (_tp) (_inh) (_syn) (_rules) (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_locals) (_lhs_nt) (_lhs_nts') =
    let ( _rules_errors,_rules_rMap) =
            (_rules (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_locals) (_lhs_nt))
    in  (let inhAttrs = getKeys _inh
             synAttrs = getKeys _syn
             lhs = TupleLhs  $ map (attrname _name) synAttrs
             rhs = App (locname _name) (map getExpr inhAttrs)
             getExpr attr = let impossible =  error $ "This should not happen: attribute not found "
                                           ++ attrname _name attr
                            in fromMaybe impossible $ locateMap attr _rules_rMap
         in if (not.null) synAttrs && _tp `elem` _lhs_nts' then [Decl lhs rhs] else []
        ,_rules_errors
        ,(_name, _tp)
        ,map ((,) _name) (getKeys _syn)
        )
-- Children ----------------------------------------------------
{-
   inherited attributes:
      attrs                : [(String,String)]
      con                  : String
      inh                  : [String]
      locals               : [String]
      nt                   : String
      nts'                 : [String]

   chained attributes:
      errors               : Errors

   synthesised attributes:
      decls                : Decls
      fields               : [(String,String)]
      synAttrs             : [(Name,Name)]

-}
{-
   local variables for Children.Cons:

-}
{-
   local variables for Children.Nil:

-}
-- semantic domain
type T_Children = ([(String,String)]) ->
                  (String) ->
                  (Errors) ->
                  ([String]) ->
                  ([String]) ->
                  (String) ->
                  ([String]) ->
                  ((Decls),(Errors),([(String,String)]),([(Name,Name)]))
-- cata
sem_Children :: (Children) ->
                (T_Children)
sem_Children (list) =
    (foldr (sem_Children_Cons) (sem_Children_Nil) ((map sem_Child list)))
sem_Children_Cons :: (T_Child) ->
                     (T_Children) ->
                     (T_Children)
sem_Children_Cons (_hd) (_tl) (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_inh) (_lhs_locals) (_lhs_nt) (_lhs_nts') =
    let ( _hd_decls,_hd_errors,_hd_field,_hd_synAttrs) =
            (_hd (_lhs_attrs) (_lhs_con) (_tl_errors) (_lhs_locals) (_lhs_nt) (_lhs_nts'))
        ( _tl_decls,_tl_errors,_tl_fields,_tl_synAttrs) =
            (_tl (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_inh) (_lhs_locals) (_lhs_nt) (_lhs_nts'))
    in  (_hd_decls ++ _tl_decls,_hd_errors,_hd_field : _tl_fields,_hd_synAttrs ++ _tl_synAttrs)
sem_Children_Nil :: (T_Children)
sem_Children_Nil (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_inh) (_lhs_locals) (_lhs_nt) (_lhs_nts') =
    let 
    in  ([],_lhs_errors,[],[])
-- Expression --------------------------------------------------
{-
   inherited attributes:
      attrs                : [(String,String)]
      con                  : String
      locals               : [String]
      nt                   : String

   chained attributes:
      errors               : Errors

   synthesised attributes:
      pp                   : PP_Doc
      usedAttrs            : [(String,String)]
      usedLocals           : [String]

-}
{-
   local variables for Expression.Expression:
      usedLocals
      usedAttrs
      pp
      errors

-}
-- semantic domain
type T_Expression = ([(String,String)]) ->
                    (String) ->
                    (Errors) ->
                    ([String]) ->
                    (String) ->
                    ((Errors),(PP_Doc),([(String,String)]),([String]))
-- cata
sem_Expression :: (Expression) ->
                  (T_Expression)
sem_Expression ((Expression (_pos) (_txt))) =
    (sem_Expression_Expression (_pos) (_txt))
sem_Expression_Expression :: (Pos) ->
                             (String) ->
                             (T_Expression)
sem_Expression_Expression (_pos) (_txt) (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_locals) (_lhs_nt) =
    let ((_errors,_pp,_usedAttrs,_usedLocals)) =
            let p | line _pos < 1 = Pos "" 1 1
                  | otherwise     = _pos
            in sem_HsTokensRoot (HsTokensRoot $ lexTokens _pos _txt) _lhs_attrs _lhs_con _lhs_errors _lhs_locals _lhs_nt
    in  (_errors,_pp,_usedAttrs,_usedLocals)
-- Grammar -----------------------------------------------------
{-
   inherited attributes:
      options              : String

   chained attributes:

   synthesised attributes:
      errors               : Errors
      prog                 : Program

-}
{-
   local variables for Grammar.Grammar:
      o_pretty

-}
-- semantic domain
type T_Grammar = (String) ->
                 ((Errors),(Program))
-- cata
sem_Grammar :: (Grammar) ->
               (T_Grammar)
sem_Grammar ((Grammar (_typeSyns) (_useMap) (_prods))) =
    (sem_Grammar_Grammar (_typeSyns) (_useMap) ((sem_Productions (_prods))))
sem_Grammar_Grammar :: (TypeSyns) ->
                       (UseMap) ->
                       (T_Productions) ->
                       (T_Grammar)
sem_Grammar_Grammar (_typeSyns) (_useMap) (_prods) (_lhs_options) =
    let (_o_pretty) =
            'p' `elem` _lhs_options
        ( _prods_decls,_prods_errors,_prods_nts) =
            (_prods ([]) ([]) (_prods_nts) ('c' `elem` _lhs_options) ('d' `elem` _lhs_options) (_o_pretty) ('r' `elem` _lhs_options) ('f' `elem` _lhs_options) ('s' `elem` _lhs_options) (_typeSyns))
    in  (_prods_errors,Program _prods_decls)
-- LocRule -----------------------------------------------------
{-
   inherited attributes:
      attrs                : [(String,String)]
      con                  : String
      locals               : [String]
      nt                   : String

   chained attributes:
      errors               : Errors
      locVars              : [String]

   synthesised attributes:
      decl                 : Decl

-}
{-
   local variables for LocRule.LocRule:

-}
-- semantic domain
type T_LocRule = ([(String,String)]) ->
                 (String) ->
                 (Errors) ->
                 ([String]) ->
                 ([String]) ->
                 (String) ->
                 ((Decl),(Errors),([String]))
-- cata
sem_LocRule :: (LocRule) ->
               (T_LocRule)
sem_LocRule ((LocRule (_pat) (_rhs) (_owrt))) =
    (sem_LocRule_LocRule ((sem_Pattern (_pat))) ((sem_Expression (_rhs))) (_owrt))
sem_LocRule_LocRule :: (T_Pattern) ->
                       (T_Expression) ->
                       (Bool) ->
                       (T_LocRule)
sem_LocRule_LocRule (_pat) (_rhs) (_owrt) (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_locals) (_lhs_nt) =
    let ( _pat_errors,_pat_locVars,_pat_pp) =
            (_pat (_rhs_errors) (_lhs_locVars))
        ( _rhs_errors,_rhs_pp,_rhs_usedAttrs,_rhs_usedLocals) =
            (_rhs (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_locals) (_lhs_nt))
    in  (Decl (Pattern _pat_pp) (PP _rhs_pp),_pat_errors,_pat_locVars)
-- LocRules ----------------------------------------------------
{-
   inherited attributes:
      attrs                : [(String,String)]
      con                  : String
      locals               : [String]
      nt                   : String

   chained attributes:
      errors               : Errors
      locVars              : [String]

   synthesised attributes:
      decls                : Decls

-}
{-
   local variables for LocRules.Cons:

-}
{-
   local variables for LocRules.Nil:

-}
-- semantic domain
type T_LocRules = ([(String,String)]) ->
                  (String) ->
                  (Errors) ->
                  ([String]) ->
                  ([String]) ->
                  (String) ->
                  ((Decls),(Errors),([String]))
-- cata
sem_LocRules :: (LocRules) ->
                (T_LocRules)
sem_LocRules (list) =
    (foldr (sem_LocRules_Cons) (sem_LocRules_Nil) ((map sem_LocRule list)))
sem_LocRules_Cons :: (T_LocRule) ->
                     (T_LocRules) ->
                     (T_LocRules)
sem_LocRules_Cons (_hd) (_tl) (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_locals) (_lhs_nt) =
    let ( _hd_decl,_hd_errors,_hd_locVars) =
            (_hd (_lhs_attrs) (_lhs_con) (_tl_errors) (_lhs_locVars) (_lhs_locals) (_lhs_nt))
        ( _tl_decls,_tl_errors,_tl_locVars) =
            (_tl (_lhs_attrs) (_lhs_con) (_lhs_errors) (_hd_locVars) (_lhs_locals) (_lhs_nt))
    in  (_hd_decl : _tl_decls,_hd_errors,_tl_locVars)
sem_LocRules_Nil :: (T_LocRules)
sem_LocRules_Nil (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_locals) (_lhs_nt) =
    let 
    in  ([],_lhs_errors,_lhs_locVars)
-- Pattern -----------------------------------------------------
{-
   inherited attributes:

   chained attributes:
      errors               : Errors
      locVars              : [String]

   synthesised attributes:
      pp                   : PP_Doc

-}
{-
   local variables for Pattern.Alias:

-}
{-
   local variables for Pattern.Constr:

-}
{-
   local variables for Pattern.Product:

-}
{-
   local variables for Pattern.Underscore:

-}
{-
   local variables for Pattern.Var:

-}
-- semantic domain
type T_Pattern = (Errors) ->
                 ([String]) ->
                 ((Errors),([String]),(PP_Doc))
-- cata
sem_Pattern :: (Pattern) ->
               (T_Pattern)
sem_Pattern ((Alias (_pos) (_name) (_pat))) =
    (sem_Pattern_Alias (_pos) (_name) ((sem_Pattern (_pat))))
sem_Pattern ((Constr (_pos) (_name) (_pats))) =
    (sem_Pattern_Constr (_pos) (_name) ((sem_Patterns (_pats))))
sem_Pattern ((Product (_pos) (_pats))) =
    (sem_Pattern_Product (_pos) ((sem_Patterns (_pats))))
sem_Pattern ((Underscore (_pos))) =
    (sem_Pattern_Underscore (_pos))
sem_Pattern ((Var (_pos) (_name))) =
    (sem_Pattern_Var (_pos) (_name))
sem_Pattern_Alias :: (Pos) ->
                     (String) ->
                     (T_Pattern) ->
                     (T_Pattern)
sem_Pattern_Alias (_pos) (_name) (_pat) (_lhs_errors) (_lhs_locVars) =
    let ( _pat_errors,_pat_locVars,_pat_pp) =
            (_pat (_lhs_errors) (_lhs_locVars))
    in  (_pat_errors,_name : _lhs_locVars,locname _name >|< "@" >|< _pat_pp)
sem_Pattern_Constr :: (Pos) ->
                      (String) ->
                      (T_Patterns) ->
                      (T_Pattern)
sem_Pattern_Constr (_pos) (_name) (_pats) (_lhs_errors) (_lhs_locVars) =
    let ( _pats_errors,_pats_locVars,_pats_pps) =
            (_pats (_lhs_errors) (_lhs_locVars))
    in  (_pats_errors,_pats_locVars,pp_parens $ _name >#< hv (map pp_parens _pats_pps))
sem_Pattern_Product :: (Pos) ->
                       (T_Patterns) ->
                       (T_Pattern)
sem_Pattern_Product (_pos) (_pats) (_lhs_errors) (_lhs_locVars) =
    let ( _pats_errors,_pats_locVars,_pats_pps) =
            (_pats (_lhs_errors) (_lhs_locVars))
    in  (_pats_errors,_pats_locVars,pp_block "(" ")" "," _pats_pps)
sem_Pattern_Underscore :: (Pos) ->
                          (T_Pattern)
sem_Pattern_Underscore (_pos) (_lhs_errors) (_lhs_locVars) =
    let 
    in  (_lhs_errors,_lhs_locVars,text "_")
sem_Pattern_Var :: (Pos) ->
                   (String) ->
                   (T_Pattern)
sem_Pattern_Var (_pos) (_name) (_lhs_errors) (_lhs_locVars) =
    let 
    in  (_lhs_errors,_name : _lhs_locVars,text (locname _name))
-- Patterns ----------------------------------------------------
{-
   inherited attributes:

   chained attributes:
      errors               : Errors
      locVars              : [String]

   synthesised attributes:
      pps                  : [PP_Doc]

-}
{-
   local variables for Patterns.Cons:

-}
{-
   local variables for Patterns.Nil:

-}
-- semantic domain
type T_Patterns = (Errors) ->
                  ([String]) ->
                  ((Errors),([String]),([PP_Doc]))
-- cata
sem_Patterns :: (Patterns) ->
                (T_Patterns)
sem_Patterns (list) =
    (foldr (sem_Patterns_Cons) (sem_Patterns_Nil) ((map sem_Pattern list)))
sem_Patterns_Cons :: (T_Pattern) ->
                     (T_Patterns) ->
                     (T_Patterns)
sem_Patterns_Cons (_hd) (_tl) (_lhs_errors) (_lhs_locVars) =
    let ( _hd_errors,_hd_locVars,_hd_pp) =
            (_hd (_tl_errors) (_lhs_locVars))
        ( _tl_errors,_tl_locVars,_tl_pps) =
            (_tl (_lhs_errors) (_hd_locVars))
    in  (_hd_errors,_tl_locVars,_hd_pp : _tl_pps)
sem_Patterns_Nil :: (T_Patterns)
sem_Patterns_Nil (_lhs_errors) (_lhs_locVars) =
    let 
    in  (_lhs_errors,_lhs_locVars,[])
-- Production --------------------------------------------------
{-
   inherited attributes:
      nts'                 : [String]
      o_cata               : Bool
      o_data               : Bool
      o_pretty             : Bool
      o_rename             : Bool
      o_sem                : Bool
      o_sig                : Bool
      typeSyns             : [(String,String)]

   chained attributes:
      errors               : Errors
      nts                  : [String]

   synthesised attributes:
      decls                : Decls

-}
{-
   local variables for Production.Production:
      comment
      cataFun
      semDom
      dataDef

-}
-- semantic domain
type T_Production = (Errors) ->
                    ([String]) ->
                    ([String]) ->
                    (Bool) ->
                    (Bool) ->
                    (Bool) ->
                    (Bool) ->
                    (Bool) ->
                    (Bool) ->
                    ([(String,String)]) ->
                    ((Decls),(Errors),([String]))
-- cata
sem_Production :: (Production) ->
                  (T_Production)
sem_Production ((Production (_nt) (_inh) (_syn) (_alts))) =
    (sem_Production_Production (_nt) (_inh) (_syn) ((sem_Alternatives (_alts))))
sem_Production_Production :: (String) ->
                             (Attributes) ->
                             (Attributes) ->
                             (T_Alternatives) ->
                             (T_Production)
sem_Production_Production (_nt) (_inh) (_syn) (_alts) (_lhs_errors) (_lhs_nts) (_lhs_nts') (_lhs_o_cata) (_lhs_o_data) (_lhs_o_pretty) (_lhs_o_rename) (_lhs_o_sem) (_lhs_o_sig) (_lhs_typeSyns) =
    let (_dataDef) =
            let typeSyn tp = Type _nt (List $ SimpleType tp)
                dataDef    = Data _nt _alts_dataAlts
            in maybe dataDef typeSyn $ lookup _nt _lhs_typeSyns
        (_semDom) =
            let tp = foldr Arr synTps inhTps
                synTps = TupleType $ map SimpleType ( getValues _syn)
                inhTps = map SimpleType (getValues _inh )
            in [ Comment "semantic domain"
               , Type (sdtype _nt) tp
               ]
        (_cataFun) =
            let tSig = TSig (cataname _nt)
                            (SimpleType _nt `Arr` SimpleType (sdtype _nt))
                listCata = \tp -> let  cons = SimpleExpr (semname _nt "Cons")
                                       nil  = SimpleExpr (semname _nt "Nil" )
                                       arg  = SimpleExpr "list"
                                       rarg = if tp `elem` _lhs_nts'
                                                then SimpleExpr ("(map " ++ (cataname tp) ++ " list)")
                                                else arg
                                       lhs = Fun (cataname _nt) [arg]
                                       rhs = (App "foldr" [cons,nil,rarg])
                                   in [Decl lhs rhs]
            in  Comment "cata" :
                (if _lhs_o_sig then [tSig] else []) ++
                maybe _alts_cataAlts listCata (lookup _nt _lhs_typeSyns)
        (_comment) =
            let syn'     = map2list _syn
                inh'     = map2list _inh
                chnn     = inh' `intersect` syn'
                inhn     = inh' \\ chnn
                synn     = syn' \\ chnn
            in Comment . unlines $
               [ replicate 3 ' ' ++ "inherited attributes:"
               , unlines . map ((replicate 6 ' ')++) .
                     map (\(x,y) -> x ++ replicate ((20 - length x) `max` 0) ' ' ++ " : " ++ y) $ inhn
               , replicate 3 ' ' ++ "chained attributes:"
               , unlines . map ((replicate 6 ' ')++) .
                     map (\(x,y) -> x ++ replicate ((20 - length x) `max` 0) ' ' ++ " : " ++ y) $ chnn
               , replicate 3 ' ' ++ "synthesised attributes:"
               , unlines . map ((replicate 6 ' ')++) .
                     map (\(x,y) -> x ++ replicate ((20 - length x) `max` 0) ' ' ++ " : " ++ y) $ synn
               ]
        ( _alts_cataAlts,_alts_comments,_alts_dataAlts,_alts_errors,_alts_semFuns) =
            (_alts (_lhs_errors) (getKeys _inh) (_nt) (_lhs_nts') (_lhs_o_cata) (_lhs_o_pretty) (_lhs_o_rename) (_lhs_o_sem) (_lhs_o_sig) (getKeys _syn))
    in  (Comment (_nt ++ " " ++ replicate (60 - length _nt) '-') :
         (if _lhs_o_pretty then _comment     : _alts_comments else []) ++
         (if _lhs_o_data then [_dataDef    ] else []) ++
         (if _lhs_o_sig  then _semDom      else []) ++
         (if _lhs_o_cata then _cataFun     else []) ++
         (if _lhs_o_sem  then _alts_semFuns else [])
        ,_alts_errors
        ,_nt : _lhs_nts
        )
-- Productions -------------------------------------------------
{-
   inherited attributes:
      nts'                 : [String]
      o_cata               : Bool
      o_data               : Bool
      o_pretty             : Bool
      o_rename             : Bool
      o_sem                : Bool
      o_sig                : Bool
      typeSyns             : [(String,String)]

   chained attributes:
      errors               : Errors
      nts                  : [String]

   synthesised attributes:
      decls                : Decls

-}
{-
   local variables for Productions.Cons:

-}
{-
   local variables for Productions.Nil:

-}
-- semantic domain
type T_Productions = (Errors) ->
                     ([String]) ->
                     ([String]) ->
                     (Bool) ->
                     (Bool) ->
                     (Bool) ->
                     (Bool) ->
                     (Bool) ->
                     (Bool) ->
                     ([(String,String)]) ->
                     ((Decls),(Errors),([String]))
-- cata
sem_Productions :: (Productions) ->
                   (T_Productions)
sem_Productions (list) =
    (foldr (sem_Productions_Cons) (sem_Productions_Nil) ((map sem_Production list)))
sem_Productions_Cons :: (T_Production) ->
                        (T_Productions) ->
                        (T_Productions)
sem_Productions_Cons (_hd) (_tl) (_lhs_errors) (_lhs_nts) (_lhs_nts') (_lhs_o_cata) (_lhs_o_data) (_lhs_o_pretty) (_lhs_o_rename) (_lhs_o_sem) (_lhs_o_sig) (_lhs_typeSyns) =
    let ( _hd_decls,_hd_errors,_hd_nts) =
            (_hd (_tl_errors) (_lhs_nts) (_lhs_nts') (_lhs_o_cata) (_lhs_o_data) (_lhs_o_pretty) (_lhs_o_rename) (_lhs_o_sem) (_lhs_o_sig) (_lhs_typeSyns))
        ( _tl_decls,_tl_errors,_tl_nts) =
            (_tl (_lhs_errors) (_hd_nts) (_lhs_nts') (_lhs_o_cata) (_lhs_o_data) (_lhs_o_pretty) (_lhs_o_rename) (_lhs_o_sem) (_lhs_o_sig) (_lhs_typeSyns))
    in  (_hd_decls ++ _tl_decls,_hd_errors,_tl_nts)
sem_Productions_Nil :: (T_Productions)
sem_Productions_Nil (_lhs_errors) (_lhs_nts) (_lhs_nts') (_lhs_o_cata) (_lhs_o_data) (_lhs_o_pretty) (_lhs_o_rename) (_lhs_o_sem) (_lhs_o_sig) (_lhs_typeSyns) =
    let 
    in  ([],_lhs_errors,_lhs_nts)
-- Rule --------------------------------------------------------
{-
   inherited attributes:
      attrs                : [(String,String)]
      con                  : String
      locals               : [String]
      nt                   : String

   chained attributes:
      errors               : Errors
      rMap                 : Map Name Expr

   synthesised attributes:

-}
{-
   local variables for Rule.Rule:

-}
-- semantic domain
type T_Rule = ([(String,String)]) ->
              (String) ->
              (Errors) ->
              ([String]) ->
              (String) ->
              (Map Name Expr) ->
              ((Errors),(Map Name Expr))
-- cata
sem_Rule :: (Rule) ->
            (T_Rule)
sem_Rule ((Rule (_attr) (_rhs))) =
    (sem_Rule_Rule (_attr) ((sem_Expression (_rhs))))
sem_Rule_Rule :: (Name) ->
                 (T_Expression) ->
                 (T_Rule)
sem_Rule_Rule (_attr) (_rhs) (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_locals) (_lhs_nt) (_lhs_rMap) =
    let ( _rhs_errors,_rhs_pp,_rhs_usedAttrs,_rhs_usedLocals) =
            (_rhs (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_locals) (_lhs_nt))
    in  (_rhs_errors,insert _attr (PP _rhs_pp) _lhs_rMap)
-- Rules -------------------------------------------------------
{-
   inherited attributes:
      attrs                : [(String,String)]
      con                  : String
      locals               : [String]
      nt                   : String

   chained attributes:
      errors               : Errors

   synthesised attributes:
      rMap                 : Map Name Expr

-}
{-
   local variables for Rules.Cons:

-}
{-
   local variables for Rules.Nil:

-}
-- semantic domain
type T_Rules = ([(String,String)]) ->
               (String) ->
               (Errors) ->
               ([String]) ->
               (String) ->
               ((Errors),(Map Name Expr))
-- cata
sem_Rules :: (Rules) ->
             (T_Rules)
sem_Rules (list) =
    (foldr (sem_Rules_Cons) (sem_Rules_Nil) ((map sem_Rule list)))
sem_Rules_Cons :: (T_Rule) ->
                  (T_Rules) ->
                  (T_Rules)
sem_Rules_Cons (_hd) (_tl) (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_locals) (_lhs_nt) =
    let ( _hd_errors,_hd_rMap) =
            (_hd (_lhs_attrs) (_lhs_con) (_tl_errors) (_lhs_locals) (_lhs_nt) (_tl_rMap))
        ( _tl_errors,_tl_rMap) =
            (_tl (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_locals) (_lhs_nt))
    in  (_hd_errors,_hd_rMap)
sem_Rules_Nil :: (T_Rules)
sem_Rules_Nil (_lhs_attrs) (_lhs_con) (_lhs_errors) (_lhs_locals) (_lhs_nt) =
    let 
    in  (_lhs_errors,emptyMap)

