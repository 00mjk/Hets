{- UU_AG
 - Copyright:  S. Doaitse Swierstra, Arthur I. Baars and Andres Loeh
               Department of Computer Science
               Utrecht University
               P.O. Box 80.089
               3508 TB UTRECHT
               the Netherlands
               {swierstra,arthurb,andres}@cs.uu.nl -}
INCLUDE "Expression.ag"

imports
{
import UU_Pretty(PP_Doc)
import Expression
import HsTokenScanner(lexTokens)
import SemHsTokens(sem_HsTokensRoot)
import ErrorMessages
import TokenDef
import CommonTypes
import HsToken
}

ATTR Expression [ nt,con   :{String}
                  locals   :{[String]}
                  attrs    :{[(String,String)]}
                | errors   :{Errors}
                | usedLocals:{[String]}
                  usedAttrs :{[(String,String)]}
                  pp       :{PP_Doc}
                ]

SEM Expression
  | Expression loc.(errors,pp,usedAttrs,usedLocals)
                 = let p | line @pos < 1 = Pos "" 1 1
                         | otherwise     = @pos
                   in sem_HsTokensRoot (HsTokensRoot $ lexTokens @pos @txt) @lhs.attrs @lhs.con @lhs.errors @lhs.locals @lhs.nt

{-
tokenize         = normalizeCode
sem_HsTokensRoot = \tokens _ es -> (es,tokens,([],[]))

normalizeCode :: Pos -> String -> PP_Doc
normalizeCode pos txt   = foldr (>-<) empty
                        . cutSpaces
                        . map removeTabs
                        . filter (not.allSpace)
                        . addspaces
                        . lines
                        . changeVars
                        . changeBraces
                        $ txt
    where allSpace = and . map isSpace
          addspaces []     = []
          addspaces (x:xs) = (repSpaces (column pos -1) ++ x) : xs
          cutSpaces xs     = let n = minimum (map (length . takeWhile (' '==)) xs)
                             in map (drop n) xs
          removeTabs xs    = foldr handleTab (const "") xs 1
          handleTab x r    = \col -> case x of
                                      '\t' -> let w= 8 - ((col-1) `mod` 8)
                                              in replicate w ' ' ++  r (col+w)
                                      _    -> x : (col `seq` r (col+1))
          repSpaces n | n <= 0 = ""
                      | otherwise = replicate n ' '

changeBraces []           = []
changeBraces ('{':'{':xs) = '{' : changeBraces xs
changeBraces ('}':'}':xs) = '}' : changeBraces xs
changeBraces (x:xs)       = x   : changeBraces xs

changeVars []         = []
changeVars ('@':x:xs) | isLower x = let isIdChar c =  isAlphaNum c
                                                   || c == '\''
                                                   || c == '_'
                                        (fld,rest1) = span isIdChar xs
                                        field = x:fld
                                        (attr,rest2) = getAttr rest1
                                        getAttr ('.':r:rs) | isLower r =
                                                   let (at,rest) = span isIdChar rs
                                                       attr = r:at
                                                   in (attr,rest)
                                        getAttr rs         = ("",rs)
                                        result | field == "loc" = '_':attr++ "    "
                                               | null attr      = '_':field
                                               | otherwise      = '_':field++('_':attr)
                                    in result ++ changeVars rest2
changeVars (x:xs)     = x : changeVars xs
-}
