-- do not edit; automatically generated by UU_AG
module DefaultRules where

import AbstractSyntax
import CommonTypes
import Patterns
import UU_Maps
import UU_Utils
import List (deleteBy,partition)
import UU_Pretty
import Maybe
import ErrorMessages
import UU_Pretty_ext
import Expression
import TokenDef(Pos,noPos)

import CommonTypes
import UU_Pretty
import UU_Maps
import Patterns
import Expression

import TokenDef(Pos)

attrName fld attr = '_':fld++ "_" ++ attr
locName n         = '_':n

prodRules :: String -> String -> String -> [String] -> Environment
          -> (Rules,Errors) -> String -> (Rules,Errors)
prodRules nt con field locals env (rs,err) n =
        let
            (rhs,err') = if n `elem` locals
                            then (Expression noPos $ locName n,err)
                            else maybe undef prhs $ locateMap n env
            prhs t = (case t of
                          ""    -> Expression noPos $ locName n
                          _     -> Expression noPos $ attrName t n
                     ,err)
            undef = (Expression noPos $ "undefined", MissingRule nt con field n:err)
            nr  = Rule n rhs
        in
            (nr : rs ,err')
prodUseRule useMap uses attr =
   let (op,e) = fromMaybe ("","") $ locateMap attr useMap
       chs = fromMaybe [] $ locateMap attr uses
       rhs = case chs of
              [] -> e
              _  -> foldr1 (\e es -> unwords [e, op, es])
                           (map (\fld -> attrName fld attr) chs)
   in Rule attr (Expression noPos rhs)


type Environment = Map String String
type Uses = Map Name [Name]
-- Alternative -------------------------------------------------
{-
   inherited attributes:
      inh                  : [String]
      nt                   : String
      syn                  : [String]
      useMap               : (Map Name (String,String))

   chained attributes:
      errors               : Errors

   synthesised attributes:
      out                  : Alternative

-}
{-
   local variables for Alternative.Alternative:
      newRls
      errs
      rules2
      mAttr
      uAttr

-}
-- semantic domain
type T_Alternative = (Errors) ->
                     ([String]) ->
                     (String) ->
                     ([String]) ->
                     ((Map Name (String,String))) ->
                     ((Errors),(Alternative))
-- cata
sem_Alternative :: (Alternative) ->
                   (T_Alternative)
sem_Alternative ((Alternative (_con) (_children) (_rules) (_locrules))) =
    (sem_Alternative_Alternative (_con) ((sem_Children (_children))) ((sem_Rules (_rules))) ((sem_LocRules (_locrules))))
sem_Alternative_Alternative :: (String) ->
                               (T_Children) ->
                               (T_Rules) ->
                               (T_LocRules) ->
                               (T_Alternative)
sem_Alternative_Alternative (_con) (_children) (_rules) (_locrules) (_lhs_errors) (_lhs_inh) (_lhs_nt) (_lhs_syn) (_lhs_useMap) =
    let ((_uAttr,_mAttr)) =
            partition (`contains` _lhs_useMap) _rules_mat
        ((_rules2,_errs)) =
            foldl (prodRules _lhs_nt _con  _LHS _locrules_locVars _children_env)
                  (_rules_out,_children_errors) _mAttr
        (_newRls) =
            map (prodUseRule _lhs_useMap _children_uses)  _uAttr     ++ _rules2
        ( _children_env,_children_errors,_children_names,_children_out,_children_uses) =
            (_children (_con)
                       (list2map  (map (\nm -> (nm,"lhs")) _lhs_inh ++
                                   map (\nm -> (nm,""   )) _children_names
                                  ))
                       (_rules_errors)
                       (_locrules_locVars)
                       (_lhs_nt)
                       (_uAttr))
        ( _rules_errors,_rules_mat,_rules_out) =
            (_rules (_con) (_locrules_errors) (_lhs_syn) (_lhs_nt))
        ( _locrules_errors,_locrules_locVars,_locrules_out,_locrules_overwritten) =
            (_locrules (_con) (_lhs_errors) ([]) (_lhs_nt))
    in  (_errs,Alternative _con _children_out _newRls _locrules_out)
-- Alternatives ------------------------------------------------
{-
   inherited attributes:
      inh                  : [String]
      nt                   : String
      syn                  : [String]
      useMap               : (Map Name (String,String))

   chained attributes:
      errors               : Errors

   synthesised attributes:
      out                  : Alternatives

-}
{-
   local variables for Alternatives.Cons:

-}
{-
   local variables for Alternatives.Nil:

-}
-- semantic domain
type T_Alternatives = (Errors) ->
                      ([String]) ->
                      (String) ->
                      ([String]) ->
                      ((Map Name (String,String))) ->
                      ((Errors),(Alternatives))
-- cata
sem_Alternatives :: (Alternatives) ->
                    (T_Alternatives)
sem_Alternatives (list) =
    (foldr (sem_Alternatives_Cons) (sem_Alternatives_Nil) ((map sem_Alternative list)))
sem_Alternatives_Cons :: (T_Alternative) ->
                         (T_Alternatives) ->
                         (T_Alternatives)
sem_Alternatives_Cons (_hd) (_tl) (_lhs_errors) (_lhs_inh) (_lhs_nt) (_lhs_syn) (_lhs_useMap) =
    let ( _hd_errors,_hd_out) =
            (_hd (_tl_errors) (_lhs_inh) (_lhs_nt) (_lhs_syn) (_lhs_useMap))
        ( _tl_errors,_tl_out) =
            (_tl (_lhs_errors) (_lhs_inh) (_lhs_nt) (_lhs_syn) (_lhs_useMap))
    in  (_hd_errors,_hd_out : _tl_out)
sem_Alternatives_Nil :: (T_Alternatives)
sem_Alternatives_Nil (_lhs_errors) (_lhs_inh) (_lhs_nt) (_lhs_syn) (_lhs_useMap) =
    let 
    in  (_lhs_errors,[])
-- Child -------------------------------------------------------
{-
   inherited attributes:
      con                  : String
      locVars              : [String]
      nt                   : String
      useAttrs             : [Name]

   chained attributes:
      env                  : Environment
      errors               : Errors
      uses                 : Uses

   synthesised attributes:
      names                : [String]
      out                  : Child

-}
{-
   local variables for Child.Child:
      errs
      newRls

-}
-- semantic domain
type T_Child = (String) ->
               (Environment) ->
               (Errors) ->
               ([String]) ->
               (String) ->
               ([Name]) ->
               (Uses) ->
               ((Environment),(Errors),([String]),(Child),(Uses))
-- cata
sem_Child :: (Child) ->
             (T_Child)
sem_Child ((Child (_name) (_tp) (_inh) (_syn) (_rules))) =
    (sem_Child_Child (_name) (_tp) (_inh) (_syn) ((sem_Rules (_rules))))
sem_Child_Child :: (String) ->
                   (String) ->
                   (Attributes) ->
                   (Attributes) ->
                   (T_Rules) ->
                   (T_Child)
sem_Child_Child (_name) (_tp) (_inh) (_syn) (_rules) (_lhs_con) (_lhs_env) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_useAttrs) (_lhs_uses) =
    let ((_newRls,_errs)) =
            foldl (prodRules _lhs_nt _lhs_con  _name _lhs_locVars _lhs_env)
                  (_rules_out,_lhs_errors)  _rules_mat
        ( _rules_errors,_rules_mat,_rules_out) =
            (_rules (_lhs_con) (_lhs_errors) (getKeys _inh) (_lhs_nt))
    in  (foldr (\attr -> insert attr _name) _lhs_env (getKeys _syn)
        ,_errs
        ,[_name]
        ,Child _name _tp _inh _syn _newRls
        ,foldr (\attr us -> if attr `elem` _lhs_useAttrs
                           then insertComb (++) attr [_name] us
                           else us
               ) _lhs_uses (getKeys _syn)
        )
-- Children ----------------------------------------------------
{-
   inherited attributes:
      con                  : String
      locVars              : [String]
      nt                   : String
      useAttrs             : [Name]

   chained attributes:
      env                  : Environment
      errors               : Errors

   synthesised attributes:
      names                : [String]
      out                  : Children
      uses                 : Uses

-}
{-
   local variables for Children.Cons:

-}
{-
   local variables for Children.Nil:

-}
-- semantic domain
type T_Children = (String) ->
                  (Environment) ->
                  (Errors) ->
                  ([String]) ->
                  (String) ->
                  ([Name]) ->
                  ((Environment),(Errors),([String]),(Children),(Uses))
-- cata
sem_Children :: (Children) ->
                (T_Children)
sem_Children (list) =
    (foldr (sem_Children_Cons) (sem_Children_Nil) ((map sem_Child list)))
sem_Children_Cons :: (T_Child) ->
                     (T_Children) ->
                     (T_Children)
sem_Children_Cons (_hd) (_tl) (_lhs_con) (_lhs_env) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_useAttrs) =
    let ( _hd_env,_hd_errors,_hd_names,_hd_out,_hd_uses) =
            (_hd (_lhs_con) (_lhs_env) (_tl_errors) (_lhs_locVars) (_lhs_nt) (_lhs_useAttrs) (_tl_uses))
        ( _tl_env,_tl_errors,_tl_names,_tl_out,_tl_uses) =
            (_tl (_lhs_con) (_hd_env) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_useAttrs))
    in  (_tl_env,_hd_errors,_hd_names ++ _tl_names,_hd_out : _tl_out,_hd_uses)
sem_Children_Nil :: (T_Children)
sem_Children_Nil (_lhs_con) (_lhs_env) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_useAttrs) =
    let 
    in  (_lhs_env,_lhs_errors,[],[],emptyMap)
-- Grammar -----------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      errors               : Errors
      out                  : Grammar

-}
{-
   local variables for Grammar.Grammar:

-}
-- semantic domain
type T_Grammar = ((Errors),(Grammar))
-- cata
sem_Grammar :: (Grammar) ->
               (T_Grammar)
sem_Grammar ((Grammar (_typeSyns) (_useMap) (_prods))) =
    (sem_Grammar_Grammar (_typeSyns) (_useMap) ((sem_Productions (_prods))))
sem_Grammar_Grammar :: (TypeSyns) ->
                       (UseMap) ->
                       (T_Productions) ->
                       (T_Grammar)
sem_Grammar_Grammar (_typeSyns) (_useMap) (_prods) =
    let ( _prods_errors,_prods_out) =
            (_prods ([]) (_useMap))
    in  (_prods_errors,Grammar _typeSyns _useMap _prods_out)
-- LocRule -----------------------------------------------------
{-
   inherited attributes:
      con                  : String
      nt                   : String

   chained attributes:
      errors               : Errors
      locVars              : [String]
      overwritten          : [String]

   synthesised attributes:
      containsVars         : Bool
      out                  : LocRule

-}
{-
   local variables for LocRule.LocRule:

-}
-- semantic domain
type T_LocRule = (String) ->
                 (Errors) ->
                 ([String]) ->
                 (String) ->
                 ([String]) ->
                 ((Bool),(Errors),([String]),(LocRule),([String]))
-- cata
sem_LocRule :: (LocRule) ->
               (T_LocRule)
sem_LocRule ((LocRule (_pat) (_rhs) (_owrt))) =
    (sem_LocRule_LocRule ((sem_Pattern (_pat))) (_rhs) (_owrt))
sem_LocRule_LocRule :: (T_Pattern) ->
                       (Expression) ->
                       (Bool) ->
                       (T_LocRule)
sem_LocRule_LocRule (_pat) (_rhs) (_owrt) (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_overwritten) =
    let ( _pat_containsVars,_pat_errors,_pat_locVars,_pat_out,_pat_overwritten) =
            (_pat (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_overwritten) (_owrt))
    in  (_pat_containsVars,_pat_errors,_pat_locVars,LocRule _pat_out _rhs _owrt,_pat_overwritten)
-- LocRules ----------------------------------------------------
{-
   inherited attributes:
      con                  : String
      nt                   : String

   chained attributes:
      errors               : Errors
      locVars              : [String]

   synthesised attributes:
      out                  : LocRules
      overwritten          : [String]

-}
{-
   local variables for LocRules.Cons:

-}
{-
   local variables for LocRules.Nil:

-}
-- semantic domain
type T_LocRules = (String) ->
                  (Errors) ->
                  ([String]) ->
                  (String) ->
                  ((Errors),([String]),(LocRules),([String]))
-- cata
sem_LocRules :: (LocRules) ->
                (T_LocRules)
sem_LocRules (list) =
    (foldr (sem_LocRules_Cons) (sem_LocRules_Nil) ((map sem_LocRule list)))
sem_LocRules_Cons :: (T_LocRule) ->
                     (T_LocRules) ->
                     (T_LocRules)
sem_LocRules_Cons (_hd) (_tl) (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_nt) =
    let ( _hd_containsVars,_hd_errors,_hd_locVars,_hd_out,_hd_overwritten) =
            (_hd (_lhs_con) (_tl_errors) (_lhs_locVars) (_lhs_nt) (_tl_overwritten))
        ( _tl_errors,_tl_locVars,_tl_out,_tl_overwritten) =
            (_tl (_lhs_con) (_lhs_errors) (_hd_locVars) (_lhs_nt))
    in  (_hd_errors
        ,_tl_locVars
        ,if _hd_containsVars
            then _hd_out : _tl_out
            else _tl_out
        ,_hd_overwritten
        )
sem_LocRules_Nil :: (T_LocRules)
sem_LocRules_Nil (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_nt) =
    let 
    in  (_lhs_errors,_lhs_locVars,[],[])
-- Pattern -----------------------------------------------------
{-
   inherited attributes:
      con                  : String
      nt                   : String
      owrt                 : Bool

   chained attributes:
      errors               : Errors
      locVars              : [String]
      overwritten          : [String]

   synthesised attributes:
      containsVars         : Bool
      out                  : Pattern

-}
{-
   local variables for Pattern.Alias:
      es
      lv

-}
{-
   local variables for Pattern.Constr:

-}
{-
   local variables for Pattern.Product:

-}
{-
   local variables for Pattern.Underscore:

-}
{-
   local variables for Pattern.Var:
      es
      lv

-}
-- semantic domain
type T_Pattern = (String) ->
                 (Errors) ->
                 ([String]) ->
                 (String) ->
                 ([String]) ->
                 (Bool) ->
                 ((Bool),(Errors),([String]),(Pattern),([String]))
-- cata
sem_Pattern :: (Pattern) ->
               (T_Pattern)
sem_Pattern ((Alias (_pos) (_name) (_pat))) =
    (sem_Pattern_Alias (_pos) (_name) ((sem_Pattern (_pat))))
sem_Pattern ((Constr (_pos) (_name) (_pats))) =
    (sem_Pattern_Constr (_pos) (_name) ((sem_Patterns (_pats))))
sem_Pattern ((Product (_pos) (_pats))) =
    (sem_Pattern_Product (_pos) ((sem_Patterns (_pats))))
sem_Pattern ((Underscore (_pos))) =
    (sem_Pattern_Underscore (_pos))
sem_Pattern ((Var (_pos) (_name))) =
    (sem_Pattern_Var (_pos) (_name))
sem_Pattern_Alias :: (Pos) ->
                     (String) ->
                     (T_Pattern) ->
                     (T_Pattern)
sem_Pattern_Alias (_pos) (_name) (_pat) (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_overwritten) (_lhs_owrt) =
    let ((_lv,_es)) =
            if _name `elem` _lhs_locVars
               then (_lhs_locVars
                    , if _lhs_owrt
                         then _lhs_errors
                         else DupLocal _lhs_nt _lhs_con _name : _pat_errors
                    )
               else (_name : _lhs_locVars, _lhs_errors)
        ( _pat_containsVars,_pat_errors,_pat_locVars,_pat_out,_pat_overwritten) =
            (_pat (_lhs_con) (_lhs_errors) (_lv) (_lhs_nt) (_lhs_overwritten) (_lhs_owrt))
    in  (not (_name `elem` _lhs_overwritten)
        ,_es
        ,_pat_locVars
        ,if _name `elem` _lhs_overwritten
            then _pat_out
            else Alias _pos _name _pat_out
        ,if _lhs_owrt
            then _name : _pat_overwritten
            else _pat_overwritten
        )
sem_Pattern_Constr :: (Pos) ->
                      (String) ->
                      (T_Patterns) ->
                      (T_Pattern)
sem_Pattern_Constr (_pos) (_name) (_pats) (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_overwritten) (_lhs_owrt) =
    let ( _pats_containsVars,_pats_errors,_pats_locVars,_pats_out,_pats_overwritten) =
            (_pats (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_owrt))
    in  (_pats_containsVars,_pats_errors,_pats_locVars,Constr _pos _name _pats_out,_pats_overwritten)
sem_Pattern_Product :: (Pos) ->
                       (T_Patterns) ->
                       (T_Pattern)
sem_Pattern_Product (_pos) (_pats) (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_overwritten) (_lhs_owrt) =
    let ( _pats_containsVars,_pats_errors,_pats_locVars,_pats_out,_pats_overwritten) =
            (_pats (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_owrt))
    in  (_pats_containsVars,_pats_errors,_pats_locVars,Product _pos _pats_out,_pats_overwritten)
sem_Pattern_Underscore :: (Pos) ->
                          (T_Pattern)
sem_Pattern_Underscore (_pos) (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_overwritten) (_lhs_owrt) =
    let 
    in  (False,_lhs_errors,_lhs_locVars,Underscore _pos,_lhs_overwritten)
sem_Pattern_Var :: (Pos) ->
                   (String) ->
                   (T_Pattern)
sem_Pattern_Var (_pos) (_name) (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_overwritten) (_lhs_owrt) =
    let ((_lv,_es)) =
            if _name `elem` _lhs_locVars
                then (_lhs_locVars
                     , if _lhs_owrt
                          then _lhs_errors
                          else DupLocal _lhs_nt _lhs_con _name : _lhs_errors
                     )
                else (_name : _lhs_locVars, _lhs_errors)
    in  (not (_name `elem` _lhs_overwritten)
        ,_es
        ,_lv
        ,if _name `elem` _lhs_overwritten
            then Underscore _pos
            else Var _pos _name
        ,if _lhs_owrt
            then _name : _lhs_overwritten
            else _lhs_overwritten
        )
-- Patterns ----------------------------------------------------
{-
   inherited attributes:
      con                  : String
      nt                   : String
      owrt                 : Bool

   chained attributes:
      errors               : Errors
      locVars              : [String]

   synthesised attributes:
      containsVars         : Bool
      out                  : Patterns
      overwritten          : [String]

-}
{-
   local variables for Patterns.Cons:

-}
{-
   local variables for Patterns.Nil:

-}
-- semantic domain
type T_Patterns = (String) ->
                  (Errors) ->
                  ([String]) ->
                  (String) ->
                  (Bool) ->
                  ((Bool),(Errors),([String]),(Patterns),([String]))
-- cata
sem_Patterns :: (Patterns) ->
                (T_Patterns)
sem_Patterns (list) =
    (foldr (sem_Patterns_Cons) (sem_Patterns_Nil) ((map sem_Pattern list)))
sem_Patterns_Cons :: (T_Pattern) ->
                     (T_Patterns) ->
                     (T_Patterns)
sem_Patterns_Cons (_hd) (_tl) (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_owrt) =
    let ( _hd_containsVars,_hd_errors,_hd_locVars,_hd_out,_hd_overwritten) =
            (_hd (_lhs_con) (_tl_errors) (_lhs_locVars) (_lhs_nt) (_tl_overwritten) (_lhs_owrt))
        ( _tl_containsVars,_tl_errors,_tl_locVars,_tl_out,_tl_overwritten) =
            (_tl (_lhs_con) (_lhs_errors) (_hd_locVars) (_lhs_nt) (_lhs_owrt))
    in  (_hd_containsVars || _tl_containsVars,_hd_errors,_tl_locVars,_hd_out : _tl_out,_hd_overwritten)
sem_Patterns_Nil :: (T_Patterns)
sem_Patterns_Nil (_lhs_con) (_lhs_errors) (_lhs_locVars) (_lhs_nt) (_lhs_owrt) =
    let 
    in  (False,_lhs_errors,_lhs_locVars,[],[])
-- Production --------------------------------------------------
{-
   inherited attributes:
      useMap               : UseMap

   chained attributes:
      errors               : Errors

   synthesised attributes:
      out                  : Production

-}
{-
   local variables for Production.Production:

-}
-- semantic domain
type T_Production = (Errors) ->
                    (UseMap) ->
                    ((Errors),(Production))
-- cata
sem_Production :: (Production) ->
                  (T_Production)
sem_Production ((Production (_nt) (_inh) (_syn) (_alts))) =
    (sem_Production_Production (_nt) (_inh) (_syn) ((sem_Alternatives (_alts))))
sem_Production_Production :: (String) ->
                             (Attributes) ->
                             (Attributes) ->
                             (T_Alternatives) ->
                             (T_Production)
sem_Production_Production (_nt) (_inh) (_syn) (_alts) (_lhs_errors) (_lhs_useMap) =
    let ( _alts_errors,_alts_out) =
            (_alts (_lhs_errors) (getKeys _inh) (_nt) (getKeys _syn) (fromMaybe emptyMap (locateMap _nt _lhs_useMap)))
    in  (_alts_errors,Production _nt _inh _syn _alts_out)
-- Productions -------------------------------------------------
{-
   inherited attributes:
      useMap               : UseMap

   chained attributes:
      errors               : Errors

   synthesised attributes:
      out                  : Productions

-}
{-
   local variables for Productions.Cons:

-}
{-
   local variables for Productions.Nil:

-}
-- semantic domain
type T_Productions = (Errors) ->
                     (UseMap) ->
                     ((Errors),(Productions))
-- cata
sem_Productions :: (Productions) ->
                   (T_Productions)
sem_Productions (list) =
    (foldr (sem_Productions_Cons) (sem_Productions_Nil) ((map sem_Production list)))
sem_Productions_Cons :: (T_Production) ->
                        (T_Productions) ->
                        (T_Productions)
sem_Productions_Cons (_hd) (_tl) (_lhs_errors) (_lhs_useMap) =
    let ( _hd_errors,_hd_out) =
            (_hd (_tl_errors) (_lhs_useMap))
        ( _tl_errors,_tl_out) =
            (_tl (_lhs_errors) (_lhs_useMap))
    in  (_hd_errors,_hd_out : _tl_out)
sem_Productions_Nil :: (T_Productions)
sem_Productions_Nil (_lhs_errors) (_lhs_useMap) =
    let 
    in  (_lhs_errors,[])
-- Rule --------------------------------------------------------
{-
   inherited attributes:
      con                  : String
      nt                   : String

   chained attributes:
      errors               : Errors
      mat                  : [String]

   synthesised attributes:
      out                  : Rule

-}
{-
   local variables for Rule.Rule:

-}
-- semantic domain
type T_Rule = (String) ->
              (Errors) ->
              ([String]) ->
              (String) ->
              ((Errors),([String]),(Rule))
-- cata
sem_Rule :: (Rule) ->
            (T_Rule)
sem_Rule ((Rule (_attr) (_rhs))) =
    (sem_Rule_Rule (_attr) (_rhs))
sem_Rule_Rule :: (Name) ->
                 (Expression) ->
                 (T_Rule)
sem_Rule_Rule (_attr) (_rhs) (_lhs_con) (_lhs_errors) (_lhs_mat) (_lhs_nt) =
    let 
    in  (_lhs_errors,filter ( /= _attr) _lhs_mat,Rule _attr _rhs)
-- Rules -------------------------------------------------------
{-
   inherited attributes:
      con                  : String
      nt                   : String

   chained attributes:
      errors               : Errors
      mat                  : [String]

   synthesised attributes:
      out                  : Rules

-}
{-
   local variables for Rules.Cons:

-}
{-
   local variables for Rules.Nil:

-}
-- semantic domain
type T_Rules = (String) ->
               (Errors) ->
               ([String]) ->
               (String) ->
               ((Errors),([String]),(Rules))
-- cata
sem_Rules :: (Rules) ->
             (T_Rules)
sem_Rules (list) =
    (foldr (sem_Rules_Cons) (sem_Rules_Nil) ((map sem_Rule list)))
sem_Rules_Cons :: (T_Rule) ->
                  (T_Rules) ->
                  (T_Rules)
sem_Rules_Cons (_hd) (_tl) (_lhs_con) (_lhs_errors) (_lhs_mat) (_lhs_nt) =
    let ( _hd_errors,_hd_mat,_hd_out) =
            (_hd (_lhs_con) (_tl_errors) (_lhs_mat) (_lhs_nt))
        ( _tl_errors,_tl_mat,_tl_out) =
            (_tl (_lhs_con) (_lhs_errors) (_hd_mat) (_lhs_nt))
    in  (_hd_errors,_tl_mat,_hd_out : _tl_out)
sem_Rules_Nil :: (T_Rules)
sem_Rules_Nil (_lhs_con) (_lhs_errors) (_lhs_mat) (_lhs_nt) =
    let 
    in  (_lhs_errors,_lhs_mat,[])

