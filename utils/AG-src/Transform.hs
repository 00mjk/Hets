-- do not edit; automatically generated by UU_AG
module Transform where

import UU_Maps
import UU_Utils
import UU_Pretty

import ConcreteSyntax
import AbstractSyntax
import Patterns
import ErrorMessages
import List (partition)
import Maybe
import IOExts

import CommonTypes
import Patterns
import UU_Pretty
import TokenDef(Pos)
import Expression

import TokenDef(Pos)

addRule pos field attr rhs tp getAttrs attrMap owrt nt con rulesMap errors
  | contains attr (maybe emptyMap getAttrs (locateMap tp attrMap))
        = let (rules,lrs) = rulesMap
              rs          = fromMaybe emptyMap (locateMap field rules)
          in case locateMap attr rs of
              Just (p,_) -> if owrt
                               then (errors
                                    ,(insert field (insert attr (pos,rhs) rs) rules,lrs)
                                    )
                               else (DupRule p pos nt con field attr : errors
                                    , rulesMap
                                    )
              Nothing    -> (errors
                            ,(insert field (insert attr (pos,rhs) rs) rules,lrs)
                            )
  | otherwise = (SuperfluousRule pos nt con field attr : errors
                ,rulesMap
                )

--      name clash
nameClashError pos nt con es var fields =
        case var `lookup`  fields of
          Just (p,_) ->  NameClash p pos nt con var  : es
          Nothing    ->  es

constructGrammar gram attrs uses rules tsyns =
   let gr = map (\(nt,(p,alts)) -> (nt, (p, map2list alts))) (map2list gram)
       stripPos = fmap snd
       prods = map prod gr
       prod (nt,(_,alts))=  let (pinh,psyn) = fromMaybe (emptyMap,emptyMap) $ locateMap nt attrs
                                inh = stripPos pinh
                                syn = stripPos psyn
                                rmap  = fromMaybe emptyMap (locateMap nt rules)
                                alt (con,(_,flds)) =
                                   let (rmap',lrs) = fromMaybe (emptyMap,[]) (locateMap con rmap)
                                       locrs = reverse lrs -- order is reversed,so reverse again
                                       rs  = fromMaybe emptyMap (locateMap _LHS rmap')
                                       rules = map rule (map2list rs)
                                       rule (attr,(_,rhs)) = Rule attr rhs
                                       child (nm,(_,tp)) =
                                          let (pinh,psyn) = fromMaybe (emptyMap,emptyMap) $ locateMap tp attrs
                                              inh = stripPos pinh
                                              syn = stripPos psyn
                                              rs  = fromMaybe emptyMap (locateMap nm rmap')
                                              rules = map rule (map2list rs)
                                          in Child nm tp inh syn rules
                                   in Alternative con (map child flds) rules locrs
                            in Production nt inh syn (map alt alts)
   in Grammar tsyns uses prods
 

type Blocks  = Map Name [String]

type Gram     = Map Nonterminal (Pos, AltMap)
type AltMap   = Map Constructor (Pos, FieldMap)
type FieldMap = [(Name, (Pos,String))]

type AtMap  = Map Nonterminal (Map Name (Pos,String),Map Name (Pos,String))
--type UseMap = Map Nonterminal (Map Name (String,String))

type RulesMap    = Map Nonterminal RulesMap2
type RulesMap2   = Map Constructor RulesMap3
type RulesMap3   = (Map Name RulesMap4,LocRules)
type RulesMap4   = Map Name (Pos,Expression)
-- AG ----------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      blocks               : Blocks
      errors               : Errors
      trans                : Grammar

-}
{-
   local variables for AG.AG:

-}
-- semantic domain
type T_AG = ((Blocks),(Errors),(Grammar))
-- cata
sem_AG :: (AG) ->
          (T_AG)
sem_AG ((AG (_elems))) =
    (sem_AG_AG ((sem_Elems (_elems))))
sem_AG_AG :: (T_Elems) ->
             (T_AG)
sem_AG_AG (_elems) =
    let ( _elems_atMap,_elems_blocks,_elems_errors,_elems_gram,_elems_rulesMap,_elems_typeSyns,_elems_uses) =
            (_elems (emptyMap) (_elems_atMap) ([]) (emptyMap) (_elems_gram) (emptyMap) ([]) (emptyMap))
    in  (_elems_blocks,_elems_errors,constructGrammar _elems_gram _elems_atMap _elems_uses _elems_rulesMap _elems_typeSyns)
-- Alt ---------------------------------------------------------
{-
   inherited attributes:
      nt                   : Nonterminal

   chained attributes:
      altMap               : AltMap
      errors               : Errors

   synthesised attributes:

-}
{-
   local variables for Alt.Alt:
      aMap
      errs

-}
-- semantic domain
type T_Alt = (AltMap) ->
             (Errors) ->
             (Nonterminal) ->
             ((AltMap),(Errors))
-- cata
sem_Alt :: (Alt) ->
           (T_Alt)
sem_Alt ((Alt (_pos) (_name) (_fields))) =
    (sem_Alt_Alt (_pos) (_name) (_fields))
sem_Alt_Alt :: (Pos) ->
               (Constructor) ->
               (Fields) ->
               (T_Alt)
sem_Alt_Alt (_pos) (_name) (_fields) (_lhs_altMap) (_lhs_errors) (_lhs_nt) =
    let ((_errs,_aMap)) =
            case locateMap  _name _lhs_altMap  of
               Just (p,_) -> (DupAlt p _pos _lhs_nt _name : _lhs_errors
                             ,_lhs_altMap)
               Nothing    -> let ins (nm,tp) (es,fs) = case lookup nm fs of
                                  Just (p,_) -> (DupChild p _pos _lhs_nt _name nm : es
                                                ,fs)
                                  Nothing    -> (es, (nm, (_pos,tp)): fs)
                                 (es,flds) = foldr ins (_lhs_errors,[]) _fields
                             in (es,insert _name (_pos,flds) _lhs_altMap)
    in  (_aMap,_errs)
-- Alts --------------------------------------------------------
{-
   inherited attributes:
      nt                   : Nonterminal

   chained attributes:
      altMap               : AltMap
      errors               : Errors

   synthesised attributes:

-}
{-
   local variables for Alts.Cons:

-}
{-
   local variables for Alts.Nil:

-}
-- semantic domain
type T_Alts = (AltMap) ->
              (Errors) ->
              (Nonterminal) ->
              ((AltMap),(Errors))
-- cata
sem_Alts :: (Alts) ->
            (T_Alts)
sem_Alts (list) =
    (foldr (sem_Alts_Cons) (sem_Alts_Nil) ((map sem_Alt list)))
sem_Alts_Cons :: (T_Alt) ->
                 (T_Alts) ->
                 (T_Alts)
sem_Alts_Cons (_hd) (_tl) (_lhs_altMap) (_lhs_errors) (_lhs_nt) =
    let ( _hd_altMap,_hd_errors) =
            (_hd (_lhs_altMap) (_tl_errors) (_lhs_nt))
        ( _tl_altMap,_tl_errors) =
            (_tl (_hd_altMap) (_lhs_errors) (_lhs_nt))
    in  (_tl_altMap,_hd_errors)
sem_Alts_Nil :: (T_Alts)
sem_Alts_Nil (_lhs_altMap) (_lhs_errors) (_lhs_nt) =
    let 
    in  (_lhs_altMap,_lhs_errors)
-- Attrs -------------------------------------------------------
{-
   inherited attributes:
      gram2                : Gram
      nts                  : [Nonterminal]

   chained attributes:
      atMap                : AtMap
      errors               : Errors
      uses                 : UseMap

   synthesised attributes:

-}
{-
   local variables for Attrs.Attrs:
      syns
      inhs
      er
      us
      am

-}
-- semantic domain
type T_Attrs = (AtMap) ->
               (Errors) ->
               (Gram) ->
               ([Nonterminal]) ->
               (UseMap) ->
               ((AtMap),(Errors),(UseMap))
-- cata
sem_Attrs :: (Attrs) ->
             (T_Attrs)
sem_Attrs ((Attrs (_pos) (_inh) (_chn) (_syn))) =
    (sem_Attrs_Attrs (_pos) (_inh) (_chn) (_syn))
sem_Attrs_Attrs :: (Pos) ->
                   (AttrNames) ->
                   (AttrNames) ->
                   (AttrNames) ->
                   (T_Attrs)
sem_Attrs_Attrs (_pos) (_inh) (_chn) (_syn) (_lhs_atMap) (_lhs_errors) (_lhs_gram2) (_lhs_nts) (_lhs_uses) =
    let ((_am,_us,_er)) =
            let addAttrs nt (atmap,useMap,err1) =
                 if contains nt _lhs_gram2
                 then
                   let inhAts    = map getAttr  _inhs
                       synAts    = map getAttr  _syns
                       uses     = map getUse   _syns
                       getUse  (nm,_ ,u) = (nm,u )
                       getAttr (nm,tp,_) = (nm,tp)
                       (eInh,eSyn) = fromMaybe (emptyMap,emptyMap) $ locateMap nt atmap
                       eUses       = fromMaybe emptyMap $ locateMap nt useMap
                       (newInh,err2) = foldr (addAttr DupInhAttr)
                                             (eInh,err1)
                                             inhAts
                       (newSyn,err3) = foldr (addAttr DupSynAttr)
                                             (eSyn,err2)
                                             synAts
                       newUses       = foldr addUse eUses uses
                       addUse (_,("",""))  ss = ss
                       addUse (a,use    )  ss | contains a ss  = ss
                                              | otherwise      = insert a use ss
                       addAttr dupE (a,tp) (as,err) = case locateMap a as of
                             Just (p,_) -> (as, dupE p _pos nt a : err)
                             Nothing    -> (insert a (_pos,tp) as,err)
                   in ( insert nt (newInh,newSyn) atmap
                      , insert nt newUses useMap
                      , err3
                      )
                 else (atmap,useMap,UndefNont _pos nt : err1)
            in foldr addAttrs (_lhs_atMap,_lhs_uses,_lhs_errors) _lhs_nts
        (_inhs) =
            _inh ++ _chn
        (_syns) =
            _chn ++ _syn
    in  (_am,_er,_us)
-- Elem --------------------------------------------------------
{-
   inherited attributes:
      attrMap              : AtMap
      gram2                : Gram

   chained attributes:
      atMap                : AtMap
      blocks               : Blocks
      errors               : Errors
      gram                 : Gram
      rulesMap             : RulesMap
      typeSyns             : TypeSyns
      uses                 : UseMap

   synthesised attributes:

-}
{-
   local variables for Elem.Attr:

-}
{-
   local variables for Elem.Data:

-}
{-
   local variables for Elem.Sem:
      rs
      es

-}
{-
   local variables for Elem.Txt:

-}
{-
   local variables for Elem.Type:
      consChildren
      altEnv
      ts
      es
      gr

-}
-- semantic domain
type T_Elem = (AtMap) ->
              (AtMap) ->
              (Blocks) ->
              (Errors) ->
              (Gram) ->
              (Gram) ->
              (RulesMap) ->
              (TypeSyns) ->
              (UseMap) ->
              ((AtMap),(Blocks),(Errors),(Gram),(RulesMap),(TypeSyns),(UseMap))
-- cata
sem_Elem :: (Elem) ->
            (T_Elem)
sem_Elem ((Attr (_pos) (_names) (_attrs))) =
    (sem_Elem_Attr (_pos) (_names) ((sem_Attrs (_attrs))))
sem_Elem ((Data (_pos) (_name) (_attrs) (_alts) (_ext))) =
    (sem_Elem_Data (_pos) (_name) ((sem_Attrs (_attrs))) ((sem_Alts (_alts))) (_ext))
sem_Elem ((Sem (_pos) (_name) (_attrs) (_rules))) =
    (sem_Elem_Sem (_pos) (_name) ((sem_Attrs (_attrs))) ((sem_SemAlts (_rules))))
sem_Elem ((Txt (_pos) (_name) (_lines))) =
    (sem_Elem_Txt (_pos) (_name) (_lines))
sem_Elem ((Type (_pos) (_name) (_arg))) =
    (sem_Elem_Type (_pos) (_name) (_arg))
sem_Elem_Attr :: (Pos) ->
                 ([Nonterminal]) ->
                 (T_Attrs) ->
                 (T_Elem)
sem_Elem_Attr (_pos) (_names) (_attrs) (_lhs_atMap) (_lhs_attrMap) (_lhs_blocks) (_lhs_errors) (_lhs_gram) (_lhs_gram2) (_lhs_rulesMap) (_lhs_typeSyns) (_lhs_uses) =
    let ( _attrs_atMap,_attrs_errors,_attrs_uses) =
            (_attrs (_lhs_atMap) (_lhs_errors) (_lhs_gram2) (_names) (_lhs_uses))
    in  (_attrs_atMap,_lhs_blocks,_attrs_errors,_lhs_gram,_lhs_rulesMap,_lhs_typeSyns,_attrs_uses)
sem_Elem_Data :: (Pos) ->
                 (Nonterminal) ->
                 (T_Attrs) ->
                 (T_Alts) ->
                 (Bool) ->
                 (T_Elem)
sem_Elem_Data (_pos) (_name) (_attrs) (_alts) (_ext) (_lhs_atMap) (_lhs_attrMap) (_lhs_blocks) (_lhs_errors) (_lhs_gram) (_lhs_gram2) (_lhs_rulesMap) (_lhs_typeSyns) (_lhs_uses) =
    let ( _attrs_atMap,_attrs_errors,_attrs_uses) =
            (_attrs (_lhs_atMap) (_alts_errors) (_lhs_gram2) ([ _name ]) (_lhs_uses))
        ( _alts_altMap,_alts_errors) =
            (_alts (maybe emptyMap snd $ locateMap _name _lhs_gram) (_lhs_errors) (_name))
    in  (_attrs_atMap,_lhs_blocks,_alts_errors,insert _name (_pos,_alts_altMap) _lhs_gram,_lhs_rulesMap,_lhs_typeSyns,_attrs_uses)
sem_Elem_Sem :: (Pos) ->
                (Nonterminal) ->
                (T_Attrs) ->
                (T_SemAlts) ->
                (T_Elem)
sem_Elem_Sem (_pos) (_name) (_attrs) (_rules) (_lhs_atMap) (_lhs_attrMap) (_lhs_blocks) (_lhs_errors) (_lhs_gram) (_lhs_gram2) (_lhs_rulesMap) (_lhs_typeSyns) (_lhs_uses) =
    let ((_es,_rs)) =
            if contains _name _lhs_gram2
               then (_attrs_errors
                    ,insert _name _rules_rulesMap _lhs_rulesMap
                    )
               else (UndefNont _pos _name : _lhs_errors
                    ,_lhs_rulesMap
                    )
        ( _attrs_atMap,_attrs_errors,_attrs_uses) =
            (_attrs (_lhs_atMap) (_rules_errors) (_lhs_gram2) ([ _name ]) (_lhs_uses))
        ( _rules_errors,_rules_rulesMap) =
            (_rules (_lhs_attrMap) (maybe emptyMap snd (locateMap _name _lhs_gram2)) (_lhs_errors) (_name) (fromMaybe emptyMap (locateMap _name _lhs_rulesMap)))
    in  (_attrs_atMap,_lhs_blocks,_es,_lhs_gram,_rs,_lhs_typeSyns,_attrs_uses)
sem_Elem_Txt :: (Pos) ->
                (Name) ->
                ([String]) ->
                (T_Elem)
sem_Elem_Txt (_pos) (_name) (_lines) (_lhs_atMap) (_lhs_attrMap) (_lhs_blocks) (_lhs_errors) (_lhs_gram) (_lhs_gram2) (_lhs_rulesMap) (_lhs_typeSyns) (_lhs_uses) =
    let 
    in  (_lhs_atMap,insertComb (++) _name _lines _lhs_blocks,_lhs_errors,_lhs_gram,_lhs_rulesMap,_lhs_typeSyns,_lhs_uses)
sem_Elem_Type :: (Pos) ->
                 (Nonterminal) ->
                 (String) ->
                 (T_Elem)
sem_Elem_Type (_pos) (_name) (_arg) (_lhs_atMap) (_lhs_attrMap) (_lhs_blocks) (_lhs_errors) (_lhs_gram) (_lhs_gram2) (_lhs_rulesMap) (_lhs_typeSyns) (_lhs_uses) =
    let ((_gr,_es,_ts)) =
            case locateMap _name _lhs_gram of
                    Just (p,_) -> ( _lhs_gram
                                  , DupSynonym p _pos _name : _lhs_errors
                                  , _lhs_typeSyns
                                  )
                    Nothing    -> ( insert _name (_pos,_altEnv    ) _lhs_gram
                                  , _lhs_errors
                                  , (_name, _arg) : _lhs_typeSyns
                                  )
        (_altEnv) =
            list2map [("Cons", (_pos,_consChildren    ))
                     ,("Nil" , (_pos,[]))
                     ]
        (_consChildren) =
            [("hd",(_pos,_arg ))
            ,("tl",(_pos,_name))
            ]
    in  (_lhs_atMap,_lhs_blocks,_es,_gr,_lhs_rulesMap,_ts,_lhs_uses)
-- Elems -------------------------------------------------------
{-
   inherited attributes:
      attrMap              : AtMap
      gram2                : Gram

   chained attributes:
      atMap                : AtMap
      errors               : Errors
      gram                 : Gram
      rulesMap             : RulesMap
      typeSyns             : TypeSyns
      uses                 : UseMap

   synthesised attributes:
      blocks               : Blocks

-}
{-
   local variables for Elems.Cons:

-}
{-
   local variables for Elems.Nil:

-}
-- semantic domain
type T_Elems = (AtMap) ->
               (AtMap) ->
               (Errors) ->
               (Gram) ->
               (Gram) ->
               (RulesMap) ->
               (TypeSyns) ->
               (UseMap) ->
               ((AtMap),(Blocks),(Errors),(Gram),(RulesMap),(TypeSyns),(UseMap))
-- cata
sem_Elems :: (Elems) ->
             (T_Elems)
sem_Elems (list) =
    (foldr (sem_Elems_Cons) (sem_Elems_Nil) ((map sem_Elem list)))
sem_Elems_Cons :: (T_Elem) ->
                  (T_Elems) ->
                  (T_Elems)
sem_Elems_Cons (_hd) (_tl) (_lhs_atMap) (_lhs_attrMap) (_lhs_errors) (_lhs_gram) (_lhs_gram2) (_lhs_rulesMap) (_lhs_typeSyns) (_lhs_uses) =
    let ( _hd_atMap,_hd_blocks,_hd_errors,_hd_gram,_hd_rulesMap,_hd_typeSyns,_hd_uses) =
            (_hd (_lhs_atMap) (_lhs_attrMap) (_tl_blocks) (_tl_errors) (_lhs_gram) (_lhs_gram2) (_lhs_rulesMap) (_lhs_typeSyns) (_lhs_uses))
        ( _tl_atMap,_tl_blocks,_tl_errors,_tl_gram,_tl_rulesMap,_tl_typeSyns,_tl_uses) =
            (_tl (_hd_atMap) (_lhs_attrMap) (_lhs_errors) (_hd_gram) (_lhs_gram2) (_hd_rulesMap) (_hd_typeSyns) (_hd_uses))
    in  (_tl_atMap,_hd_blocks,_hd_errors,_tl_gram,_tl_rulesMap,_tl_typeSyns,_tl_uses)
sem_Elems_Nil :: (T_Elems)
sem_Elems_Nil (_lhs_atMap) (_lhs_attrMap) (_lhs_errors) (_lhs_gram) (_lhs_gram2) (_lhs_rulesMap) (_lhs_typeSyns) (_lhs_uses) =
    let 
    in  (_lhs_atMap,emptyMap,_lhs_errors,_lhs_gram,_lhs_rulesMap,_lhs_typeSyns,_lhs_uses)
-- Pattern -----------------------------------------------------
{-
   inherited attributes:
      con                  : Constructor
      defFields            : FieldMap
      nt                   : Nonterminal

   chained attributes:
      errors               : Errors

   synthesised attributes:
      pat                  : Pattern

-}
{-
   local variables for Pattern.Alias:

-}
{-
   local variables for Pattern.Constr:

-}
{-
   local variables for Pattern.Product:

-}
{-
   local variables for Pattern.Underscore:

-}
{-
   local variables for Pattern.Var:

-}
-- semantic domain
type T_Pattern = (Constructor) ->
                 (FieldMap) ->
                 (Errors) ->
                 (Nonterminal) ->
                 ((Errors),(Pattern))
-- cata
sem_Pattern :: (Pattern) ->
               (T_Pattern)
sem_Pattern ((Alias (_pos) (_name) (_pat))) =
    (sem_Pattern_Alias (_pos) (_name) ((sem_Pattern (_pat))))
sem_Pattern ((Constr (_pos) (_name) (_pats))) =
    (sem_Pattern_Constr (_pos) (_name) ((sem_Patterns (_pats))))
sem_Pattern ((Product (_pos) (_pats))) =
    (sem_Pattern_Product (_pos) ((sem_Patterns (_pats))))
sem_Pattern ((Underscore (_pos))) =
    (sem_Pattern_Underscore (_pos))
sem_Pattern ((Var (_pos) (_name))) =
    (sem_Pattern_Var (_pos) (_name))
sem_Pattern_Alias :: (Pos) ->
                     (String) ->
                     (T_Pattern) ->
                     (T_Pattern)
sem_Pattern_Alias (_pos) (_name) (_pat) (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt) =
    let ( _pat_errors,_pat_pat) =
            (_pat (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt))
    in  (nameClashError _pos _lhs_nt _lhs_con _pat_errors _name _lhs_defFields,Alias _pos _name _pat_pat)
sem_Pattern_Constr :: (Pos) ->
                      (String) ->
                      (T_Patterns) ->
                      (T_Pattern)
sem_Pattern_Constr (_pos) (_name) (_pats) (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt) =
    let ( _pats_errors,_pats_pats) =
            (_pats (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt))
    in  (_pats_errors,Constr _pos _name _pats_pats)
sem_Pattern_Product :: (Pos) ->
                       (T_Patterns) ->
                       (T_Pattern)
sem_Pattern_Product (_pos) (_pats) (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt) =
    let ( _pats_errors,_pats_pats) =
            (_pats (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt))
    in  (_pats_errors,Product _pos _pats_pats)
sem_Pattern_Underscore :: (Pos) ->
                          (T_Pattern)
sem_Pattern_Underscore (_pos) (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt) =
    let 
    in  (_lhs_errors,Underscore _pos)
sem_Pattern_Var :: (Pos) ->
                   (String) ->
                   (T_Pattern)
sem_Pattern_Var (_pos) (_name) (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt) =
    let 
    in  (nameClashError _pos _lhs_nt _lhs_con _lhs_errors _name _lhs_defFields,Var _pos _name)
-- Patterns ----------------------------------------------------
{-
   inherited attributes:
      con                  : Constructor
      defFields            : FieldMap
      nt                   : Nonterminal

   chained attributes:
      errors               : Errors

   synthesised attributes:
      pats                 : Patterns

-}
{-
   local variables for Patterns.Cons:

-}
{-
   local variables for Patterns.Nil:

-}
-- semantic domain
type T_Patterns = (Constructor) ->
                  (FieldMap) ->
                  (Errors) ->
                  (Nonterminal) ->
                  ((Errors),(Patterns))
-- cata
sem_Patterns :: (Patterns) ->
                (T_Patterns)
sem_Patterns (list) =
    (foldr (sem_Patterns_Cons) (sem_Patterns_Nil) ((map sem_Pattern list)))
sem_Patterns_Cons :: (T_Pattern) ->
                     (T_Patterns) ->
                     (T_Patterns)
sem_Patterns_Cons (_hd) (_tl) (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt) =
    let ( _hd_errors,_hd_pat) =
            (_hd (_lhs_con) (_lhs_defFields) (_tl_errors) (_lhs_nt))
        ( _tl_errors,_tl_pats) =
            (_tl (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt))
    in  (_hd_errors,_hd_pat : _tl_pats)
sem_Patterns_Nil :: (T_Patterns)
sem_Patterns_Nil (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt) =
    let 
    in  (_lhs_errors,[])
-- SemAlt ------------------------------------------------------
{-
   inherited attributes:
      attrMap              : AtMap
      defAlts              : AltMap
      nt                   : Nonterminal

   chained attributes:
      errors               : Errors
      rulesMap             : RulesMap2

   synthesised attributes:

-}
{-
   local variables for SemAlt.SemAlt:
      rs
      es

-}
-- semantic domain
type T_SemAlt = (AtMap) ->
                (AltMap) ->
                (Errors) ->
                (Nonterminal) ->
                (RulesMap2) ->
                ((Errors),(RulesMap2))
-- cata
sem_SemAlt :: (SemAlt) ->
              (T_SemAlt)
sem_SemAlt ((SemAlt (_pos) (_name) (_fields))) =
    (sem_SemAlt_SemAlt (_pos) (_name) ((sem_SemDefs (_fields))))
sem_SemAlt_SemAlt :: (Pos) ->
                     (Constructor) ->
                     (T_SemDefs) ->
                     (T_SemAlt)
sem_SemAlt_SemAlt (_pos) (_name) (_fields) (_lhs_attrMap) (_lhs_defAlts) (_lhs_errors) (_lhs_nt) (_lhs_rulesMap) =
    let ((_es,_rs)) =
            if contains _name _lhs_defAlts
              then (_fields_errors
                   ,insert _name _fields_rulesMap _lhs_rulesMap
                   )
              else (UndefAlt _pos _lhs_nt _name : _lhs_errors
                   ,_lhs_rulesMap
                   )
        ( _fields_errors,_fields_rulesMap) =
            (_fields (_lhs_attrMap) (_name) (maybe [] snd (locateMap _name _lhs_defAlts)) (_lhs_errors) (_lhs_nt) (fromMaybe (emptyMap,[]) (locateMap _name _lhs_rulesMap)))
    in  (_es,_rs)
-- SemAlts -----------------------------------------------------
{-
   inherited attributes:
      attrMap              : AtMap
      defAlts              : AltMap
      nt                   : Nonterminal

   chained attributes:
      errors               : Errors
      rulesMap             : RulesMap2

   synthesised attributes:

-}
{-
   local variables for SemAlts.Cons:

-}
{-
   local variables for SemAlts.Nil:

-}
-- semantic domain
type T_SemAlts = (AtMap) ->
                 (AltMap) ->
                 (Errors) ->
                 (Nonterminal) ->
                 (RulesMap2) ->
                 ((Errors),(RulesMap2))
-- cata
sem_SemAlts :: (SemAlts) ->
               (T_SemAlts)
sem_SemAlts (list) =
    (foldr (sem_SemAlts_Cons) (sem_SemAlts_Nil) ((map sem_SemAlt list)))
sem_SemAlts_Cons :: (T_SemAlt) ->
                    (T_SemAlts) ->
                    (T_SemAlts)
sem_SemAlts_Cons (_hd) (_tl) (_lhs_attrMap) (_lhs_defAlts) (_lhs_errors) (_lhs_nt) (_lhs_rulesMap) =
    let ( _hd_errors,_hd_rulesMap) =
            (_hd (_lhs_attrMap) (_lhs_defAlts) (_tl_errors) (_lhs_nt) (_lhs_rulesMap))
        ( _tl_errors,_tl_rulesMap) =
            (_tl (_lhs_attrMap) (_lhs_defAlts) (_lhs_errors) (_lhs_nt) (_hd_rulesMap))
    in  (_hd_errors,_tl_rulesMap)
sem_SemAlts_Nil :: (T_SemAlts)
sem_SemAlts_Nil (_lhs_attrMap) (_lhs_defAlts) (_lhs_errors) (_lhs_nt) (_lhs_rulesMap) =
    let 
    in  (_lhs_errors,_lhs_rulesMap)
-- SemDef ------------------------------------------------------
{-
   inherited attributes:
      attrMap              : AtMap
      con                  : Constructor
      defFields            : FieldMap
      nt                   : Nonterminal

   chained attributes:
      errors               : Errors
      rulesMap             : RulesMap3

   synthesised attributes:

-}
{-
   local variables for SemDef.Def:
      rs
      errs

-}
{-
   local variables for SemDef.LocDef:

-}
-- semantic domain
type T_SemDef = (AtMap) ->
                (Constructor) ->
                (FieldMap) ->
                (Errors) ->
                (Nonterminal) ->
                (RulesMap3) ->
                ((Errors),(RulesMap3))
-- cata
sem_SemDef :: (SemDef) ->
              (T_SemDef)
sem_SemDef ((Def (_pos) (_field) (_attr) (_rhs) (_owrt))) =
    (sem_SemDef_Def (_pos) (_field) (_attr) (_rhs) (_owrt))
sem_SemDef ((LocDef (_pos) (_pat) (_rhs) (_owrt))) =
    (sem_SemDef_LocDef (_pos) ((sem_Pattern (_pat))) (_rhs) (_owrt))
sem_SemDef_Def :: (Pos) ->
                  (Name) ->
                  (Name) ->
                  (Expression) ->
                  (Bool) ->
                  (T_SemDef)
sem_SemDef_Def (_pos) (_field) (_attr) (_rhs) (_owrt) (_lhs_attrMap) (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt) (_lhs_rulesMap) =
    let ((_errs,_rs)) =
            if _field == _LHS
               then addRule _pos _field _attr _rhs _lhs_nt snd _lhs_attrMap _owrt _lhs_nt _lhs_con _lhs_rulesMap _lhs_errors
               else case lookup _field _lhs_defFields of
                   Just (_,tp) -> addRule _pos _field _attr _rhs tp fst _lhs_attrMap _owrt _lhs_nt _lhs_con _lhs_rulesMap _lhs_errors
                   Nothing -> (UndefChild _pos _lhs_nt _lhs_con _field : _lhs_errors
                              , _lhs_rulesMap
                              )
    in  (_errs,_rs)
sem_SemDef_LocDef :: (Pos) ->
                     (T_Pattern) ->
                     (Expression) ->
                     (Bool) ->
                     (T_SemDef)
sem_SemDef_LocDef (_pos) (_pat) (_rhs) (_owrt) (_lhs_attrMap) (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt) (_lhs_rulesMap) =
    let ( _pat_errors,_pat_pat) =
            (_pat (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt))
    in  (_pat_errors
        ,let (rules,lrules) = _lhs_rulesMap
         in (rules, LocRule _pat_pat _rhs _owrt : lrules)
        )
-- SemDefs -----------------------------------------------------
{-
   inherited attributes:
      attrMap              : AtMap
      con                  : Constructor
      defFields            : FieldMap
      nt                   : Nonterminal

   chained attributes:
      errors               : Errors
      rulesMap             : RulesMap3

   synthesised attributes:

-}
{-
   local variables for SemDefs.Cons:

-}
{-
   local variables for SemDefs.Nil:

-}
-- semantic domain
type T_SemDefs = (AtMap) ->
                 (Constructor) ->
                 (FieldMap) ->
                 (Errors) ->
                 (Nonterminal) ->
                 (RulesMap3) ->
                 ((Errors),(RulesMap3))
-- cata
sem_SemDefs :: (SemDefs) ->
               (T_SemDefs)
sem_SemDefs (list) =
    (foldr (sem_SemDefs_Cons) (sem_SemDefs_Nil) ((map sem_SemDef list)))
sem_SemDefs_Cons :: (T_SemDef) ->
                    (T_SemDefs) ->
                    (T_SemDefs)
sem_SemDefs_Cons (_hd) (_tl) (_lhs_attrMap) (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt) (_lhs_rulesMap) =
    let ( _hd_errors,_hd_rulesMap) =
            (_hd (_lhs_attrMap) (_lhs_con) (_lhs_defFields) (_tl_errors) (_lhs_nt) (_lhs_rulesMap))
        ( _tl_errors,_tl_rulesMap) =
            (_tl (_lhs_attrMap) (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt) (_hd_rulesMap))
    in  (_hd_errors,_tl_rulesMap)
sem_SemDefs_Nil :: (T_SemDefs)
sem_SemDefs_Nil (_lhs_attrMap) (_lhs_con) (_lhs_defFields) (_lhs_errors) (_lhs_nt) (_lhs_rulesMap) =
    let 
    in  (_lhs_errors,_lhs_rulesMap)

