{- UU_AG, version tag: r1
 - Copyright:  S. Doaitse Swierstra, Arthur I. Baars and Andres Loeh
               Department of Computer Science
               Utrecht University
               P.O. Box 80.089
               3508 TB UTRECHT
               the Netherlands
               {swierstra,arthurb,andres}@cs.uu.nl -}
module Main where

import GetOpt
import System
import UU_Maps
import List (sortBy,partition,isSuffixOf)
import UU_Pretty
import Scanner
import UU_Parsing_Core(Reports(..))
import Parser
import Transform (sem_AG)
import DefaultRules (sem_Grammar)
import qualified GenerateCode as Gen(sem_Grammar)
import PrintCode (sem_Program)
import PrintErrorMessages (sem_Errors)
import TokenDef (loc)
{- Available options for generating code:
   m : module header
   d : data type definition
   c : catas
   f : semantic functions
   s : signatures for semantic functions
   p : pretty printed attribute listings
-}

options     :: [OptDescr String]
options     =  [ Option ['m']
                 ["module"]
                 (NoArg "m")
                 "generate module headers"
               , Option ['d']
                 ["data"]
                 (NoArg "d")
                 "generate data type definition"
               , Option ['c']
                 ["catas"]
                 (NoArg "c")
                 "generate catamorphisms"
               , Option ['f']
                 ["semfuns"]
                 (NoArg "f")
                 "generate semantic functions"
               , Option ['s']
                 ["signatures"]
                 (NoArg "s")
                 "generate signatures for semantic functions"
               , Option ['p']
                 ["pretty"]
                 (NoArg "p")
                 "generate pretty printed list of attributes"
               , Option ['r']
                 ["rename"]
                 (NoArg "r")
                 "rename data constructors"
               , Option ['o']
                 ["output"]
                 (ReqArg ('o':) "file")
                 "specify output file"
               , Option ['a']
                 ["all"]
                 (NoArg allc)
                 ("do everything (-" ++ allc ++ ")")
               , Option ['v']
                 ["verbose"]
                 (NoArg "v")
                 "verbose error message format"
{-               , Option ['x']
                 ["macros"]
                 (NoArg "x")
                 "generate syntax macro instance"
-}
               , Option ['h','?']
                 ["help"]
                 (NoArg "h")
                 "get (this) usage information"
               ]

allc = "mdcsfpr"

type Options  = String

{- MAIN -}

main        :: IO ()
main        =  do
                 args <- getArgs
                 let (o,n,errs) = getOpt Permute options args
                 let (output',opts') = partition ((=='o') . head) o
                 let output = map tail output' ++ repeat ""
                 let opts = if null opts'
                               then allc
                               else concat opts'
                 if null n || 'h' `elem` opts
                    then putStr $ usageInfo usageheader options
                    else sequence_ $ map (\(x,out) -> compile x out opts)
                                         (zip n output)
  where
  usageheader = "Usage info:\n  ag options file ...\n\nList of options:"

compile     :: String -> String -> Options -> IO ()
compile f output o
            =  do
                 let inputfile  = inputFile f
                 let outputfile = if output == "" then outputFile f
                                                  else output
                 let modulename = moduleName f
                 (ag,errs_pars) <- parseAG inputfile
                 let (blocks,err_des,desugar) = sem_AG ag
                     (err_trans,transformed)  = sem_Grammar desugar
                     (err_gen,prog         )  = Gen.sem_Grammar transformed o
                     verbose = 'v' `elem` o
                     err1 = sem_Errors err_des   verbose
                     err2 = sem_Errors err_trans verbose
                     err3 = sem_Errors err_gen verbose
                     code = sem_Program prog
                 putStr . showReports $ takeReports 5 errs_pars

                 render err1 75
                 render err2 75
                 render err3 75

                 writeFile outputfile "-- do not edit; automatically generated by UU_AG\n"
                 if ('m' `elem` o) then generateHeader outputfile modulename else return ()
                 let textblocks = case locateMap "imports" blocks of
                                   Nothing -> getValues blocks
                                   Just b  -> b : getValues (delete "imports" blocks)
                 appendFile outputfile
                     . unlines . concat $ textblocks
                 appendFileLn outputfile (code 450)
                 putStrLn ("\n" ++ outputfile ++ " generated")
--                 if 'x' `elem` o then macros modulename
--                    else return ()

   where takeReports n rs  | n <= 0 = NoMoreReports
                           | otherwise = case rs of
                                           Insert a b c rs' -> Insert a b c (takeReports (n-1) rs')
                                           Delete a b c rs' -> Delete a b c (takeReports (n-1) rs')
                                           NoMoreReports    -> NoMoreReports
         showReports (Insert un _  exp rs) = parseError un exp ++  showReports rs
         showReports (Delete _  un exp rs) = parseError (Just un) exp ++ showReports rs
         showReports (NoMoreReports    )   = ""
         parseError unexp expect =
                     let (pos,un) = case unexp of
                                Nothing -> ("", "end of file")
                                Just s  -> (show (loc s), show s)
                     in "Parse error " ++ pos ++"\n" ++
                        "Unexpected " ++ un ++ "\n" ++
                        "Expecting " ++ show expect ++ "\n\n"


generateHeader :: String -> String -> IO ()
generateHeader o f =  do
                         appendFile o $ "module " ++ f ++ " where\n"


appendFileLn :: String -> String -> IO ()
appendFileLn f t = do
                     appendFile f t
                     appendFile f "\n"

inputFile :: String -> String
inputFile f = if ".ag" `isSuffixOf` f || ".lag" `isSuffixOf` f
                  then f
                  else f ++ ".ag"

outputFile :: String -> String
outputFile f = moduleName f ++ ".hs"

moduleName :: String -> String
moduleName f = if ".ag" `isSuffixOf` f
                  then (take (length f - 3) f )
               else if ".lag" `isSuffixOf` f
                  then (take (length f - 4) f )
               else f
