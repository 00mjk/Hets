
# usage: 
#   genInlines.pl Modal/GeneratePatterns.inline.hs.in Modal/ModalSystems.hs

# substitute ##<WORD> with Haskell code snippits

use strict;
use File::Basename;

my $disclaimer = '"Remove this trace when Results from map_sign are available\\n"';

my %substs = 
 ("°!modalAx" =>
  "inlineAxioms Modal \"modality empty\\n".
"pred p,q:()\\n".
". ",
  "°!caslAx" =>
  "inlineAxioms CASL \"sort world \\n".
"pred rel : world * world\\n".
"forall w1 : world \\n. ");

die "exactly one in- and one out-file needed!!" unless @ARGV == 2;

my ($infile,$outfile) = @ARGV;
my $outfile1 = join "", (fileparse($infile,'\.in'))[1,0];

print STDERR "Generating $outfile1\n";

open IN, "<$infile" or die "cannot read \"$infile\"";
open OUT, ">$outfile1" or die "cannot write to \"$outfile1\"";

while (<IN>) {
   foreach my $key (keys %substs) {
      s/$key\"/$substs{$key}/ge;
   }
   print OUT $_;
}

close IN;
close OUT;

my $input = `utils/outlineAxioms $outfile1`;
if($? >> 8) {
    print STDERR "outlineAxioms detected an error\n";
    exit 5;
}
$input =~ s,^.*snip\s+><\s+Patterns(.*)snip\s+>/<\s+Patterns,$1,s;
$input =~ s/^\s*\[\(\[\[//s;
$input =~ s/(\})\]\]\)\]\s*$/$1/s;

# print "$input\n";
my @input = split(/\]\]\),\s+?\(\[\[/s, $input); 

print STDERR "Generating $outfile\n";
open OUT, ">$outfile" or die "cannot write to \"$outfile\"";

print OUT '{- look but don\'t touch !!
generated by utils genFunction.pl -}

module Modal.ModalSystems (transSchemaMFormula) where

import Debug.Trace

import Common.PrettyPrint
import Common.AS_Annotation

-- CASL
import CASL.Logic_CASL 
import CASL.AS_Basic_CASL

-- ModalCASL
import Modal.AS_Modal
import Modal.Print_AS
import Modal.Utils

transSchemaMFormula :: ([VAR] -> TERM M_FORMULA -> TERM ())
                    -> SORT -> PRED_NAME -> [VAR] 
		    -> AnModFORM -> Maybe (Named CASLFORMULA)

',
'transSchemaMFormula mapT world rel vars anMF =
   let '.
	  join("\n       ",map {'w'.$_.' = vars !! '.($_-1);} (1,2,3,4,5)).
	  ' in
    case (getRLabel anMF,item anMF) of
';

foreach my $pair (@input) {
#    print "Pair: $pair\n";
    my $moda_i = 0;
    my ($pattern,$result) = split /\]\],\s+?\[\[/s,$pair;
#    print "    $pattern => $result\n";
    $pattern =~ s/""/_label/os;
    $pattern =~ s/\n//gos;
    $pattern =~ s/\s+/ /go;
    $pattern =~ s/Simple_mod empty/'moda'.$moda_i++/goe;
    $pattern =~ s/ (p|q) / _ /go;
    $pattern =~ s/\}\s*$//o;
    $pattern =~ s/NamedSen\{senName = //o;
    $pattern =~ s/(\w,) sentence = /$1/o;
    $pattern =~ s/\[\]/_/go;
    $result =~ s/\n//gos;
    $result =~ s/\s+/ /go;
    my $list = "";
    for (my $i = 0; $i < $moda_i; $list .= 'moda'.$i++.",") {};
    $list = "[$list";
    $list =~ s/,$/]/o;
    unless ($result =~ m/^\s*Nothing\s*$/o) {
	$result = "Just \$ ".$result;
    }	
    print OUT
'      ('.$pattern.") -> \n".
'         addTerm mapT rel (map modToTerm '.$list.') vars ('.$result.")\n";
}
print OUT '      (_,f)'." -> \n".
          '          trace ('.$disclaimer.'++"Modal2CASL: unknown formula \\""++showPretty f "\\"\\n"++show f) Nothing
';

close OUT;
