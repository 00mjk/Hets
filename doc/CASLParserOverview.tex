\documentclass{article}

\parindent 0pt
\parskip 5pt

\begin{document}

\section{Preliminaries}

Make sure a new version (currently 5.04.1) of \texttt{ghc}
(www.haskell.org) is properly installed.  Also
\texttt{/usr/local/bin/perl, /usr/local/bin/bash} and \texttt{GNU
  make} are required.


\subsection{Accessing the CVS repository}

Read \texttt{http://www.informatik.uni-bremen.de/\~{}ger/cvs/CVS.html}
and send the encrypted password and your (or another) username to
George Russell (\texttt{ger@tzi.de}). Under solaris you can use
\texttt{/home/till/bin/encrypt} to get the password. After George's
reply you can log in. 

For \texttt{cvs login} the evironment variable \texttt{CVSROOT} must be set:

\begin{verbatim}
CVSROOT=:pserver:$USER@cvs-agbkb.informatik.uni-bremen.de:/repository
export CVSROOT
\end{verbatim}

Go to or make a directory with sufficient space, i.e. under
\texttt{/home/cofi/\$USER}, and then retrieve the source tree:

\begin{verbatim}
cvs checkout HetCATS
\end{verbatim}

With \texttt{cvs up} you'll always retrieve the latest versions,
unless you modified a file. A modified file can be put into the
repository by \texttt{cvs commit MyFile}. Before committing something
you may check differences by \texttt{cvs diff MyFile}. Make sure the
committed file is usable for others and enter a meaningful log
message. A short log message can be given via the \texttt{-m} option:

\begin{verbatim}
cvs commit -m "corrected typing of 'eror' to 'error' " MyFile
\end{verbatim}

A completely new file must be added before committing by \texttt{cvs
  add MyFile}.  No longer used files can be removed by \texttt{cvs
  remove MyFile}.  Moving a file from one directory to another is
best done by adding and removing.

\texttt{cvs log MyFile} gives an overview of all revisions. An old
version, i.e. the initial revision 1.1, may be viewed using the
\texttt{-p} and \texttt{-r} options. (If you forget \texttt{-p} the
current revision will change.)

\begin{verbatim}
cvs up -p -r1.1 MyFile | less
\end{verbatim}

When you no longer work with the repository, you may release it:

\begin{verbatim}
cvs release HetCATS
\end{verbatim}

\subsection{Using Hugs}

It is also possible to use hugs (version of Nov. 2002) instead of ghc.
A binary for Solaris is currently available under
\texttt{/home/maeder/bin/hugs}.  The environment variable
\texttt{HUGSFLAGS} (one line) is given in my \texttt{.bashrc} as follows:

\begin{verbatim}
HCAT=/home/maeder/haskell/HetCATS
HLIB=/home/maeder/lib/hugs/lib

export HUGSFLAGS="-98 +o -h20M\
  -P$HCAT:$HCAT/hugs:$HCAT/parsec:$HCAT/pretty:$HCAT/haterm-1.0/src:\
    $HCAT/aterm_conv:$HCAT/fgl:$HCAT/CASL:$HCAT/HasCASL:\
    $HLIB:$HLIB/exts:$HLIB/hugs\
  -E\"emacsclient +%d %s\""
\end{verbatim}

The variable \texttt{HCAT} must be set to your own \texttt{HetCATS} directory.

\section{Getting started}

\subsection{Check out}
The latest versions of all sources should be checked out in the top
directory \texttt{HetCATS/} using:

\texttt{cvs up -d}

(use option \texttt{-d} to also get new directories)

\subsection{(Pre-)Compile}

\texttt{cd HetCATS/hetcats} and call \texttt{make} (on Linux) or
\texttt{gmake} (on Solaris). To fully recompile everything call
\texttt{gmake distclean} before. Files with extensions
\texttt{*.\{d,o,hi\}} are intermediate compilation results.

One important effect is that \texttt{*.der.hs} files will be
``drifted'', i.e.  from \texttt{*.der.hs} files actual haskell source
files (\texttt{*.hs}) are created that include extra code for
instances (of class \texttt{PosItem}) derived by DrIFT (a in
\texttt{HetCATS/utils/}).

\subsection{Compiling the CASL parser}

\texttt{cd HetCATS/CASL} and call \texttt{./ghc-call} (a script that
contains all necessary ghc options and parameters). An alternative is to call \texttt{gmake capa} in (almost) any directory with a \texttt{Makefile}.

This creates a binary called \texttt{capa} that can parse (and pretty
print) ``Basic Specification with Subsorts'' of the CASL Summary
version 1.0.1 \\ (www.brics.dk/Projects/CoFI/Documents/CASL/Summary/).

Structured specifications can not be parsed yet.

Note: if module \texttt{AS\_Basic\_CASL} can not be found
\texttt{AS\_Basic\_CASL.hs} was not ``drifted'' (see above). Most
\texttt{AS\_*} files have extension \texttt{.der.hs} and need to
be drifted.

\subsection{Testing}

A test call might be: 

\texttt{./capa BasicSpec.casl}

The binary \texttt{capa} is also used to test various subordinate (and
mixfix) parsers. Test cases are given as \texttt{*.casl} files.

Calling \texttt{./runcheck.sh ./capa} performs many tests and compares the
results with corresponding \texttt{*.output} files.

Alternatively a test can be run using \texttt{runhugs}. For this the
file \texttt{capa.lhs} is executable and the test can be run
by \texttt{./runcheck.sh ./capa.lhs}.

\texttt{Wrong*.casl} files contain wrong CASL code and should produce
error messages. Apart from extra tests, correct (\texttt{Bla.casl})
and wrong files (\texttt{WrongBla.casl}) are tested. The number e of
``\texttt{error}'' occurrences (in the produced ouput) is compared to the
number of input lines. If e is zero or is equal to the number of lines
then the test is silently regarded as ok, otherwise an additional message
is produced that can be ignored provided the internal call to
\texttt{diff} succeeded and ``\texttt{passed}'' was emitted.

Calling ``\texttt{./runcheck.sh ./capa set}'' will update the \texttt{*.output} files (and a subsequent \texttt{./runcheck.sh ./capa} should always pass).

\section{Structure of source files}

\subsection{Directory \texttt{HetCATS/CASL}}

\subsubsection*{Parser related files}

\begin{description}
\item[capa.lhs] is the main module that simply lists the test parsers
  and is executable for hugs
\item[RunParsers.hs] contains the driver called in Main for test parsers and is reused in \texttt{HetCATS/HasCASL}
\item[RunMixfixParser.hs] is an additional driver to test the mixfix
  analysis. (It declares an existential type.)
\item[MixfixParser.hs] uses precedence and associativity to resolve
  mixfix terms (and formulae). Also \%list, \%string, \%number and
  \%floating annotations are resolved. 
\item[AS\_Basic\_CASL.hs] defines the abstract syntax tree for CASL
\item[Print\_AS\_Basic.hs] pretty prints data types of
  \texttt{AS\_Basic\_CASL.hs}
\item[Parse\_AS\_Basic.hs] supplies the top-level parsers \texttt{basicSpec,
  basicItems, dotFormulae} and \texttt{sigItems}
\item[TypeItem.hs] parsers \texttt{datatype} and \texttt{typeItems}
\item[OpItem.hs] parsers \texttt{opItem(s)} and \texttt{predItem(s)}
\item[SortItem.hs] parser \texttt{sortItem(s)} (requires \texttt{Formula.hs} for subsort definitions)
\item[ItemList.hs] parses items (separated by semicolons) generically
  (\texttt{itemList}) and annotations between or following these
  items. It depends on \texttt{annotationL} from
  \texttt{HetCATS/Anno\_Parser.hs}.
\item[SymbolParser.hs] parses symbols and symbol maps that are not
  needed for basic specs but for heterogeneous structured
  specifications only (see \texttt{Logic\_CASL.hs})
\item[Formula.hs] parser \texttt{term} and \texttt{formula}
\item[Token.hs] generic parser for mixfix ids and some keyword parsers
  (reused in \texttt{HetCATS/HasCASL}). The haskell data types
  \texttt{Token} and \texttt{Id} are defined in \texttt{HetCATS/Id.hs}!
\item[Lexer.hs] various scanners and extensions of the Parsec library 
\item[Keywords.hs] CASL keywords as named identifiers (to be used
  for parsing and printing and thus ensuring consistent spellings)
\end{description}

\subsubsection*{Dependencies to the parent and other directories}
\label{sec:casl}

The above files rely on the data types in \texttt{Id.hs} and
\texttt{AS\_Annotation.hs} in the parent directory. For pretty
printing the class in \texttt{PrettyPrint.hs} is required.
\texttt{PrettyPrint.hs} in turn relies on
\texttt{GlobalAnnotations.hs} and \texttt{pretty/LaTeX\_funs.hs} and
\texttt{pretty/LaTeX\_maps.hs} (to consider \%display annotations).
\texttt{pretty/Pretty.lhs} is an adapted copy of\\
\texttt{//research.microsoft.com/\~{}simonpj/downloads/pretty-printer/pretty.html}
that is also included as Haskell (\texttt{package -text}) library. (So
don't include this package instead of the subdirectories
\texttt{pretty} and \texttt{parsec}.)

\texttt{PrettyPrint.hs} supplies an instance for \texttt{Id}. The
instance for annotations is given in \texttt{Print\_AS\_Annotation.hs}.
\texttt{CASL/Print\_AS\_Basic} further imports \texttt{PPUtils.hs}.

\texttt{GlobalAnnotations.hs} contains the \texttt{PrecedenceGraph} and
imports \texttt{FiniteMap} from the Haskell (\texttt{package -data})
library and \texttt{fgl/Graph.hs} that (unfortunately) has its
own implementation of maps, namely
\texttt{fgl/SimpleMap.hs}. 
FGL comes from \texttt{www.cs.orst.edu/\~{}erwig/fgl/}

In conjunction with \texttt{GlobalAnnotations.hs} also
\texttt{GlobalAnnotationsFunctions.hs} is sometimes needed. The later
depends on \texttt{GraphUtils.hs}. 

\texttt{CASL/MixfixParser.hs} uses \texttt{Result.hs} to combine
diagnostic messages.

The actually parser combinators come from 
\texttt{www.cs.uu.nl/\~{}daan/parsec.html} that are part of the
Haskell library but also have been slightly extended (by
\texttt{consumeNothing}) and included in the \texttt{parsec/}
subdirectory. \texttt{Parsec.hs} simply reexports parts from
\texttt{ParsecPrim.hs}, \texttt{ParsecCombinator.hs},
\texttt{ParsecChar.hs}, \texttt{ParsecError.hs} and
\texttt{ParsecPos.hs}

\texttt{Anno\_Parser.hs} has its own parser for mixfix \texttt{Id}s based on
\texttt{CaslLanguage.hs} that in turn is based on
\texttt{parsec/ParsecToken.hs} and \texttt{parsec/ParsecLanguage.hs}.
\texttt{Anno\_Parser.hs} further uses \texttt{parsec/ParsecPerm.hs}
and \texttt{Utils.hs}.

\subsubsection*{Other \texttt{*.hs} files in \texttt{HetCATS/CASL}}

\begin{description}
\item[Sign.hs] describes signatures after the static analysis
\item[Static.hs] computes the above signatures
\item[Logic\_CASL.hs] supplies an instance for \texttt{HetCATS/Logic.hs}
\item[Sublogics.hs] is used in \texttt{Logic\_CASL.hs}
\end{description}
 
\texttt{MixfixParser.hs} operates only on \texttt{FORMULA} and
\texttt{TERM} from \texttt{AS\_Basic\_CASL.der.hs} and not on
\texttt{Sign.hs}. 

Typechecking (considering subtypes and overloading) of terms and
formulae (plus their conversions to the types in \texttt{Sign.hs}) is
still missing.

\subsubsection*{scripts}

\texttt{runcheck.sh} includes \texttt{checkFunctions.sh}.
\texttt{iterate.sh} checks differences between the working copy and
the most recent cvs version.


\subsection{Top-level directory \texttt{HetCATS}}

The subdirectories \texttt{utils} (for DriFT), \texttt{hetcats} (for
the final application), \texttt{pretty}, \texttt{parsec}, \texttt{fgl}
have been mentioned above.

\begin{description}
\item[CASL] see \ref{sec:casl} (Christian)
\item[CSP-CASL] Markus
\item[HasCASL] Christian
\item[Lottery] Markus
\item[aterm\_conv] converts sml-CATS ATerms (Klaus)
\item[haterm-1.0/src] the adapted ATerm library (Klaus)
\item[doc] for documentations like this one
\item[hugs] include this directory if you use hugs
\item[ghc] include this directory if you use ghc
\item[mini] Till
\item[test] for test cases (Pascal)
\end{description}

The directories \texttt{hugs} and \texttt{ghc} currently only implement the function \texttt{unsafeCoerce} differently. 

The top-level directory contains the abstract syntax trees for
heterogeneous specifications: \texttt{AS\_Atructured}, \texttt{AS\_Architecture} and \texttt{AS\_Library}

For the above \texttt{AS\_*.der.hs} files corresponding pretty
printers \texttt{Print\_AS\_*.hs} are given. 

\begin{description}
\item[DevGraph.hs] Development Graph (Till)
\item[GlobalEnv.hs] Global environment (Till)
\item[GlobalLibraryAnnotations.hs] extends \texttt{GlobalAnnotationsFunctions} and \texttt{AS\_Library}
\item[Grothendieck.hs] supplies the heterogeneous (existential) data
  types for structured specifications
\item[Logic.hs] defines the (very big) class \texttt{Logic} for the
  types in \texttt{Grothendieck}. It exploits \texttt{functional
    dependencies}!
\item[LogicRepr.hs] is an extension of \texttt{Logic.hs} and includes
  composition of logic representation (not used?)
\item[LogicGraph.hs] gives a graph of logic representations (not used?)
\item[LogicStructured.hs] has something to do with sublogics (Pascal, Till?)
\item[P\_user\_state.hs] is intended (as user state of parsec
  combinators) for heterogeneous parsing (Klaus)
\item[Parse\_AS\_Structured.hs] is the unfinished start of a heterogeneous
  parser without user state (Christian)
\item[Print\_HetCASL.hs] applies functions from \texttt{Print\_AS\_Library}
\item[Prover.hs] is one subdivision of \texttt{Logic.hs}
\item[test\_parser.hs] contains a \texttt{main} to test the differences
  between the two \texttt{Id} parsers (from Christian's
  \texttt{CASL/Token.hs} and Klaus's \texttt{Anno\_Parser.hs}).
\end{description}

The other files \texttt{AS\_Annotation.der.hs},
\texttt{CaslLanguage.hs}, \texttt{Id.hs}, \texttt{Result.hs},
\texttt{GraphUtils.hs}, \texttt{PPUtils.hs}, \texttt{PrettyPrint.hs},
\texttt{Print\_AS\_Annotation} and \texttt{Utils.hs} have been mentioned in 
Section \ref{sec:casl}.


\subsection{Directory \texttt{HetCATS/HasCASL}}

HasCASL relies on \texttt{CASL/Keywords.hs}, \texttt{CASL/Lexer.hs},
\texttt{CASL/Token.hs} and \texttt{CASL/RunParsers.hs} (for testing
purposes in \texttt{Main.hs}). Form the top-level directory also stuff
for annotations (i.e.\ \texttt{Anno\_Parser.hs}) is used.

\begin{description}
\item[hacapa.lhs] counterpart to \texttt{CASL/capa.lhs} 
\item[As.hs] abstract syntax
\item[Le.hs] local environment
\item[HToken.hs] extension of \texttt{CASL/Token.hs} for HasCASL
  (further keywords)
\item[PrintAs.hs] pretty printing the abstract syntax
\item[ParseTerm.hs] parsing classes, types, terms and formulae
\item[ParseItem.hs] parsing basic (HasCASL) items
\end{description}

As in \texttt{HetCATS/CASL/} there are some test files (
\texttt{*.casl}, \texttt{Wrong*.casl} and \texttt{*.output}) and a
script \texttt{runcheck.sh}. The binary produced by \texttt{ghc-call}
is named \texttt{hacapa}.

\end{document}

