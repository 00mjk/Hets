{- |
Module      :  $Header$
Description :  Import data generated by hol2hets into a DG
Copyright   :  (c) Jonathan von Schroeder, DFKI GmbH 2010
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  jonathan.von_schroeder@dfki.de
Stability   :  experimental
Portability :  portable

-}

module HolLight.HolLight2DG where

import Static.GTheory
import Static.DevGraph
import Static.History
import Static.ComputeTheory

import Logic.Logic
import Logic.Prover
import Logic.ExtSign
import Logic.Grothendieck

import Common.LibName
import Common.Id
import Common.AS_Annotation
import Common.Result

import HolLight.Sign
import HolLight.Sentence
import HolLight.Term
import HolLight.Logic_HolLight
import HolLight.Helper

import Driver.Options

import Data.Graph.Inductive.Graph
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified Data.Char

import qualified System.FilePath.Posix

import Maybe

import Text.XML.Light

cleanContent :: Element -> [Content]
cleanContent e = catMaybes (map (\ c -> case c of
 (CRef s) -> if all Data.Char.isSpace s then Nothing else Just c
 (Text s) -> if all Data.Char.isSpace (cdData s) then Nothing else Just c
 _ -> Just c
 ) (elContent e))

expectElems :: [String] -> [Content] -> [Element]
expectElems [] _ = []
expectElems (s:s') (c:c') = case c of
 Elem e -> if qName (elName e) == s then e:(expectElems s' c')
           else []
 _ -> expectElems (s:s') c'
expectElems _ _ = []

expectElem :: Content -> Maybe Element
expectElem (Elem e) = Just e
expectElem _ = Nothing

readTuple :: Content -> Maybe (Element,Element)
readTuple (Elem e) =
 if qName (elName e) == "tuple" then
  case expectElems ["fst","snd"] (cleanContent e) of
   (f:s:[]) -> Just (f,s) 
   _ -> Nothing
 else Nothing
readTuple _ = Nothing

readMappedTuple :: (Show a, Show b) => (Element -> Maybe a) -> (Element -> Maybe b) -> Content -> Maybe (a,b)
readMappedTuple a b c = case readTuple c of
 Just (c1,c2) -> case (a c1,b c2) of
  (Just e1,Just e2) -> Just (e1,e2)
  _ -> Nothing
 Nothing -> Nothing

readString :: Content -> Maybe String
readString (CRef s) = Just s
readString (Text t) = let s = cdData t
                          b = Data.Char.isSpace
                      in Just $ reverse (dropWhile b (reverse (dropWhile b s)))
readString _ = Nothing

readType :: Content -> Maybe HolType
readType (Elem e) = case (qName (elName e),cleanContent e) of
 ("TyVar",s:[]) -> case readString s of
  Just s' -> Just (TyVar s')
  _ -> Nothing
 ("TyApp",s:t) -> case (readString s, readAll readType t) of
  (Just s',Just t') -> Just (TyApp s' t')
  _ -> Nothing
 _ -> Nothing
readType _ = Nothing

readOnlyInt :: [Content] -> Maybe Int
readOnlyInt ((CRef s):[]) = Just ((read s)::Int)
readOnlyInt ((Text s):[]) = Just ((read (cdData s))::Int)
readOnlyInt _ = Nothing

readParseType :: [Content] -> Maybe ([Content],HolParseType)
readParseType ((Elem e):c') = case (qName (elName e),cleanContent e) of
 ("Prefix",_) -> Just (c',Prefix)
 ("InfixR",c) -> case (readOnlyInt c) of
  Just i  -> Just (c',InfixR i)
  Nothing ->  Nothing
 ("InfixL",c) -> case (readOnlyInt c) of
  Just i  -> Just (c',InfixL i)
  Nothing -> Nothing
 ("Normal",_) -> Just (c',Normal)
 ("Binder",_) -> Just (c',Binder)
 _ -> Nothing
readParseType _ = Nothing

applyToContents :: ([Content] -> Maybe a) -> Element -> Maybe a
applyToContents f e = f (cleanContent e)

applyToSingleEl :: (Content -> Maybe a) -> Element -> Maybe a
applyToSingleEl f e = case (cleanContent e) of
 (e':[]) -> f e'
 _ -> Nothing

readTermInfo :: [Content] -> Maybe HolTermInfo
readTermInfo c = case readParseType c of
 Just (c',p) -> case c' of
  (t:_) -> case readMappedTuple (applyToSingleEl readString) (applyToContents readParseType) t of
   Just (s,(_,p1)) -> Just (HolTermInfo (p,Just (s,p1)))
   _ -> Just (HolTermInfo (p,Nothing))
  _ -> Just (HolTermInfo (p,Nothing))
 _ -> Nothing

readTerm :: Content -> Maybe Term
readTerm (Elem e) = case (qName (elName e),cleanContent e) of
 ("Var",n:t:i) -> case (readString n,readType t,readTermInfo i) of
  (Just n',Just t',Just i') -> Just (Var n' t' i')
  _ -> Nothing
 ("Const",n:t:i) -> case (readString n,readType t,readTermInfo i) of
  (Just n',Just t',Just i') -> Just (Const n' t' i')
  _ -> Nothing
 ("Comb",t1:t2:[]) -> case (readTerm t1,readTerm t2) of
  (Just t1',Just t2') -> Just (Comb t1' t2')
  _ -> Nothing
 ("Abs",t1:t2:[]) -> case (readTerm t1,readTerm t2) of
  (Just t1',Just t2') -> Just (Abs t1' t2')
  _ -> Nothing
 _ -> Nothing
readTerm _ = Nothing

readTest :: a -> Maybe a
readTest c = Just c

readAll :: (Content -> Maybe a) -> [Content] -> Maybe [a]
readAll _ [] = Just []
readAll r (c:c') = case (r c,readAll r c') of
 (Just e,Just l) -> Just (e:l)
 _ -> Nothing

importData :: FilePath -> IO ([(String,[(String,Term)])],[(String,String)]) 
importData fp = do
    s <- readFile fp
    let e = ([],[])
    case parseXMLDoc s of
     Just export -> 
      if qName (elName export) == "HolExport" then
       case expectElems ["Libs","LibLinks"] (cleanContent export) of
        (l:lk:[]) -> let l' = readAll (readMappedTuple (applyToSingleEl readString) (applyToContents (readAll (readMappedTuple (applyToSingleEl readString) (applyToSingleEl readTerm))))) (cleanContent l)
                         lk' = readAll (readMappedTuple (applyToSingleEl readString) (applyToSingleEl readString)) (cleanContent lk)
                     in case (l',lk') of
                      (Just l'',Just lk'') -> return (l'',lk'')
                      _ -> return e
        _ -> return e
      else return e
     Nothing -> return e

get_types :: Map.Map String Int -> HolType -> Map.Map String Int
get_types m t = case t of
 (TyVar s) -> Map.insert s 0 m
 (TyApp s ts) -> let m' = foldl get_types Map.empty ts in
                     Map.insert s (length ts) m'

mergeTypesOps :: (Map.Map String Int,Map.Map String (Set.Set HolType))
                 -> (Map.Map String Int,Map.Map String (Set.Set HolType))
                 -> (Map.Map String Int,Map.Map String (Set.Set HolType))
mergeTypesOps (ts1,ops1) (ts2,ops2) =
 (Map.union ts1 ts2,Map.unionWith Set.union ops1 ops2)

get_ops :: [String] -> Bool -> Term
           -> (Map.Map String Int,Map.Map String (Set.Set HolType)) 
get_ops ign not_abs t = case t of
 (Var s tp _)   -> let ts = get_types Map.empty tp
                     in if not_abs && not (elem s ign) then
                          (ts,Map.insert s (Set.fromList [tp]) Map.empty)
                        else (ts,Map.empty)
 (Const s tp _) -> let ts = get_types Map.empty tp
                     in (ts,Map.insert s (Set.fromList [tp]) Map.empty)
 (Comb t1 t2) -> mergeTypesOps 
                  (get_ops ((name_of t1):ign) True  t1)
                  (get_ops ((name_of t1):ign) True  t2)
 (Abs t1 t2)  -> mergeTypesOps                  
                  (get_ops ((name_of t1):ign) False t1)
                  (get_ops ((name_of t1):ign) True  t2)

calcSig :: [(String,Term)] -> Sign
calcSig tm = let (ts,os) = foldl
                  (\p (_,t) -> (mergeTypesOps (get_ops [] True t) p)) (Map.empty,Map.empty) tm
             in Sign {
                 types = ts
                ,ops = os }

sigDepends :: Sign -> Sign -> Bool
sigDepends s1 s2 = ((Map.size (Map.intersection (types s1) (types s2))) /= 0) ||
                   (foldl (||) False (map snd (Map.toList (Map.intersectionWith
                     (\a b -> (Set.size (Set.intersection a b))/=0)
                     (ops s1) (ops s2)))))

treeLevels :: [(String,String)] -> Map.Map Int [(String,String)]
treeLevels l = let lk = foldl (\l' (imp,t) -> case lookup t l' of
                                 Just (p,_) -> (imp,(p+1,t)):l'
                                 Nothing -> (imp,(1,t)):(t,(0,"")):l') [] l
                        in foldl (\m (imp,(p,t)) ->
                            let s = Map.findWithDefault [] p m
                                in Map.insert p ((imp,t):s) m) Map.empty lk

makeNamedSentence :: String -> Term -> Named Sentence
makeNamedSentence n t = makeNamed n $ Sentence { term = t, proof = Nothing }

_insNodeDG :: Sign -> [Named Sentence] -> String -> (DGraph, Map.Map String (String,Data.Graph.Inductive.Graph.Node,DGNodeLab)) -> (DGraph, Map.Map String (String,Data.Graph.Inductive.Graph.Node,DGNodeLab))
_insNodeDG sig sens n (dg,m) = let gt = G_theory HolLight (makeExtSign HolLight sig) startSigId
                                          (toThSens sens) startThId
                                   n' = snd (System.FilePath.Posix.splitFileName n)
                                   labelK = newInfoNodeLab
                                          (makeName (mkSimpleId n'))
                                          (newNodeInfo DGEmpty)
                                          gt
                                   k = getNewNodeDG dg
                                   m' = Map.insert n (n,k,labelK) m
                                   insN = [InsertNode (k,labelK)]
                                   newDG = changesDGH dg insN
                                   labCh = [SetNodeLab labelK (k, labelK
                                         { globalTheory = computeLabelTheory Map.empty newDG
                                           (k, labelK) })]
                                   newDG1 = changesDGH newDG labCh in (newDG1,m')

anaHolLightFile :: HetcatsOpts -> FilePath -> IO (Maybe (LibName, LibEnv))
anaHolLightFile _opts path = do
   (libs, lnks) <- importData path
   let h = treeLevels lnks
   let fixLinks m l = case l of 
        (l1:l2:l') -> if ((snd l1) == (snd l2)) && (sigDepends
                          (Map.findWithDefault emptySig (fst l1) m)
                          (Map.findWithDefault emptySig (fst l2) m)) then
                       ((fst l1,fst l2):(fixLinks m (l2:l')))
                      else (l1:l2:(fixLinks m l'))
        l' -> l'
   let uniteSigs m lnks' = foldl (\m' (s,t) -> case resultToMaybe (sigUnion
                                                                   (Map.findWithDefault emptySig s m')
                                                                   (Map.findWithDefault emptySig t m')) of
                                                Nothing      -> m'
                                                Just new_tsig -> Map.insert t new_tsig m') m lnks'
   let m = foldl (\m' (s,l) -> Map.insert s (calcSig l) m') Map.empty libs
   let (m',lnks') = foldr (\lvl (m'',lnks_loc) -> let lvl' = Map.findWithDefault [] lvl h
                                                      lnks_next = fixLinks m'' (reverse lvl')
                                               in (uniteSigs m'' lnks_next,lnks_next++lnks_loc)
                    ) (m,[]) [0..((Map.size h)-1)]
   let (dg',node_m) = foldr (\(lname,lterms) (dg,node_m') ->
           let sig = Map.findWithDefault emptySig lname m'
               sens = map (\(n,t) -> makeNamedSentence n t) lterms in
           _insNodeDG sig sens lname (dg,node_m')) (emptyDG,Map.empty) libs
       dg'' = foldr (\(source,target) dg -> case Map.lookup source node_m of
                                           Just (n,k,lk) -> case Map.lookup target node_m of
                                             Just (n1,k1,lk1) -> let sig  = Map.findWithDefault emptySig n  m'
                                                                     sig1 = Map.findWithDefault emptySig n1 m' in
                                                          case resultToMaybe $ subsig_inclusion HolLight sig sig1 of
                                                            Nothing -> dg
                                                            Just incl ->
                                                              let inclM = gEmbed $ mkG_morphism HolLight incl
                                                                  insE = [InsertEdge (k, k1,globDefLink inclM DGLinkImports)]
                                                                  newDG = changesDGH dg insE
                                                                  updL = [SetNodeLab lk1 (k1, lk1
                                                                          { globalTheory = computeLabelTheory Map.empty newDG
                                                                           (k1, lk1) }),
                                                                          SetNodeLab lk (k, lk
                                                                          { globalTheory = computeLabelTheory Map.empty newDG
                                                                           (k, lk) })]
                                                              in changesDGH newDG updL
                                             Nothing -> dg
                                           Nothing -> dg) dg' lnks'
       le = Map.insert (emptyLibName (System.FilePath.Posix.takeBaseName path)) dg'' (Map.empty)
   return (Just (emptyLibName (System.FilePath.Posix.takeBaseName path), le))
