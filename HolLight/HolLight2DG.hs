{- |
Module      :  $Header$
Description :  Import data generated by hol2hets into a DG
Copyright   :  (c) Jonathan von Schroeder, DFKI GmbH 2010
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  jonathan.von_schroeder@dfki.de
Stability   :  experimental
Portability :  portable

-}

module HolLight.HolLight2DG where

import Static.GTheory
import Static.DevGraph
import Static.ComputeTheory
import Static.AnalysisStructured

import Logic.Logic
import Logic.Prover
import Logic.ExtSign
import Logic.Grothendieck

import HolLight.Sign
import HolLight.Sentence
import HolLight.Logic_HolLight

import Driver.Options

import Data.Map as Map

data SenInfo = SenInfo Int Bool [Int] String

term_sig :: Term -> Sign
term_sig (Var s _) = Sign (Set.singleton s)
term_sig (Comb t1 t2) = sigUnion (term_sig t1) (term_sig t2)
term_sig (Abs t1 t2) = sigUnion (term_sig t1) (term_sig t2)
term_sig _ = Sign Set.empty

anaHol2HetsFile :: HetcatsOpts -> FilePath -> IO (Maybe (LibName, LibEnv))
directHolParsing _ fp = do
  s <- readFile fp
  let s' = (read s) :: [(Term,SenInfo)] in
  let (dg,lnks,m) = foldl (\(t,SenInfo id axiom inc name) (dg,ls,mp) ->
                   let gt = G_theory HolLight (makeExtSign HolLight (term_sig t)) startSigId (toThSens [makeNamed name (Sentence name t Nothing)]) startThId in
                   let (n,dg') = insGTheory dg (mkName (mkSimpleId name)) DGEmpty gt in
                   (dg1',ls++(map (\i -> (i,n)) inc),Map.insert id (n) mp) 
                 ) (emptyDG,[],Map.emoty) s' in
  let dg' = foldl (\(i,n) d -> 
            let s = case Map.lookup i m
                      Just n1 -> n1
                      Nothing -> error "encountered internal error while importing data exported from Hol Light" in
            let incl = subsig_inclusion HolLight (plainSign (getSig n1)) (plainSign (getSig n)) in
            let gm = case maybeResult incl of
                     Nothgin -> error "encountered an internal error importing data exported from Hol Light" 
                     Just inc -> gEmbed $ mkG_morphism HolLight inc in
            insLink d gm globalDef TEST (getNode n1) (getNode n)

           ) dg lnks
  let ln = emptyLibName fp
      lib = Map.singleton ln $
              computeDGraphTheories Map.empty dg in
