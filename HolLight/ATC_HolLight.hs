{-# OPTIONS -w -O0 #-}
{- |
Module      :  HolLight/ATC_HolLight.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'HolLight.Sentence.Sentence'
'HolLight.Sentence.HolProof'
'HolLight.Sentence.HolType'
'HolLight.Sentence.Term'
'HolLight.Sign.Sign'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
HolLight/Sentence.hs
HolLight/Sign.hs
-}

module HolLight.ATC_HolLight () where

import ATC.AS_Annotation
import ATerm.Lib
import Common.Doc
import Common.DocUtils
import Data.Typeable
import HolLight.Sentence
import HolLight.Sign
import qualified Data.Set as Set

{-! for HolLight.Sentence.Sentence derive : Typeable !-}
{-! for HolLight.Sentence.HolProof derive : Typeable !-}
{-! for HolLight.Sentence.HolType derive : Typeable !-}
{-! for HolLight.Sentence.Term derive : Typeable !-}
{-! for HolLight.Sign.Sign derive : Typeable !-}

{-! for HolLight.Sentence.Sentence derive : ShATermConvertible !-}
{-! for HolLight.Sentence.HolProof derive : ShATermConvertible !-}
{-! for HolLight.Sentence.HolType derive : ShATermConvertible !-}
{-! for HolLight.Sentence.Term derive : ShATermConvertible !-}
{-! for HolLight.Sign.Sign derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

instance ShATermConvertible Term where
  toShATermAux att0 xv = case xv of
    Var a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Var" [a', b'] []) att2
    Const a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Const" [a', b'] []) att2
    Comb a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Comb" [a', b'] []) att2
    Abs a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Abs" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Var" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Var a' b') }}
    ShAAppl "Const" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Const a' b') }}
    ShAAppl "Comb" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Comb a' b') }}
    ShAAppl "Abs" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Abs a' b') }}
    u -> fromShATermError "Term" u

instance ShATermConvertible HolType where
  toShATermAux att0 xv = case xv of
    TyVar a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TyVar" [a'] []) att1
    TyApp a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TyApp" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TyVar" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TyVar a') }
    ShAAppl "TyApp" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TyApp a' b') }}
    u -> fromShATermError "HolType" u

instance ShATermConvertible HolProof where
  toShATermAux att0 xv = case xv of
    NoProof -> return $ addATerm (ShAAppl "NoProof" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "NoProof" [] _ -> (att0, NoProof)
    u -> fromShATermError "HolProof" u

instance ShATermConvertible Sentence where
  toShATermAux att0 xv = case xv of
    Sentence a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Sentence" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sentence" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Sentence a' b' c') }}}
    u -> fromShATermError "Sentence" u

_tcTermTc :: TyCon
_tcTermTc = mkTyCon "HolLight.Sentence.Term"
instance Typeable Term where
    typeOf _ = mkTyConApp _tcTermTc []

_tcHolTypeTc :: TyCon
_tcHolTypeTc = mkTyCon "HolLight.Sentence.HolType"
instance Typeable HolType where
    typeOf _ = mkTyConApp _tcHolTypeTc []

_tcHolProofTc :: TyCon
_tcHolProofTc = mkTyCon "HolLight.Sentence.HolProof"
instance Typeable HolProof where
    typeOf _ = mkTyConApp _tcHolProofTc []

_tcSentenceTc :: TyCon
_tcSentenceTc = mkTyCon "HolLight.Sentence.Sentence"
instance Typeable Sentence where
    typeOf _ = mkTyConApp _tcSentenceTc []

_tcSignTc :: TyCon
_tcSignTc = mkTyCon "HolLight.Sign.Sign"
instance Typeable Sign where
    typeOf _ = mkTyConApp _tcSignTc []

instance ShATermConvertible Sign where
  toShATermAux att0 xv = case xv of
    Sign a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Sign" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sign" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Sign a') }
    u -> fromShATermError "Sign" u
