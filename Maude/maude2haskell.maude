 fmod MAUDE2HASKELL is
  pr CONVERSION .
  pr VIEW .
  ex META-MODULE .
  
  var  H : Header .
  var  IL : ImportList .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  var  ODS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RS : RuleSet .
  vars Q Q' Q'' : Qid .
  var  QIL : QidList .
  var  STR STR1 STR2 : String .
  vars ME ME' ME'' : ModuleExpression .
  var  TL : TermList .
  vars T T' : Term .
  var  AtS : AttrSet .
  var  TyL : TypeList .
  var  Ty : Type .
  vars S S' : Sort .
  var  K : Kind .
  var  A : Attr .
  var  Ct : Constant .
  var  V : Variable .
  var  N : Nat .
  var  NL : NatList .
  var  Mb : MembAx .
  vars C C' : Condition .
  var  Eq : Equation .
  var  R : Rule .
  var  PDL : ParameterDeclList .
  var  I : Import .
  var  PD : ParameterDecl .
  var  HL : HookList .
  var  HK : Hook .
  var  RNMS : RenamingSet .
  var  SVM : Set{ViewMap} .
  var  VM : ViewMap .
  var  PL : ParameterList .
  var  M M' : Module .
  var  FR : FindResult .
  
  --- Constant used when no module is really needed
  op no-module : -> Module .
  
  op haskellify : Qid -> QidList .
  eq haskellify(Q) = haskellify(upModule(Q, false)) .

  op haskellify : Module -> QidList .
  ceq haskellify(M) = 
      'SpecMod '`( 'Module haskellifyHeader(H) ' ' 
      '`[ haskellifyImports(IL) comma(IL, SS)
          haskellifySorts(SS) comma(IL, SS, SSDS)
          haskellifySubsorts(SSDS) comma(IL, SS, SSDS, ODS)
          haskellifyOpDeclSet(M, ODS) comma(IL, SS, SSDS, ODS, MAS)
          haskellifyMembAxSet(M, MAS) comma(IL, SS, SSDS, ODS, MAS, EqS)
          haskellifyEqSet(M, EqS) '`] '`) '\n '@#$endHetsSpec$#@ '\n
    if fmod H is IL sorts SS . SSDS ODS MAS EqS endfm := M .
  ceq haskellify(M) = 
      'SpecMod '`( 'Module haskellifyHeader(H) ' ' 
      '`[ haskellifyImports(IL) comma(IL, SS)
          haskellifySorts(SS) comma(IL, SS, SSDS)
          haskellifySubsorts(SSDS) comma(IL, SS, SSDS, ODS)
          haskellifyOpDeclSet(M, ODS) comma(IL, SS, SSDS, ODS, MAS)
          haskellifyMembAxSet(M, MAS) comma(IL, SS, SSDS, ODS, MAS, EqS)
          haskellifyEqSet(M, EqS) comma(IL, SS, SSDS, ODS, MAS, EqS, RS)
          haskellifyRlSet(M, RS) '`] '`) '\n '@#$endHetsSpec$#@ '\n
   if mod H is IL sorts SS . SSDS ODS MAS EqS RS endm := M .
  ceq haskellify(M) = 
      'SpecTh '`( 'Module haskellifyHeader(H) ' ' 
      '`[ haskellifyImports(IL) comma(IL, SS)
          haskellifySorts(SS) comma(IL, SS, SSDS)
          haskellifySubsorts(SSDS) comma(IL, SS, SSDS, ODS)
          haskellifyOpDeclSet(M, ODS) comma(IL, SS, SSDS, ODS, MAS)
          haskellifyMembAxSet(M, MAS) comma(IL, SS, SSDS, ODS, MAS, EqS)
          haskellifyEqSet(M, EqS) '`] '`) '\n '@#$endHetsSpec$#@ '\n
   if fth H is IL sorts SS . SSDS ODS MAS EqS endfth := M .
  ceq haskellify(M) = 
      'SpecTh '`( 'Module haskellifyHeader(H) ' ' 
      '`[ haskellifyImports(IL) comma(IL, SS)
          haskellifySorts(SS) comma(IL, SS, SSDS)
          haskellifySubsorts(SSDS) comma(IL, SS, SSDS, ODS)
          haskellifyOpDeclSet(M, ODS) comma(IL, SS, SSDS, ODS, MAS)
          haskellifyMembAxSet(M, MAS) comma(IL, SS, SSDS, ODS, MAS, EqS)
          haskellifyEqSet(M, EqS) comma(IL, SS, SSDS, ODS, MAS, EqS, RS)
          haskellifyRlSet(M, RS) '`] '`) '\n '@#$endHetsSpec$#@ '\n
   if th H is IL sorts SS . SSDS ODS MAS EqS RS endth := M .
  
  op haskellify : Module Module View -> QidList .
  eq haskellify(M, M', view Q from ME to ME' is SVM endv) = 
      'SpecView '`( 'View '`( 'ModId qid2token(Q) '`)
      haskellifyME(ME) haskellifyME(ME')
      '`[ haskellifyMaps(M, M', SVM) '`] '`) '\n '@#$endHetsSpec$#@ '\n .
  
  op haskellifyHeader : Header -> QidList .
  eq haskellifyHeader(Q) = ' '`( 'ModId qid2token(Q) '`) ' ' '`[ '`] .
  eq haskellifyHeader(Q {PDL}) = ' '`( 'ModId qid2token(Q) '`) ' '
                                 '`[ haskellifyParamDeclList(PDL) '`] .

  op haskellifyParamDeclList : ParameterDeclList -> QidList .
  eq haskellifyParamDeclList(nil) = nil .
  eq haskellifyParamDeclList((PD, PDL)) = haskellifyParamDecl(PD) comma(PDL)
                                          haskellifyParamDeclList(PDL) .
  
  op haskellifyParamDecl : ParameterDecl -> QidList .
  eq haskellifyParamDecl(S :: ME) = 'Parameter '`( haskellifySort(S) '`) '
                                               '`( haskellifyME(ME) '`) ' .
  
  op comma : ParameterDeclList -> QidList .
  eq comma((nil).ParameterDeclList) = nil .
  eq comma(PDL) = '`, ' [owise] .

  op haskellifyImports : ImportList -> QidList .
  eq haskellifyImports(nil) = nil .
  eq haskellifyImports(I IL) = 'ImportStmnt ' '`( haskellifyImport(I) '`) comma(IL)
                               haskellifyImports(IL) .

  op haskellifyImport : Import -> QidList .
  eq haskellifyImport(protecting ME .) = 'Protecting haskellifyME(ME) .
  eq haskellifyImport(including ME .) = 'Including haskellifyME(ME) .
  eq haskellifyImport(extending ME .) = 'Extending haskellifyME(ME) .
  
  op comma : ImportList -> QidList .
  eq comma((nil).ImportList) = nil .
  eq comma(IL) = '`, ' [owise] .

  op haskellifyME : ModuleExpression -> QidList .
  eq haskellifyME(Q) = ' '`( 'ModExp ' '`( 'ModId qid2token(Q) '`) '`) ' .
  eq haskellifyME(ME + ME') = ' '`( 'SummationModExp haskellifyME(ME) 
                              haskellifyME(ME')  '`) ' .
  eq haskellifyME(ME * (RNMS)) = ' '`( 'RenamingModExp haskellifyME(ME) 
                                 '`[ haskellifyMaps(no-module, no-module, RNMS) '`]  '`) ' .
  eq haskellifyME(ME {PL}) = ' '`( 'InstantiationModExp haskellifyME(ME) 
                             '`[ haskellifyPL(PL)  '`]  '`) ' .

  op haskellifyMaps : Module Module Set{ViewMap} -> QidList .
  eq haskellifyMaps(M, M', none) = nil .
  eq haskellifyMaps(M, M', VM) = haskellifyMap(M, M', VM) .
  eq haskellifyMaps(M, M', (VM, SVM)) = haskellifyMap(M, M', VM) '`, '
                                        haskellifyMaps(M, M', SVM) .
  
  op haskellifyMap : Module Module ViewMap -> QidList .
  eq haskellifyMap(M, M', sort Q to Q') = 'SortRenaming haskellifySort(Q) haskellifySort(Q') .
  eq haskellifyMap(M, M', label Q to Q') = 'LabelRenaming haskellifyLabel(Q) haskellifyLabel(Q') .
  eq haskellifyMap(M, M', op Q to Q' [AtS]) = 'OpRenaming1 '`( 'OpId qid2token(Q) '`) '
                                              '`( 'To ' '`( 'OpId qid2token(Q') '`) '
                                              '`[ haskellifyAttr*(no-module, AtS) '`]  '`) ' .
  eq haskellifyMap(M, M', op Q : TyL -> Ty to Q' [AtS]) =
                   'OpRenaming2 '`( 'OpId qid2token(Q) '`) ' '`[ haskellifyType*(TyL) '`]
                   haskellifyType(Ty)
                   '`( 'To ' '`( 'OpId qid2token(Q') '`) ' 
                   '`[ haskellifyAttr*(no-module, AtS) '`]  '`) ' .
  eq haskellifyMap(M, M', termMap(T, T')) = 'TermMap haskellifyTerm(M, T) haskellifyTerm(M', T') .
  
  op haskellifyPL : ParameterList -> QidList .
  eq haskellifyPL(empty) = nil .
  eq haskellifyPL((Q, PL)) = 'ViewId qid2token(Q) comma(PL) haskellifyPL(PL) .
  
  op comma : ParameterList -> QidList .
  eq comma((empty).ParameterList) = nil .
  eq comma(PL) = '`, ' [owise] .

  op haskellifyLabel : Qid -> QidList .
  eq haskellifyLabel(Q) = ' '`( 'LabelId qid2token(Q) '`) ' .
  
  op haskellifySorts : SortSet -> QidList .
  eq haskellifySorts(none) = nil .
  eq haskellifySorts(S ; SS) = 'SortStmnt ' '`( haskellifySort(S) '`) comma(SS)
                               haskellifySorts(SS) .
  
  op haskellifySort : Sort -> QidList .
  eq haskellifySort(S) = ' '`( 'SortId qid2token(S) '`) ' .
  
  op comma : SortSet -> QidList .
  eq comma((none).SortSet) = nil .
  eq comma(SS) = '`, ' [owise] .
  
  op haskellifySubsorts : SubsortDeclSet -> QidList .
  eq haskellifySubsorts(none) = nil .
  eq haskellifySubsorts(subsort S < S' . SSDS) = 
            'SubsortStmnt ' '`( 'Subsort haskellifySort(S) haskellifySort(S') '`) comma(SSDS)
            haskellifySubsorts(SSDS) .

  op comma : SubsortDeclSet -> QidList .
  eq comma((none).SubsortDeclSet) = nil .
  eq comma(SSDS) = '`, ' [owise] .

  op haskellifyOpDeclSet : Module OpDeclSet -> QidList .
  eq haskellifyOpDeclSet(M, none) = nil .
  eq haskellifyOpDeclSet(M, op Q : TyL -> Ty [AtS] . ODS) = 
         'OpStmnt ' '`( 'Op ' '`( 'OpId qid2token(Q) '`) ' ' '`[ haskellifyType*(TyL) '`] '
             haskellifyType(Ty) ' '`[ haskellifyAttr*(M, AtS) '`] '`) comma(ODS)
         haskellifyOpDeclSet(M, ODS) .

  op comma : OpDeclSet -> QidList .
  eq comma((none).OpDeclSet) = nil .
  eq comma(ODS) = '`, ' [owise] .

  op haskellifyType : Type -> QidList .
  eq haskellifyType(S) = ' '`( 'TypeSort haskellifySort(S) '`) ' .
  eq haskellifyType(K) = ' '`( 'TypeKind haskellifyKind(kind2sort(K)) '`) ' .
  
  op kind2sort : Kind -> Qid .
  ceq kind2sort(K) = if FR :: Nat
                     then qid(substr(STR, 0, FR))
                     else qid(substr(STR, 0, _-_(length(STR),2)))
                     fi
   if STR := substr(string(K), 2, length(string(K))) /\
      FR := find(STR, "`,", 0) .
  
  op haskellifyKind : Qid -> QidList .
  eq haskellifyKind(Q) = ' '`( 'KindId qid2token(Q) '`) ' .
  
  op haskellifyType* : TypeList -> QidList .
  
  eq haskellifyType*(nil) = nil .
  eq haskellifyType*(Ty TyL) = haskellifyType(Ty) comma(TyL)
                               haskellifyType*(TyL) .

  op comma : TypeList -> QidList .
  eq comma((nil).TypeList) = nil .
  eq comma(TyL) = '`, ' [owise] .

  op haskellifyAttr : Module Attr -> QidList .
  eq haskellifyAttr(M, assoc) = 'Assoc .
  eq haskellifyAttr(M, comm) = 'Comm .
  eq haskellifyAttr(M, idem) = 'Idem .
  eq haskellifyAttr(M, ctor) = 'Ctor .
  eq haskellifyAttr(M, iter) = 'Iter .
  eq haskellifyAttr(M, memo) = 'Memo .
  eq haskellifyAttr(M, object) = 'Object .
  eq haskellifyAttr(M, msg) = 'Msg .
  eq haskellifyAttr(M, config) = 'Config .
  eq haskellifyAttr(M, id(T)) = 'Id haskellifyTerm(M, T) .
  eq haskellifyAttr(M, left-id(T)) = 'LeftId haskellifyTerm(M, T) .
  eq haskellifyAttr(M, right-id(T)) = 'RightId haskellifyTerm(M, T) .
  eq haskellifyAttr(M, frozen(NL)) = 'Frozen ' '`[ haskellifyNatList(NL) '`] ' .
  eq haskellifyAttr(M, strat(NL)) = 'Strat ' '`[ haskellifyNatList(NL) '`] ' .
  eq haskellifyAttr(M, poly(NL)) = 'Poly ' '`[ haskellifyNatList(NL) '`] ' .
  eq haskellifyAttr(M, prec(N)) = 'Prec nat2qid(N) .
  eq haskellifyAttr(M, label(Q)) = 'Label qid2token(Q) .
  eq haskellifyAttr(M, gather(QIL)) = 'Gather ' '`[ printQidList(QIL) '`] ' .
  eq haskellifyAttr(M, format(QIL)) = 'Format ' '`[ printQidList(QIL) '`] ' .
  eq haskellifyAttr(M, nonexec) = 'Nonexec .
  eq haskellifyAttr(M, owise) = 'Owise .
  eq haskellifyAttr(M, special(HL)) = 'Special ' '`[ haskellifyHookList(M, HL) '`] ' .
  
  op haskellifyHookList : Module HookList -> QidList .
  eq haskellifyHookList(M, nil) = nil .
  eq haskellifyHookList(M, HK HL) = haskellifyHook(M, HK) comma(HL) haskellifyHookList(M, HL) .
  
  op haskellifyHook : Module Hook -> QidList .
  eq haskellifyHook(M, id-hook(Q, QIL)) = 'IdHook qid2token(Q) ' '`[ printQidList(QIL) '`] ' .
  eq haskellifyHook(M, op-hook(Q, Q', QIL, Q'')) = 'OpHook qid2token(Q) qid2token(Q')
                                                ' '`[ printQidList(QIL) '`] ' qid2token(Q'') .
  eq haskellifyHook(M, term-hook(Q, T)) = 'TermHook qid2token(Q) haskellifyTerm(M, T) .
  
  op comma : HookList -> QidList .
  eq comma((nil).HookList) = nil .
  eq comma(HL) = '`, ' [owise] .

  op printQidList : Qid -> QidList .
  eq printQidList(nil) = nil .
  eq printQidList(Q QIL) = qid2token(Q) comma(QIL) printQidList(QIL) .
  
  op comma : QidList -> QidList .
  eq comma((nil).QidList) = nil .
  eq comma(QIL) = '`, ' [owise] .

  op haskellifyTerm : Module Term -> QidList .
  ceq haskellifyTerm(M, Ct) = ' '`( 'Const qid2token(Q) haskellifyType(Ty) '`) '
   if Q := getName(Ct) /\
      Ty := getType(Ct) .
  ceq haskellifyTerm(M, V) = ' '`( 'Var qid2token(Q) haskellifyType(Ty) '`) '
   if Q := getName(V) /\
      Ty := getType(V) .
  ceq haskellifyTerm(M, Q[TL]) = ' '`( 'Apply qid2token(Q) ' '`[ haskellifyTerm*(M, TL) '`] '
                                        haskellifyType(Ty) '`) '
   if {T, Ty} := metaNormalize(M, Q[TL]) .
  
  op haskellifyTerm* : Module TermList -> QidList .
  eq haskellifyTerm*(M, empty) = nil .
  eq haskellifyTerm*(M, (T, TL)) = haskellifyTerm(M, T) comma(TL)
                                   haskellifyTerm*(M, TL) .

  op comma : TermList -> QidList .
  eq comma((empty).TermList) = nil .
  eq comma(TL) = '`, ' [owise] .
  
  op haskellifyAttr* : Module AttrSet -> QidList .
  eq haskellifyAttr*(M, none) = nil .
  eq haskellifyAttr*(M, A AtS) = haskellifyAttr(M, A) comma(AtS)
                                 haskellifyAttr*(M, AtS) .

  op comma : AttrSet -> QidList .
  eq comma((none).AttrSet) = nil .
  eq comma(AtS) = '`, ' [owise] .

  op haskellifyMembAxSet : Module MembAxSet -> QidList .
  eq haskellifyMembAxSet(M, none) = nil .
  eq haskellifyMembAxSet(M, Mb MAS) = 'MbStmnt ' '`( haskellifyMembAx(M, Mb) '`) comma(MAS)
                                       haskellifyMembAxSet(M, MAS) .

  op haskellifyMembAx : Module MembAxSet -> QidList .
  eq haskellifyMembAx(M, mb T : S [AtS] .) = 'Mb haskellifyTerm(M, T)
                                              haskellifySort(S)
                                              ' '`[ '`] '
                                              ' '`[ haskellifyAttr*(M, AtS) '`] ' .
  eq haskellifyMembAx(M, cmb T : S if C [AtS] .) = 'Mb haskellifyTerm(M, T)
                                                   haskellifySort(S)
                                                   ' '`[ haskellifyCondition(M, C) '`] '
                                                   ' '`[ haskellifyAttr*(M, AtS) '`] ' .

  op haskellifyCondition : Module Condition -> QidList .
  eq haskellifyCondition(M, nil) = nil .
  ceq haskellifyCondition(M, C /\ C') = haskellifyCondition(M, C) '`, '
                                        haskellifyCondition(M, C')
   if C =/= nil /\ C' =/= nil .
  eq haskellifyCondition(M, T = T') = 'EqCond haskellifyTerm(M, T)
                                              haskellifyTerm(M, T') .
  eq haskellifyCondition(M, T := T') = 'MatchCond haskellifyTerm(M, T) 
                                                  haskellifyTerm(M, T') .
  eq haskellifyCondition(M, T : S) = 'MbCond haskellifyTerm(M, T) 
                                             haskellifySort(S) .
  eq haskellifyCondition(M, T => T') = 'RwCond haskellifyTerm(M, T) 
                                               haskellifyTerm(M, T') .

  op comma : MembAxSet -> QidList .
  eq comma((none).MembAxSet) = nil .
  eq comma(MAS) = '`, ' [owise] .
  
  op haskellifyEqSet : Module EquationSet -> QidList .
  eq haskellifyEqSet(M, none) = nil .
  eq haskellifyEqSet(M, Eq EqS) = 'EqStmnt ' '`( haskellifyEq(M, Eq) '`) comma(EqS)
                                   haskellifyEqSet(M, EqS) .
  
  op haskellifyEq : Module Equation -> QidList .
  eq haskellifyEq(M, eq T = T' [AtS] .) = 'Eq haskellifyTerm(M, T)
                                              haskellifyTerm(M, T')
                                              ' '`[ '`] '
                                              ' '`[ haskellifyAttr*(M, AtS) '`] ' .
  eq haskellifyEq(M, ceq T = T' if C [AtS] .) = 'Eq haskellifyTerm(M, T)
                                                    haskellifyTerm(M, T')
                                                    ' '`[ haskellifyCondition(M, C) '`] '
                                                    ' '`[ haskellifyAttr*(M, AtS) '`] ' .
  
  op comma : EquationSet -> QidList .
  eq comma((none).EquationSet) = nil .
  eq comma(EqS) = '`, ' [owise] .

  op haskellifyRlSet : Module RuleSet -> QidList .
  eq haskellifyRlSet(M, none) = nil .
  eq haskellifyRlSet(M, R RS) = 'RlStmnt ' '`( haskellifyRl(M, R) '`) comma(RS)
                                 haskellifyRlSet(M, RS) .
  
  op haskellifyRl : Module Rule -> QidList .
  eq haskellifyRl(M, rl T => T' [AtS] .) = 'Rl haskellifyTerm(M, T)
                                               haskellifyTerm(M, T')
                                               ' '`[ '`] '
                                               ' '`[ haskellifyAttr*(M, AtS) '`] ' .
  eq haskellifyRl(M, crl T => T' if C [AtS] .) = 'Rl haskellifyTerm(M, T)
                                                     haskellifyTerm(M, T')
                                                     ' '`[ haskellifyCondition(M, C) '`] '
                                                     ' '`[ haskellifyAttr*(M, AtS) '`] ' .
  
  op comma : RuleSet -> QidList .
  eq comma((none).RuleSet) = nil .
  eq comma(RS) = '`, ' [owise] .

  -----------------------------------------------------------------
  ------------------- COMMA AUXILIARY FUNCTIONS -------------------
  -----------------------------------------------------------------

  op comma : ImportList SortSet -> QidList .
  eq comma(IL, SS) = if IL =/= nil and SS =/= none
                      then '`, ' 
                      else nil
                      fi .
  
  op comma : ImportList SortSet SubsortDeclSet -> QidList .
  eq comma(IL, SS, SSDS) = if (IL =/= nil or SS =/= none) and SSDS =/= none
                           then '`, ' 
                           else nil
                           fi .
  
  op comma : ImportList SortSet SubsortDeclSet OpDeclSet -> QidList .
  eq comma(IL, SS, SSDS, ODS) = 
          if (IL =/= nil or SS =/= none or SSDS =/= none) and ODS =/= none
          then '`, ' 
          else nil
          fi .
  
  op comma : ImportList SortSet SubsortDeclSet OpDeclSet MembAxSet -> QidList .
  eq comma(IL, SS, SSDS, ODS, MAS) = 
          if (IL =/= nil or SS =/= none or SSDS =/= none or ODS =/= none) and MAS =/= none
          then '`, ' 
          else nil
          fi .

  op comma : ImportList SortSet SubsortDeclSet OpDeclSet MembAxSet
             EquationSet -> QidList .
  eq comma(IL, SS, SSDS, ODS, MAS, EqS) = 
          if (IL =/= nil or SS =/= none or SSDS =/= none or ODS =/= none or MAS =/= none)
             and EqS =/= none
          then '`, ' 
          else nil
          fi .

  op comma : ImportList SortSet SubsortDeclSet OpDeclSet MembAxSet
             EquationSet RuleSet -> QidList .
  eq comma(IL, SS, SSDS, ODS, MAS, EqS, RS) = 
          if (IL =/= nil or SS =/= none or SSDS =/= none or ODS =/= none
              or MAS =/= none or EqS =/= none) and RS =/= none
          then '`, ' 
          else nil
          fi .

  op qid2token : Qid -> QidList .
  eq qid2token(Q) = qid("\"" + specialCharacters(string(Q)) + "\"") .
  
  op specialCharacters : String -> String .
  eq specialCharacters(STR) = stringScape(backslash(STR)) .
  
  op backslash : String -> String .
  ceq backslash(STR) = STR1 + "\\\\" + backslash(STR2)
   if N := find(STR, "\\", 0) /\
      STR1 := substr(STR, 0, N) /\
      STR2 := substr(STR, N + 1, length(STR)) .
  eq backslash(STR) = STR [owise] .
  
  op stringScape : String -> String .
  ceq stringScape(STR) = STR1 + "\\\"" + stringScape(STR2)
   if N := find(STR, "\"", 0) /\
      STR1 := substr(STR, 0, N) /\
      STR2 := substr(STR, N + 1, length(STR)) .
  eq stringScape(STR) = STR [owise] .

  op nat2qid : Nat -> Qid .
  eq nat2qid(N) = qid(string(N, 10)) .
  
  op haskellifyNatList : NatList -> QidList .
  eq haskellifyNatList(nil) = nil .
  eq haskellifyNatList(N NL) = nat2qid(N) comma(NL)
                               haskellifyNatList(NL) .

  op comma : NatList -> QidList .
  eq comma((nil).NatList) = nil .
  eq comma(NL) = '`, ' [owise] .
 endfm
 
 