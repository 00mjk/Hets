{- |
Module      :  $Header$
Description :  colimit of an arbitrary diagram in Set
Copyright   :  (c) Mihai Codescu, and Uni Bremen 2002-2006
License     :  similar to LGPL, see HetCATS/LICENSE.txt or LIZENZ.txt
Maintainer  :  mcodescu@informatik.uni-bremen.de
Stability   :  provisional
Portability :  portable

Computes the colimit of an arbitrary diagram in Set:
  - the set is the disjoint union of all sets in the diagram
    (which we obtain by pairing elements with the node number)
    factored by the equivalence generated by the pairs (x, f_i(x)),
    with i an arrow in the diagram
  - structural morphisms are factorizations

-}

module Common.SetColimit(
    computeColimitSet
  , updateComp
  , initialDegrees
  , updateDegrees
  , orderByIncomingEdges
  )
 where

import Common.Lib.Graph
import Data.Graph.Inductive.Graph
import qualified Data.Map as Map
import qualified Data.Set as Set
import Data.List

compose :: (Ord a) => Set.Set (a, Int) ->
                      Map.Map (a, Int) (a, Int) ->
                      Map.Map (a, Int) (a, Int) ->
                      Map.Map (a, Int) (a, Int)
compose s f g = Map.fromList $
                map (\x -> let y = Map.findWithDefault x x f in
                            (x, Map.findWithDefault y y g))
                $ Set.toList s

coeq :: (Ord a) =>
        Set.Set (a, Int) -> Set.Set (a, Int) ->
        Map.Map (a, Int) (a, Int) -> Map.Map (a, Int) (a, Int) ->
        (Set.Set (a, Int), Map.Map (a,Int) (a, Int))
coeq sSet tSet f1 f2 =
 case Set.elems sSet of
   [] -> (tSet, Map.empty)
   x:xs -> if null xs then let
             f1x = Map.findWithDefault x x f1
             f2x = Map.findWithDefault x x f2
            in if f1x == f2x then (tSet, Map.empty)
                else (Set.difference tSet $ Set.singleton f2x,
                      Map.fromList [(f2x, f1x)])
           else let
             a1 = Set.singleton x
             a2 = Set.difference sSet a1
             (c, cf) = coeq a1 tSet f1 f2
             cf1 = compose a2 f1 cf
             cf2 = compose a2 f2 cf
             (d, df) = coeq a2 c cf1 cf2
             coeqf = compose tSet cf df
            in (d, coeqf)

computeColimitSet :: (Ord a) =>
                     Gr (Set.Set a) (Int, Map.Map a a) ->
                     (Set.Set (a, Node), Map.Map Node (Map.Map a (a, Node)))
computeColimitSet graph = let
   unionSet = foldl Set.union Set.empty $
               map (\(n, s) -> Set.map (\x -> (x, n)) s) $ labNodes graph
   inclMap = Map.fromList $ map (\ (n, _) ->(n, Map.empty)) $ labNodes graph
   (colim, morMap) = computeCoeqs graph (unionSet, inclMap) $ labEdges graph
   morMap' = Map.map
               (\f -> Map.fromList $ map (\((x,_),z) -> (x,z))$  Map.toList f)
               morMap
  in (colim, morMap')

computeCoeqs :: (Ord a) =>
      Gr (Set.Set a) (Int, Map.Map a a) ->
      (Set.Set (a, Node), Map.Map Node (Map.Map (a, Node) (a, Node))) ->
      [LEdge (Int, Map.Map a a)] ->
      (Set.Set (a, Node), Map.Map Node (Map.Map (a, Node) (a, Node)))
computeCoeqs graph (colim, morMap) edgeList =
  case edgeList of
   [] -> (colim, morMap)
   (sn, tn, (_, f)):edges' -> let
     Just sset = lab graph sn
     f1 = morMap Map.! sn
     f' = Map.fromList $ map (\x -> ((x,sn),(Map.findWithDefault x x f, tn))) $
          Set.toList sset
     f2 = Map.map (\x -> Map.findWithDefault x  x (morMap Map.! tn)) f'
     (colim', coeqMor) = coeq (Set.map (\x -> (x, sn)) sset) colim f1 f2
     morMap' = Map.fromList $
               map (\(n, g) ->let
                     Just nset = lab graph n
                              in(n, Map.fromList $
                               map (\x -> let
                                      y = Map.findWithDefault x x g
                                     in (x,Map.findWithDefault y y coeqMor)) $
                               Set.toList $ Set.map (\x-> (x,n)) nset ))
               $ Map.toList  morMap
    in computeCoeqs graph (colim', morMap') edges'

---------

-- functions needed in CASL/ColimSign
-- will be probably removed after ColimSign is reimplemented

--mapping assigning to each node the number of incoming edges
--will be updated when choosing a node
initialDegrees :: Gr a b -> Map.Map Node Int
initialDegrees graph = let nodeList = nodes graph in
  Map.fromList $ zip nodeList $ map (indeg graph) nodeList

--decrease the number of incoming edges for all the successors of a node
updateDegrees :: Gr a b -> Node -> Map.Map Node Int -> Map.Map Node Int
updateDegrees graph hnode incomEdges = let
  nList = suc graph hnode
  insertFromList f list = case list of
    [] -> f
    x:xs -> let oldValue = (Map.!) f x
                f1 = Map.insert x (oldValue-1) f
            in insertFromList f1 xs
 in insertFromList incomEdges nList

orderByIncomingEdges :: [Node] -> Gr a b -> Map.Map Node Int -> [Node]
orderByIncomingEdges [] _ _ = []
orderByIncomingEdges (x:xs) gr incomEdges =
 ( orderByIncomingEdges
   (filter (\z->((Map.!) incomEdges z) <= ((Map.!) incomEdges x))xs)
   gr incomEdges) ++ [x] ++
 ( orderByIncomingEdges
   (filter (\z->((Map.!) incomEdges z) > ((Map.!) incomEdges x))xs)
   gr incomEdges)

--updates the value in a key
-- of a function assigned to a key by a higher order function
updateComp :: (Ord a, Ord c) => a -> b -> c -> Map.Map c (Map.Map a b)
  -> Map.Map c (Map.Map a b)
updateComp x1 y1 x f =
  let fx = Map.insert x1 y1 ((Map.!) f x)
  in Map.insert x fx f




