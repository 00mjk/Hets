{-# LANGUAGE ViewPatterns #-}
module PLpatt.StaticAnaPLpatt
    where

import qualified PLpatt.AS_BASIC_PLpatt as As
import qualified PLpatt.Sign as Sign
import PLpatt.Tools
import Common.AS_Annotation
import Common.GlobalAnnotations
import Common.Result
import Common.ExtSign
import Common.Id
import Data.Maybe
import qualified Data.Set as Set
import System.IO.Unsafe
import qualified MMT.XMLtoPT as XML
import qualified MMT.Tools as PT
import System.IO.Temp
import System.IO
import qualified MMT.Hets2mmt as MMT
import Data.List
import qualified Data.Map as Map
import System.Directory (removeFile)
import Common.Utils (getEnvDef)

basicAna :: (As.Basic_spec, Sign.Sigs, GlobalAnnos) -> 
                Result(
                  As.Basic_spec,
                  ExtSign Sign.Sigs As.Symb,
                  [Named As.Bool']
                )
basicAna (bs, Sign.Sigs sg, ann) = let
                                 namespace = "http://cds.omdoc.org/hets-test"
                                 newsg = mmtAna namespace bs
                                 sgn = ExtSign (Sign.Sigs (newsg ++ sg))
                                               Set.empty
                                 nst = []
                                 in
                                 return (bs, sgn, nst)

{-
getSens :: Sign.Sigs -> [Named As.Bool']
getSens (Sign.Sigs decls) = map sentences decls

sentences :: As.Decl -> Named As.Bool'
sentences (As.Dot_decl (As.Dot (name sen))) = name sen
-}
-- logic id is generated by MMT
lid :: String
lid = "PLpatt"

hetslib :: String
hetslib = unsafePerformIO $ getEnvDef "HETS_LIB" ""

mmtAna :: String -> As.Basic_spec -> [As.Decl]
mmtAna namespace (As.Basic_spec bs) = let
                          decls = unsafePerformIO $
                                  getDecls namespace bs
                          in
                          map (fromJust . maybeResult) decls


gs :: String
gs = "\29"

us :: String
us = "\31"

rs :: String
rs = "\30"


-- compile lines into a temp file
compileMMTsrc :: String -> [String] -> IO (FilePath)
compileMMTsrc ns rest = do
                           let cont = "namespace " ++ ns ++ gs ++ "\n" ++
                                      "theory " ++ lid ++ "spec : " ++
                                      "?" ++ lid ++
                                      " = \n" ++ 
                                      "\n" ++ (unlines rest) ++ "\n" ++ gs
                           (fpath, fhand) <- openTempFile "MMTtmp"
                                                          "input.mmt"
                           hPutStr fhand cont
                           hClose fhand
                           return fpath

-- sort declarations
arrangeFileSrc :: String -> [String] -> [String]
arrangeFileSrc (stripPrefix "namespace" -> Just uri)  ls = ("namespace" ++ uri) : ls
arrangeFileSrc s ls = ls ++ [s]

-- grab namespace uri
getNamespace :: String -> Maybe String
getNamespace (stripPrefix "namespace " -> Just uri) = Just uri
getNamespace s = Nothing

getDecls :: String -> [String] -> IO ([Result As.Decl])
getDecls ns sl = do
           fp <- compileMMTsrc ns sl
           MMT.callSpec fp
           -- removeFile fp
           rsdcl <- XML.parse $ hetslib ++ "MMT/xml/" ++ lid ++ "spec.xml"
           let decls = map decl2decl rsdcl
           return decls

{- helper method that translates 
   parse tree declarations to logic declarations -}
decl2decl :: Result PT.Decl -> Result As.Decl
decl2decl rs = let dcl = maybeResult rs
                in
                case dcl of
                Just(mbds) -> case decl_from_pt mbds of
                              (Just ds) -> Result [] (Just ds )
                              Nothing -> fatal_error
                                          "failed to parse parse-tree"
                                          nullRange
                Nothing -> fatal_error "Result of parse tree failure"
                                        nullRange
