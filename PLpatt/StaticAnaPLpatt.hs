module PLpatt.StaticAnaPLpatt
    where

import qualified PLpatt.AS_BASIC_PLpatt as As
--import THF.Cons
--import THF.Print ()
import qualified PLpatt.Sign as Sign
import PLpatt.Tools
--import THF.Poly (type_check)
--import THF.Utils (thfTopLevelTypeToType)

import Common.AS_Annotation
import Common.GlobalAnnotations
import Common.Result
import Common.ExtSign
import Common.Lib.State
import Common.DocUtils

import Control.Monad
import Common.Id

import Data.Maybe
--import qualified Data.Map as Map
import qualified Data.Set as Set
import System.IO.Unsafe
import qualified MMT.XMLtoPT as XML
import qualified MMT.Tools as PT
import System.IO.Temp
import System.IO-- (hPutStr)
import System.Directory

import Debug.Trace

basicAna :: (As.Basic_spec, Sign.Sigs, GlobalAnnos) -> 
                Result(
                  As.Basic_spec,
                  ExtSign Sign.Sigs As.Symb,
                  [Named As.Bool']
                )
basicAna (bs, Sign.Sigs sg, _) = trace "running basicAna" $ Result [] (Just(As.Basic_spec [], ExtSign (Sign.Sigs []) Set.empty, []))

{-let
                                 --newsg = mmtAna bs
                                 --sgn = ExtSign (Sign.Sigs (sg ++ newsg))
                                 --              Set.empty
                                 sgn = ExtSign (Sign.Sigs []) Set.empty
                                 nst = []
                                 in
                                 trace "\nrunning basicAna\n" Result [] (Just(As.Basic_spec [], sgn, []))
                                 -}

-- logic id is generated by MMT
lid :: String
lid = "PLpatt"

-- staticAnaMMT :: [String] -> () -- > Sign.Sigs
--staticAnaMMT s = unsafePerformIO $ coimpileMMTsrc s

mmtAna :: As.Basic_spec -> [As.Decl]
mmtAna (As.Basic_spec bs) = let
                          decls = unsafePerformIO $
                                  getDecls bs
                          in
                          map (fromJust . maybeResult) decls


-- compile lines into a temp file
compileMMTsrc :: [String] -> IO (FilePath)
compileMMTsrc s = do
                  let cont = "theory Spec: " ++ lid ++ 
                             "\n{\n" ++ (unlines s) ++ "\n}"
                  (fpath, fhand) <- openTempFile "MMTtmp"
                                                 "input.elf"
                  print $ cont ++ " ===>> " ++ fpath
                  hPutStr fhand cont
                  hClose fhand
                  return fpath

getDecls :: [String] -> IO ([Result As.Decl])
getDecls sl = do
           print "calling getDecls\n"
           fp <- compileMMTsrc sl
           rsdcl <- XML.parse fp
           putStr $ "\nCalling decl2decl on " ++ (show rsdcl)
           let decls = map decl2decl rsdcl
           -- remove tmp file?
           return decls

{- helper method that translates 
   parse tree declarations to logic declarations -}
decl2decl :: Result PT.Decl -> Result As.Decl
decl2decl rs = let dcl = maybeResult rs
                in
                case dcl of
                Just(mbds) -> case decl_from_pt mbds of
                              (Just ds) -> Result [] (Just ds )
                              Nothing -> fatal_error
                                          "failed to parse parse-tree"
                                          nullRange
                Nothing -> fatal_error "Result of parse tree failure"
                                        nullRange
