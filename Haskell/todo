Hatchet einbinden

In neuem Modul (Haskell2DG):
- top level Funktion wie die aus Static/AnalysisLibrary.hs
anaHaskellFile :: HetcatsOpts -> String -- filename
              -> IO (Maybe (LIB_NAME, -- filename
                            HsModule, -- as tree
                            DGraph, -- development graph
                            LibEnv -- DGraphs für importierte Module
                           ))
- Datentyp anlegen für HaskellEnv (Resultat von tiModule)
- anaHaskellFile benötigt Funktion, die ein HaskellEnv in einen
  DGraph konvertiert (siehe Statc/DevGaph.hs)
  Graph-Bibliothek (functional graph library, fgl): Common/Lib/Graph
  Knoten: sind die Haskell-Module
    dgn_name = Modulname
    dgn_sign = Signatur (HsDecls)
    dgn_sens = Programmdefs
    dgn_origin = DGBasic (bei keinen Importen)
               = DGExtension (bei Importen)
  Kanten: entlang der Modul-Importe (d.h. vom importierten zum Importeur)
   dgl_morphism = ()  (siehe Logic_Haskell.hs)
   dgl_type = GlobalDef, wenn nichts versteckt wird
            = HidingDef, wenn etwas versteckt wird
   dgl_origin = DGExtension

ATerm-Instanzen: Klaus fragen

In Logic_Haskell.hs: 
- Sign durch Datentyp für Ergebnis des Typcheck ersetzen ("Interface-Files")
- Sentence durch Datentyp für Programmdefinitionen ersetzen
- in instance StaticAnalysis Funktion basic_analysis hinzufügen   
  berechnet aus abstraktem Syntaxbaum die Typen der Funktionen
    und guckt ob alle benutzten Identifier auch deklariert wurden
  basic_analysis ist also ein Wrapper um eine Hatchet-Funktion
- Für basic_analysis muss Hatchet-Funktion tiModule reduizert werden
  auf Analyse des Moduls (d.h. keine Analyse der Importe)

   basic_analysis :: lid -> -- ignorieren
                           Maybe((basic_spec,  -- abstract syntax tree
                            sign,   -- was von importierten Modulen reinkommt
                            GlobalAnnos) ->   -- global annotations
                           Result (basic_spec,  -- renamed module
                                  sign,sign, -- (gesamt, delta)
                                  -- delta = Deklarationen im Modul
                                  -- gesamt = importiert + delta 
                                            (mittels Vereinigungsfunktion)
                                  [Named sentence] -- Programmdefinitionen))

tiModule :: [String]                    -- dump flags
         -> AHsModule                   -- syntax of module after parsing
                                            das ist basic_spec
         -> ModuleInfo                  -- info about imported entities
                                            das ist sign
         -> IO (Timing,              -- timing values for each stage
                Env Scheme,          -- output variable assumptions (may be local, and pattern variables)
                Env Scheme,          -- output data cons assumptions
                ClassHierarchy,      -- output class Hierarchy
                KindEnv,             -- output kinds
                IdentTable,          -- info about identifiers in the module
                AHsModule,           -- renamed module (als basic_spec
                                         zurückgeben + sentences extrahieren)
                [AHsDecl])           -- synonyms defined in this module

sign = ModuleInfo, aus der tiModule-Ausgabe konstruieren wie in Main.hs


type AxiomName = String

data Binding
--  = NullBind
  = AndBindings    Binding Binding
  | AxiomDecl      AxiomName Formula
  deriving (Eq,Show)

data AxiomBndr
 = AxiomBndr HsName
 | AxiomBndrSig HsName HsQualType
  deriving (Eq,Show)

data Quantifier
  = AxForall [AxiomBndr]
   | AxExists [AxiomBndr]
   | AxExistsOne [AxiomBndr]
  deriving (Eq,Show)

data Formula
  = AxQuant   Quantifier Formula
  | AxEq      Formula HsExp SrcLoc
  | AxExp     HsExp
  deriving (Eq,Show)

Erweiterung der statischen Analyse auf Formula, d.h.
tiFormula ::  TypeEnv -> Formula -> TI ([Pred], TypeEnv, Type)

unter Benutzung von tiExpr

Analyse von "AxQuant   Quantifier Formula" ähnlich wie 
  tiExpr env expr@(AHsLambda sloc pats e)

tiFormula an geeigneter Stelle in tiProgram (oder Unterfunktion davon)
einbinden