Hatchet einbinden

In neuem Modul (Haskell2DG):
- insImports mit Resultat IO DGraph, oder besser: IO (LIB_NAME,LibEnv)
  importierte Module mit anaHaskellFile behandeln (rekursiv)
  Für jedes importierte Modul erhält man (ln,lenv) => mit lookup (ln,lenv)
   erhält man einen GlobalContext  = (GlobalAnnos,GlobalEnv,DGraph)
  DGraphen der importierten Module vereinigen zu großem DGraph G
  Knoten aus den GlobalEnvs sind die Hauptknoten der importierten
  Module. Von da aus Links zu Knoten für Hauptmodul legen (als Erweiterung von G).

- bevor ein importiertes Modul rekursiv mit anaHaskellFile bearbeitet wird,
  zunächst gucken, ob es schon im LibEnv verzeichnet ist, dann kann
  anaHaskellFile entfallen, stattdessen direkt Infos aus LibEnv rausholen

- globale Einbindung: siehe Kommentare zu processFile in hets.hs
LibEnv: pro Modul (inkl. Hauptmodul) ein GlobalContext

GlobalContext:
GlobalAnnos können erstmal leer sein, weil es in Haskell da nichts
vergleichbares gibt. (Evtl. könnten später die Deklarationen von
Infix-Operatoren und Prioritäten da rein kommen).
Das GlobalEnv ordnet in CASL jeder Spezifikation einen Knoten
im DGraph zu. Allerdings haben wir bei Haskell pro File nur eine
"Spezifikation" (nämlich das Programm-Modul). Also muss das GlobalEnv
hier einfach nur einen Eintrag haben, der dem Namen des Programm-Moduls
den Knoten des Programm-Moduls im DGraph zuordnet. Das kannst du
erzeugen mit

Map.insert name (SpecEntry (imp,params,parsig,body)) Map.empty

wobei name der Namen des Programm-Moduls ist, und
imp = EmptyNode und parsig als empty_signature Haskell gewählt werden können,
und params = []. body = NodeSig(n,sig), wobei n der Knoten im Entwicklungsgraph
und sig die Signatur ist (beides jeweils die für das Programm-Modul).


- top level Funktion wie die aus Static/AnalysisLibrary.hs
anaHaskellFile :: HetcatsOpts -> String -- filename
              -> IO (Maybe (LIB_NAME, -- filename
                            HsModule, -- as tree
                            DGraph, -- development graph
                            LibEnv -- DGraphs für importierte Module
                           ))
- Datentyp anlegen für HaskellEnv (Resultat von tiModule)
- anaHaskellFile benötigt Funktion, die ein HaskellEnv in einen
  DGraph konvertiert (siehe Statc/DevGaph.hs)
  Graph-Bibliothek (functional graph library, fgl): Common/Lib/Graph
  Knoten: sind die Haskell-Module
    dgn_name = Modulname
    dgn_sign = Signatur (HsDecls)
    dgn_sens = Programmdefs
    dgn_origin = DGBasic (bei keinen Importen)
               = DGExtension (bei Importen)
  Kanten: entlang der Modul-Importe (d.h. vom importierten zum Importeur)
   dgl_morphism = ()  (siehe Logic_Haskell.hs)
   dgl_type = GlobalDef, wenn nichts versteckt wird
            = HidingDef, wenn etwas versteckt wird
   dgl_origin = DGExtension

ATerm-Instanzen: Klaus fragen

In Logic_Haskell.hs: 
- empty_signature implementieren: "alles leer" (ohne Prelude)
- importierte Module müssen nicht eingelesenw werden, 
    stattdessen übergebene sig benutzen
- Funktion(Konstante) für Prelude-Signatur bereitstellen

- in instance StaticAnalysis Funktion basic_analysis hinzufügen   
  berechnet aus abstraktem Syntaxbaum die Typen der Funktionen
    und guckt ob alle benutzten Identifier auch deklariert wurden
  basic_analysis ist also ein Wrapper um eine Hatchet-Funktion
- Für basic_analysis muss Hatchet-Funktion tiModule reduizert werden
  auf Analyse des Moduls (d.h. keine Analyse der Importe)

   basic_analysis :: lid -> -- ignorieren
                           Maybe((basic_spec,  -- abstract syntax tree
                            sign,   -- was von importierten Modulen reinkommt
                            GlobalAnnos) ->   -- global annotations
                           Result (basic_spec,  -- renamed module
                                  sign,sign, -- (gesamt, delta)
                                  -- delta = Deklarationen im Modul
                                  -- gesamt = importiert + delta 
                                            (mittels Vereinigungsfunktion)
                                  [Named sentence] -- Programmdefinitionen))

tiModule :: [String]                    -- dump flags
         -> AHsModule                   -- syntax of module after parsing
                                            das ist basic_spec
         -> ModuleInfo                  -- info about imported entities
                                            das ist sign
         -> IO (Timing,              -- timing values for each stage
                Env Scheme,          -- output variable assumptions (may be local, and pattern variables)
                Env Scheme,          -- output data cons assumptions
                ClassHierarchy,      -- output class Hierarchy
                KindEnv,             -- output kinds
                IdentTable,          -- info about identifiers in the module
                AHsModule,           -- renamed module (als basic_spec
                                         zurückgeben + sentences extrahieren)
                [AHsDecl])           -- synonyms defined in this module

sign = ModuleInfo, aus der tiModule-Ausgabe konstruieren wie in Main.hs


type AxiomName = String

data Binding
--  = NullBind
  = AndBindings    Binding Binding
  | AxiomDecl      AxiomName Formula
  deriving (Eq,Show)

data AxiomBndr
 = AxiomBndr HsName
 | AxiomBndrSig HsName HsQualType
  deriving (Eq,Show)

data Quantifier
  = AxForall [AxiomBndr]
   | AxExists [AxiomBndr]
   | AxExistsOne [AxiomBndr]
  deriving (Eq,Show)

data Formula
  = AxQuant   Quantifier Formula
  | AxEq      Formula HsExp SrcLoc
  | AxExp     HsExp
  deriving (Eq,Show)

Erweiterung der statischen Analyse auf Formula, d.h.
tiFormula ::  TypeEnv -> Formula -> TI ([Pred], TypeEnv, Type)

unter Benutzung von tiExpr

Analyse von "AxQuant   Quantifier Formula" ähnlich wie 
  tiExpr env expr@(AHsLambda sloc pats e)

tiFormula an geeigneter Stelle in tiProgram (oder Unterfunktion davon)
einbinden


Zeilennummern in Hatchet-Parser einbauen (neue Version angucken)