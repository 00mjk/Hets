Poly/ML RTS version I386-4.1.4 (14:18:30 Nov 14 2005)
Copyright (c) 2002-5 CUTS and contributors.
Running with heap parameters (h=30000K,ib=6000K,ip=100%,mb=10096K,mp=20%)
Mapping /local/mirror/linux-bkb/Isabelle/Isabelle2005/heaps/polyml-4.1.4_x86-linux/HOL
Mapping /home/linux-bkb/Isabelle/polyml-4.1.4/x86-linux/ML_dbase
Poly/ML 4.2.0 Release
> val it = () : unit
Loading theory "HsHOL" (required by "ex_class_h")
### Specification of constant HsHOL.hEq :: "bool => bool => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hNEq :: "bool => bool => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hEq :: "int => int => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hNEq :: "int => int => bool"
### is strictly less general than the declared type
### Occurrences of recursive constant have non-unifiable types
### Specification of constant HsHOL.hEq :: "'a list => 'a list => bool"
### is strictly less general than the declared type
Proving equations for primrec function(s) "HsHOL.hEq" ...
### Specification of constant HsHOL.hNEq :: "'a list => 'a list => bool"
### is strictly less general than the declared type
Loading theory "ex_class_h"
structure Header :
  sig val initialize : string list -> unit val record : string -> unit end
val it = () : unit
Proofs for datatype(s) "Prelude_MPList"
Constructing representing sets ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the induction rule ...
Proving isomorphism properties ...
Proving freeness of constructors ...
Proving induction rule for datatypes ...
Proving case distinction theorems ...
Constructing primrec combinators ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
Proving termination and uniqueness of primrec functions ...
Proving characteristic theorems for primrec combinators ...
Proving characteristic theorems for case combinators ...
Proving equations for case splitting ...
Proving additional theorems for TFL ...
Proving equations for size function ...
Proofs for datatype(s) "Prelude_Color"
Constructing representing sets ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the induction rule ...
Proving isomorphism properties ...
Proving freeness of constructors ...
Proving induction rule for datatypes ...
Proving case distinction theorems ...
Constructing primrec combinators ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
Proving termination and uniqueness of primrec functions ...
Proving characteristic theorems for primrec combinators ...
Proving characteristic theorems for case combinators ...
Proving equations for case splitting ...
Proving additional theorems for TFL ...
Proving equations for size function ...
Proofs for datatype(s) "Prelude_MyList"
Constructing representing sets ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the induction rule ...
Proving isomorphism properties ...
Proving freeness of constructors ...
Proving induction rule for datatypes ...
Proving case distinction theorems ...
Constructing primrec combinators ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
Proving termination and uniqueness of primrec functions ...
Proving characteristic theorems for primrec combinators ...
Proving characteristic theorems for case combinators ...
Proving equations for case splitting ...
Proving additional theorems for TFL ...
Proving equations for size function ...
### Interactive-only command "sorry" (line 51 of "/home/maeder/haskell/HetCATS/Haskell/test/HOL/ex_class_h.thy")
*** Proof may be skipped in quick_and_dirty mode only!
*** At command "sorry" (line 51 of "/home/maeder/haskell/HetCATS/Haskell/test/HOL/ex_class_h.thy").
Exception- ERROR raised
val it = () : unit
val it =
   {ProtoPure, Pure, CPure, HOL, Lattice_Locales, Orderings, LOrder, Set,
     Typedef, Fun, Product_Type, FixedPoint, Sum_Type, Relation, Record,
     Inductive, Transitive_Closure, Wellfounded_Recursion, OrderedGroup,
     Ring_and_Field, Nat, NatArith, Datatype_Universe, Datatype, Divides,
     Power, Finite_Set, Wellfounded_Relations, Equiv_Relations, IntDef,
     Numeral, IntArith, SetInterval, Recdef, IntDiv, NatBin, NatSimprocs,
     Presburger, Relation_Power, Parity, GCD, Binomial, PreList, List, Map,
     Refute, SAT, Hilbert_Choice, Infinite_Set, Extraction, Reconstruction,
     Main, HsHOL, #} : Theory.theory
val it = [] : (string * Thm.thm) list
Poly/ML RTS version I386-4.1.4 (14:18:30 Nov 14 2005)
Copyright (c) 2002-5 CUTS and contributors.
Running with heap parameters (h=30000K,ib=6000K,ip=100%,mb=10096K,mp=20%)
Mapping /local/mirror/linux-bkb/Isabelle/Isabelle2005/heaps/polyml-4.1.4_x86-linux/HOL
Mapping /home/linux-bkb/Isabelle/polyml-4.1.4/x86-linux/ML_dbase
Poly/ML 4.2.0 Release
> val it = () : unit
Loading theory "HsHOL" (required by "ex_let_h")
### Specification of constant HsHOL.hEq :: "bool => bool => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hNEq :: "bool => bool => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hEq :: "int => int => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hNEq :: "int => int => bool"
### is strictly less general than the declared type
### Occurrences of recursive constant have non-unifiable types
### Specification of constant HsHOL.hEq :: "'a list => 'a list => bool"
### is strictly less general than the declared type
Proving equations for primrec function(s) "HsHOL.hEq" ...
### Specification of constant HsHOL.hNEq :: "'a list => 'a list => bool"
### is strictly less general than the declared type
Loading theory "ex_let_h"
structure Header :
  sig val initialize : string list -> unit val record : string -> unit end
val it = () : unit
val it = () : unit
val it = () : unit
val it =
   {ProtoPure, Pure, CPure, HOL, Lattice_Locales, Orderings, LOrder, Set,
     Typedef, Fun, Product_Type, FixedPoint, Sum_Type, Relation, Record,
     Inductive, Transitive_Closure, Wellfounded_Recursion, OrderedGroup,
     Ring_and_Field, Nat, NatArith, Datatype_Universe, Datatype, Divides,
     Power, Finite_Set, Wellfounded_Relations, Equiv_Relations, IntDef,
     Numeral, IntArith, SetInterval, Recdef, IntDiv, NatBin, NatSimprocs,
     Presburger, Relation_Power, Parity, GCD, Binomial, PreList, List, Map,
     Refute, SAT, Hilbert_Choice, Infinite_Set, Extraction, Reconstruction,
     Main, HsHOL, ex_let_h} : Theory.theory
val it =
   [("ex_let_h.foon_def",
         "foon ==
            %a b c.
               let testName1 = myEqual a b
               in Let (myEqual b c) (op & testName1)"),
      ("ex_let_h.myEqual_def",
         "myEqual == %x y. if hEq x y then True else False")]
: (string * Thm.thm) list
Poly/ML RTS version I386-4.1.4 (14:18:30 Nov 14 2005)
Copyright (c) 2002-5 CUTS and contributors.
Running with heap parameters (h=30000K,ib=6000K,ip=100%,mb=10096K,mp=20%)
Mapping /local/mirror/linux-bkb/Isabelle/Isabelle2005/heaps/polyml-4.1.4_x86-linux/HOL
Mapping /home/linux-bkb/Isabelle/polyml-4.1.4/x86-linux/ML_dbase
Poly/ML 4.2.0 Release
> val it = () : unit
Loading theory "HsHOL" (required by "ex_list_h")
### Specification of constant HsHOL.hEq :: "bool => bool => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hNEq :: "bool => bool => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hEq :: "int => int => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hNEq :: "int => int => bool"
### is strictly less general than the declared type
### Occurrences of recursive constant have non-unifiable types
### Specification of constant HsHOL.hEq :: "'a list => 'a list => bool"
### is strictly less general than the declared type
Proving equations for primrec function(s) "HsHOL.hEq" ...
### Specification of constant HsHOL.hNEq :: "'a list => 'a list => bool"
### is strictly less general than the declared type
Loading theory "ex_list_h"
structure Header :
  sig val initialize : string list -> unit val record : string -> unit end
val it = () : unit
Proving equations for primrec function(s) "ex_list_h.myMap" ...
val it = () : unit
val it = () : unit
val it =
   {ProtoPure, Pure, CPure, HOL, Lattice_Locales, Orderings, LOrder, Set,
     Typedef, Fun, Product_Type, FixedPoint, Sum_Type, Relation, Record,
     Inductive, Transitive_Closure, Wellfounded_Recursion, OrderedGroup,
     Ring_and_Field, Nat, NatArith, Datatype_Universe, Datatype, Divides,
     Power, Finite_Set, Wellfounded_Relations, Equiv_Relations, IntDef,
     Numeral, IntArith, SetInterval, Recdef, IntDiv, NatBin, NatSimprocs,
     Presburger, Relation_Power, Parity, GCD, Binomial, PreList, List, Map,
     Refute, SAT, Hilbert_Choice, Infinite_Set, Extraction, Reconstruction,
     Main, HsHOL, ex_list_h} : Theory.theory
val it =
   [("ex_list_h.funOne_def",
         "funOne == %x y. if hEq x (hd x # tl y) then True else False"),
      ("ex_list_h.myMap.myMap_list_def",
         "myMap == list_rec (%f. []) (%pX1 pX2 pX2a f. f pX1 # pX2a f)")]
: (string * Thm.thm) list
Poly/ML RTS version I386-4.1.4 (14:18:30 Nov 14 2005)
Copyright (c) 2002-5 CUTS and contributors.
Running with heap parameters (h=30000K,ib=6000K,ip=100%,mb=10096K,mp=20%)
Mapping /local/mirror/linux-bkb/Isabelle/Isabelle2005/heaps/polyml-4.1.4_x86-linux/HOL
Mapping /home/linux-bkb/Isabelle/polyml-4.1.4/x86-linux/ML_dbase
Poly/ML 4.2.0 Release
> val it = () : unit
Loading theory "HsHOL" (required by "Map2_h")
### Specification of constant HsHOL.hEq :: "bool => bool => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hNEq :: "bool => bool => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hEq :: "int => int => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hNEq :: "int => int => bool"
### is strictly less general than the declared type
### Occurrences of recursive constant have non-unifiable types
### Specification of constant HsHOL.hEq :: "'a list => 'a list => bool"
### is strictly less general than the declared type
Proving equations for primrec function(s) "HsHOL.hEq" ...
### Specification of constant HsHOL.hNEq :: "'a list => 'a list => bool"
### is strictly less general than the declared type
Loading theory "Map2_h"
structure Header :
  sig val initialize : string list -> unit val record : string -> unit end
val it = () : unit
Proving equations for primrec function(s) "Map2_h.map1" ...
Proving equations for primrec function(s) "Map2_h.map2" ...
val it = () : unit
val it = () : unit
val it =
   {ProtoPure, Pure, CPure, HOL, Lattice_Locales, Orderings, LOrder, Set,
     Typedef, Fun, Product_Type, FixedPoint, Sum_Type, Relation, Record,
     Inductive, Transitive_Closure, Wellfounded_Recursion, OrderedGroup,
     Ring_and_Field, Nat, NatArith, Datatype_Universe, Datatype, Divides,
     Power, Finite_Set, Wellfounded_Relations, Equiv_Relations, IntDef,
     Numeral, IntArith, SetInterval, Recdef, IntDiv, NatBin, NatSimprocs,
     Presburger, Relation_Power, Parity, GCD, Binomial, PreList, List, Map,
     Refute, SAT, Hilbert_Choice, Infinite_Set, Extraction, Reconstruction,
     Main, HsHOL, Map2_h} : Theory.theory
val it =
   [("Map2_h.map1.map1_list_def",
         "map1 ==
            %u ua.
               list_rec (%qX1. []) (%pX1 pX2 pX2a qX1. qX1 pX1 # pX2a qX1) ua
                u"),
      ("Map2_h.map2.map2_list_def",
         "map2 ==
            %u ua.
               list_rec (%f. []) (%pX1 pX2 pX2a f. f pX1 # pX2a f) ua u")]
: (string * Thm.thm) list
Poly/ML RTS version I386-4.1.4 (14:18:30 Nov 14 2005)
Copyright (c) 2002-5 CUTS and contributors.
Running with heap parameters (h=30000K,ib=6000K,ip=100%,mb=10096K,mp=20%)
Mapping /local/mirror/linux-bkb/Isabelle/Isabelle2005/heaps/polyml-4.1.4_x86-linux/HOL
Mapping /home/linux-bkb/Isabelle/polyml-4.1.4/x86-linux/ML_dbase
Poly/ML 4.2.0 Release
> val it = () : unit
Loading theory "HsHOL" (required by "mrec3_h")
### Specification of constant HsHOL.hEq :: "bool => bool => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hNEq :: "bool => bool => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hEq :: "int => int => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hNEq :: "int => int => bool"
### is strictly less general than the declared type
### Occurrences of recursive constant have non-unifiable types
### Specification of constant HsHOL.hEq :: "'a list => 'a list => bool"
### is strictly less general than the declared type
Proving equations for primrec function(s) "HsHOL.hEq" ...
### Specification of constant HsHOL.hNEq :: "'a list => 'a list => bool"
### is strictly less general than the declared type
Loading theory "mrec3_h"
structure Header :
  sig val initialize : string list -> unit val record : string -> unit end
val it = () : unit
Proofs for datatype(s) "Prelude_Boolx"
Constructing representing sets ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the induction rule ...
Proving isomorphism properties ...
Proving freeness of constructors ...
Proving induction rule for datatypes ...
Proving case distinction theorems ...
Constructing primrec combinators ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
Proving termination and uniqueness of primrec functions ...
Proving characteristic theorems for primrec combinators ...
Proving characteristic theorems for case combinators ...
Proving equations for case splitting ...
Proving additional theorems for TFL ...
Proving equations for size function ...
Proofs for datatype(s) "Prelude_Natx"
Constructing representing sets ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the induction rule ...
Proving isomorphism properties ...
Proving freeness of constructors ...
Proving induction rule for datatypes ...
Proving case distinction theorems ...
Constructing primrec combinators ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
Proving termination and uniqueness of primrec functions ...
Proving characteristic theorems for primrec combinators ...
Proving characteristic theorems for case combinators ...
Proving equations for case splitting ...
Proving additional theorems for TFL ...
Proving equations for size function ...
### Interactive-only command "sorry" (line 17 of "/home/maeder/haskell/HetCATS/Haskell/test/HOL/mrec3_h.thy")
*** Proof may be skipped in quick_and_dirty mode only!
*** At command "sorry" (line 17 of "/home/maeder/haskell/HetCATS/Haskell/test/HOL/mrec3_h.thy").
Exception- ERROR raised
val it = () : unit
val it =
   {ProtoPure, Pure, CPure, HOL, Lattice_Locales, Orderings, LOrder, Set,
     Typedef, Fun, Product_Type, FixedPoint, Sum_Type, Relation, Record,
     Inductive, Transitive_Closure, Wellfounded_Recursion, OrderedGroup,
     Ring_and_Field, Nat, NatArith, Datatype_Universe, Datatype, Divides,
     Power, Finite_Set, Wellfounded_Relations, Equiv_Relations, IntDef,
     Numeral, IntArith, SetInterval, Recdef, IntDiv, NatBin, NatSimprocs,
     Presburger, Relation_Power, Parity, GCD, Binomial, PreList, List, Map,
     Refute, SAT, Hilbert_Choice, Infinite_Set, Extraction, Reconstruction,
     Main, HsHOL, #} : Theory.theory
val it = [] : (string * Thm.thm) list
Poly/ML RTS version I386-4.1.4 (14:18:30 Nov 14 2005)
Copyright (c) 2002-5 CUTS and contributors.
Running with heap parameters (h=30000K,ib=6000K,ip=100%,mb=10096K,mp=20%)
Mapping /local/mirror/linux-bkb/Isabelle/Isabelle2005/heaps/polyml-4.1.4_x86-linux/HOL
Mapping /home/linux-bkb/Isabelle/polyml-4.1.4/x86-linux/ML_dbase
Poly/ML 4.2.0 Release
> val it = () : unit
Loading theory "HsHOL" (required by "mrec_h")
### Specification of constant HsHOL.hEq :: "bool => bool => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hNEq :: "bool => bool => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hEq :: "int => int => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hNEq :: "int => int => bool"
### is strictly less general than the declared type
### Occurrences of recursive constant have non-unifiable types
### Specification of constant HsHOL.hEq :: "'a list => 'a list => bool"
### is strictly less general than the declared type
Proving equations for primrec function(s) "HsHOL.hEq" ...
### Specification of constant HsHOL.hNEq :: "'a list => 'a list => bool"
### is strictly less general than the declared type
Loading theory "mrec_h"
structure Header :
  sig val initialize : string list -> unit val record : string -> unit end
val it = () : unit
Proofs for datatype(s) "Prelude_Natx"
Constructing representing sets ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the induction rule ...
Proving isomorphism properties ...
Proving freeness of constructors ...
Proving induction rule for datatypes ...
Proving case distinction theorems ...
Constructing primrec combinators ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
Proving termination and uniqueness of primrec functions ...
Proving characteristic theorems for primrec combinators ...
Proving characteristic theorems for case combinators ...
Proving equations for case splitting ...
Proving additional theorems for TFL ...
Proving equations for size function ...
Proving equations for primrec function(s) "mrec_h.fun1_Xfun2_X" ...
val it = () : unit
val it = () : unit
val it =
   {ProtoPure, Pure, CPure, HOL, Lattice_Locales, Orderings, LOrder, Set,
     Typedef, Fun, Product_Type, FixedPoint, Sum_Type, Relation, Record,
     Inductive, Transitive_Closure, Wellfounded_Recursion, OrderedGroup,
     Ring_and_Field, Nat, NatArith, Datatype_Universe, Datatype, Divides,
     Power, Finite_Set, Wellfounded_Relations, Equiv_Relations, IntDef,
     Numeral, IntArith, SetInterval, Recdef, IntDiv, NatBin, NatSimprocs,
     Presburger, Relation_Power, Parity, GCD, Binomial, PreList, List, Map,
     Refute, SAT, Hilbert_Choice, Infinite_Set, Extraction, Reconstruction,
     Main, HsHOL, mrec_h} : Theory.theory
val it =
   [("mrec_h.fun1_def", "fun1 == %x. fst (fun1_Xfun2_X x)"),
      ("mrec_h.fun2_def", "fun2 == %x. snd (fun1_Xfun2_X x)"),
      ("mrec_h.Prelude_Natx.Sx_def",
         "Sx ?x2.0 ?x1.0 ==
            Abs_Prelude_Natx
             (In1
               (Scons (??.Datatype_Universe.Leaf ?x2.0)
                 (Rep_Prelude_Natx ?x1.0)))"),
      ("mrec_h.Prelude_Natx.Zx_def",
         "Zx == Abs_Prelude_Natx (In0 arbitrary)"),
      ("mrec_h.type_definition_Prelude_Natx",
         "EX x. x : Prelude_Natx_rep_set
            ==> type_definition Rep_Prelude_Natx Abs_Prelude_Natx
             Prelude_Natx_rep_set"),
      ("mrec_h.Prelude_Natx.Prelude_Natx_rec_def",
         "Prelude_Natx_rec ?f1.0 ?f2.0 ==
            %x. THE y. (x, y) : Prelude_Natx_rec_set ?f1.0 ?f2.0"),
      ("mrec_h.Prelude_Natx.Prelude_Natx_case_def",
         "Prelude_Natx_case ?f1.0 ?f2.0 ==
            Prelude_Natx_rec ?f1.0 (%x1 x2 x3. ?f2.0 x1 x2)"),
      ("mrec_h.Prelude_Natx.Prelude_Natx_size_def",
         "size == Prelude_Natx_rec 0 (%x xa xb. xb + Suc 0)"),
      ("mrec_h.Prelude_Natx.Prelude_Natx_rec_set.defs_1",
         "Prelude_Natx_rec_set ?f1.0 ?f2.0 ==
            lfp
             (%S.
                 {x.
                  x = (Zx, ?f1.0) |
                  (EX x1 x2 y1.
                      x = (Sx x2 x1, ?f2.0 x2 x1 y1) & (x1, y1) : S)})"),
      ("mrec_h.Prelude_Natx.Prelude_Natx_rep_set.defs_1",
         "Prelude_Natx_rep_set ==
            lfp
             (%S.
                 {x.
                  x = In0 arbitrary |
                  (EX x1 x2.
                      x = In1 (Scons (??.Datatype_Universe.Leaf x2) x1) &
                      x1 : S)})"),
      ("mrec_h.fun1_Xfun2_X.fun1_Xfun2_X_Prelude_Natx_def",
         "fun1_Xfun2_X ==
            Prelude_Natx_rec ((Zx, 0), 0)
             (%pX1 pX2 pX2a.
                 ((Sx pX1 (fst (fst pX2a)), pX1 * snd pX2a),
                  snd (fst pX2a) + pX1))")] : (string * Thm.thm) list
Poly/ML RTS version I386-4.1.4 (14:18:30 Nov 14 2005)
Copyright (c) 2002-5 CUTS and contributors.
Running with heap parameters (h=30000K,ib=6000K,ip=100%,mb=10096K,mp=20%)
Mapping /local/mirror/linux-bkb/Isabelle/Isabelle2005/heaps/polyml-4.1.4_x86-linux/HOL
Mapping /home/linux-bkb/Isabelle/polyml-4.1.4/x86-linux/ML_dbase
Poly/ML 4.2.0 Release
> val it = () : unit
Loading theory "HsHOL" (required by "wcard_h")
### Specification of constant HsHOL.hEq :: "bool => bool => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hNEq :: "bool => bool => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hEq :: "int => int => bool"
### is strictly less general than the declared type
### Specification of constant HsHOL.hNEq :: "int => int => bool"
### is strictly less general than the declared type
### Occurrences of recursive constant have non-unifiable types
### Specification of constant HsHOL.hEq :: "'a list => 'a list => bool"
### is strictly less general than the declared type
Proving equations for primrec function(s) "HsHOL.hEq" ...
### Specification of constant HsHOL.hNEq :: "'a list => 'a list => bool"
### is strictly less general than the declared type
Loading theory "wcard_h"
structure Header :
  sig val initialize : string list -> unit val record : string -> unit end
val it = () : unit
Proofs for datatype(s) "Prelude_Boolx"
Constructing representing sets ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the induction rule ...
Proving isomorphism properties ...
Proving freeness of constructors ...
Proving induction rule for datatypes ...
Proving case distinction theorems ...
Constructing primrec combinators ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
Proving termination and uniqueness of primrec functions ...
Proving characteristic theorems for primrec combinators ...
Proving characteristic theorems for case combinators ...
Proving equations for case splitting ...
Proving additional theorems for TFL ...
Proving equations for size function ...
Proofs for datatype(s) "Prelude_Natx"
Constructing representing sets ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the induction rule ...
Proving isomorphism properties ...
Proving freeness of constructors ...
Proving induction rule for datatypes ...
Proving case distinction theorems ...
Constructing primrec combinators ...
  Proving monotonicity ...
  Proving the introduction rules ...
  Proving the elimination rules ...
Proving termination and uniqueness of primrec functions ...
Proving characteristic theorems for primrec combinators ...
Proving characteristic theorems for case combinators ...
Proving equations for case splitting ...
Proving additional theorems for TFL ...
Proving equations for size function ...
### Interactive-only command "sorry" (line 15 of "/home/maeder/haskell/HetCATS/Haskell/test/HOL/wcard_h.thy")
*** Proof may be skipped in quick_and_dirty mode only!
*** At command "sorry" (line 15 of "/home/maeder/haskell/HetCATS/Haskell/test/HOL/wcard_h.thy").
Exception- ERROR raised
val it = () : unit
val it =
   {ProtoPure, Pure, CPure, HOL, Lattice_Locales, Orderings, LOrder, Set,
     Typedef, Fun, Product_Type, FixedPoint, Sum_Type, Relation, Record,
     Inductive, Transitive_Closure, Wellfounded_Recursion, OrderedGroup,
     Ring_and_Field, Nat, NatArith, Datatype_Universe, Datatype, Divides,
     Power, Finite_Set, Wellfounded_Relations, Equiv_Relations, IntDef,
     Numeral, IntArith, SetInterval, Recdef, IntDiv, NatBin, NatSimprocs,
     Presburger, Relation_Power, Parity, GCD, Binomial, PreList, List, Map,
     Refute, SAT, Hilbert_Choice, Infinite_Set, Extraction, Reconstruction,
     Main, HsHOL, #} : Theory.theory
val it = [] : (string * Thm.thm) list
