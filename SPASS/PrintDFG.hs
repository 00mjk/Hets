{- |
Module      :  $Header$
Description :  Pretty printing for SPASS signatures.
Copyright   :  (c) Rene Wagner, Uni Bremen 2005
License     :  similar to LGPL, see HetCATS/LICENSE.txt or LIZENZ.txt

Maintainer  :  luettich@tzi.de
Stability   :  provisional
Portability :  unknown

stable pretty printing for SPASS signatures. This stuff is sent off to
the prover and saved from the GUI.

   Refer to <http://spass.mpi-sb.mpg.de/webspass/help/syntax/dfgsyntax.html>
   for the SPASS syntax documentation.

-}

module SPASS.PrintDFG where

import Maybe

import Common.AS_Annotation
import Common.GlobalAnnotations
import Common.Lib.Pretty
import Common.PrettyPrint

import SPASS.Sign
import SPASS.Conversions

-- | This type class allows pretty printing in DFG syntax of instantiated data
--   types
class PrintDFG a where
    printDFG :: a -> Doc

instance PrintDFG Sign where
  printDFG = printDFG . signToSPLogicalPart

{- |
  Helper function. Generates a '.' as a Doc.
-}
dot :: Doc
dot = char '.'

endOfListS :: String
endOfListS = "end_of_list."

{- |
  Creates a Doc from a SPASS Problem.
-}
instance PrintDFG SPProblem where
  printDFG p = text "begin_problem" <> parens (text (identifier p)) <> dot
    $$ printDFG (description p)
    $$ printDFG (logicalPart p)
    $$ printSettings (settings p)
    $$ text "end_problem."

{- |
  Creates a Doc from a SPASS Logical Part.
-}
instance PrintDFG SPLogicalPart where
  printDFG lp =
    (if isJust (symbolList lp) then printDFG (fromJust (symbolList lp)) else empty)
    $$ (if not $ null (declarationList lp) then printDeclarationList (declarationList lp) else empty)
    $$ (if not $ null (formulaLists lp) then printFormulaLists (formulaLists lp) else empty)
    where
      printDeclarationList xs = text "list_of_declarations."
        $$ foldl (\d x-> d $$ printDFG x) empty xs
        $$ text endOfListS
      printFormulaLists = foldl (\d x-> d $$ printDFG x) empty

{- |
  Creates a Doc from a SPASS Symbol List.
-}
instance PrintDFG SPSymbolList where
  printDFG sl = text "list_of_symbols."
    $$ printSignSymList "functions" (functions sl)
    $$ printSignSymList "predicates" (predicates sl)
    $$ printSignSymList "sorts" (sorts sl)
    $$ printSignSymList "operators" (operators sl)
    $$ printSignSymList "quantifiers" (quantifiers sl)
    $$ text endOfListS
    where 
      printSignSymList lname list =
        if not $ null list
          then text lname <> brackets (foldl (\d x-> if isEmpty d then printDFG x else d <> comma $$ printDFG x) empty list) <> dot
          else empty

{-|
  Helper function. Creates a Doc from a Signature Symbol.
-}
instance PrintDFG SPSignSym where
  printDFG (SPSimpleSignSym s) = text s
  printDFG ssym = parens (text (sym ssym) <> comma <> int (arity ssym))

{- |
  Creates a Doc from a SPASS Declaration
-}
instance PrintDFG SPDeclaration where
  printDFG d = case d of
    SPSubsortDecl {sortSymA= a, sortSymB= b} ->
      text "subsort" <> parens (text a <> comma <> text b) <> dot
    SPTermDecl {termDeclTermList= l, termDeclTerm= t} ->
      printDFG (SPQuantTerm {quantSym= SPForall, variableList= l, qFormula= t}) <> dot
    SPSimpleTermDecl t ->
      printDFG t <> dot
    SPPredDecl {predSym= p, sortSyms= slist} ->
      printDFG (SPComplexTerm {symbol= (SPCustomSymbol "predicate"), arguments= (map (\x-> SPSimpleTerm (SPCustomSymbol x)) (p:slist))}) <> dot
    SPGenDecl {sortSym= s, freelyGenerated= freelygen, funcList= l} ->
      text "sort" <+> text s <+> (if freelygen then text "freely" else empty) <+> text "generated by" <+> brackets (printFuncList l) <> dot
    where
      printFuncList = foldl (\fl x-> if isEmpty fl then text x else fl <> comma <> text x) empty

{- |
  Creates a Common.Lib.Pretty.Doc from a SPASS Formula List
-}
instance PrintDFG SPFormulaList where
  printDFG l = text "list_of_formulae" <> parens (printDFG (originType l)) <> dot
    $$ printFormulae (formulae l)
    $$ text endOfListS
    where
      printFormulae = foldl (\fl x-> fl $$ printFormula x <> dot) empty

{- |
  Creates a Doc from a SPASS Origin Type
-}
instance PrintDFG SPOriginType where
  printDFG t = case t of
    SPOriginAxioms      -> text "axioms"
    SPOriginConjectures -> text "conjectures"

{- |
  Creates a Doc from a SPASS Formula. Needed since SPFormula is just a
  'type SPFormula = Named SPTerm' and thus instanciating PrintDFG is not
  possible.
-}
printFormula :: SPFormula-> Doc
printFormula f =
  text "formula" <> parens (printDFG (sentence f) <> comma <> 
                            text (senName f))

{- |
  Creates a Doc from a SPASS Term.
-}
instance PrintDFG SPTerm where
  printDFG t = case t of
    SPQuantTerm{quantSym= qsym, variableList= tlist, qFormula= tt} -> printDFG qsym <> parens (brackets (printTermList tlist) <> comma <> printDFG tt)
    SPSimpleTerm stsym -> printDFG stsym
    SPComplexTerm{symbol= ctsym, arguments= args} -> printDFG ctsym <> if null args then empty else parens (printTermList args)
    where
      printTermList = foldl (\tl x-> if isEmpty tl then printDFG x else tl <> comma <> (printDFG x)) empty

{- |
  Creates a Doc from a SPASS Quantifier Symbol.
-}
instance PrintDFG SPQuantSym where
  printDFG qs = case qs of
    SPForall             -> text "forall"
    SPExists             -> text "exists"
    SPCustomQuantSym cst -> text cst

{- |
  Creates a Doc from a SPASS Symbol.
-}
-- printSymbol :: SPSymbol-> Doc
instance PrintDFG SPSymbol where
    printDFG s = case s of
     SPEqual            -> text "equal"
     SPTrue             -> text "true"
     SPFalse            -> text "false"
     SPOr               -> text "or"
     SPAnd              -> text "and"
     SPNot              -> text "not"
     SPImplies          -> text "implies"
     SPImplied          -> text "implied"
     SPEquiv            -> text "equiv"
     SPCustomSymbol cst -> text cst

{- |
  Creates a Doc from a SPASS description.
-}
instance PrintDFG SPDescription where
  printDFG d = text "list_of_descriptions."
    $$ text "name" <> parens (spText (name d)) <> dot
    $$ text "author" <> parens (spText (author d)) <> dot
    $$ (if isJust (version d) then text "version" <> parens (spText (fromJust (version d))) <> dot else empty)
    $$ (if isJust (logic d) then text "logic" <> parens (spText (fromJust (logic d))) <> dot else empty)
    $$ text "status" <> parens (printDFG (status d)) <> dot
    $$ text "description" <> parens (spText (desc d)) <> dot
    $$ (if isJust (date d) then text "date" <> parens (spText (fromJust (date d))) <> dot else empty)
    $$ text endOfListS

{- |
  Helper function. Wraps a String in "{*  *}" as required for some of the
  description fields.
-}
spText :: String-> Doc
spText s = textBraces $ text s

{- |
  surrounds  a doc with "{*  *}" as required for some of the
  description fields and the settings.
-}
textBraces :: Doc -> Doc
textBraces d = text "{* " <> d <> text " *}"


{- |
  Creates a Doc from an 'SPLogState'.
-}
instance PrintDFG SPLogState where
  printDFG s = case s of
    SPStateSatisfiable   -> text "satisfiable"
    SPStateUnsatisfiable -> text "unsatisfiable"
    SPStateUnknown       -> text "unknown"

printSettings :: [SPSetting] -> Doc
printSettings [] = empty
printSettings l = 
    text "list_of_settings(SPASS)." $$
    textBraces (vcat (map (printDFG) l)) $$
    text endOfListS

instance PrintDFG SPSetting where
    printDFG (SPFlag sw v) = 
        text "set_flag"<>parens(text sw<>comma<>text v)<>dot
