\documentclass[11pt,a4paper]{article}

\usepackage{german}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{moreverb}
\usepackage[latin1]{inputenc}   % Unterstuetzen von deutschen Umlauten

% gieza bigger page
\setlength{\textwidth}{16cm}
\setlength{\topmargin}{-1cm}
\setlength{\evensidemargin}{0cm}
\setlength{\oddsidemargin}{0cm}
\setlength{\textheight}{24cm}

% skip between paragraphs
\setlength{\parskip}{1ex}
% ... and no indentation at start of a new paragraph
\setlength{\parindent}{0ex}

\pagestyle{plain}
\thispagestyle{plain}
\begin{document}

\title{A roadmap for the implementation of an OWL-DL logic}
\author{Klaus L"uttich, Heng Jiang}
\maketitle

%\tableofcontents

\section{General Ideas}

\subsection{parsing and analysis}
parsing and first analysis is done in JAVA
   \subsubsection{Used libraries}
   all used Java-libraries are from the tools Pellet 1.1.0:
   \begin{itemize}
   \item pellet-1.1.0/lib/aterm-java-1.6.jar
   \item pellet-1.1.0/lib/log4j-1.2.7.jar
   \item pellet-1.1.0/lib/pellet.jar
   \item pellet-1.1.0/lib/econn-owlapi/abstractparser.jar
   \item pellet-1.1.0/lib/econn-owlapi/impl.jar
   \item pellet-1.1.0/lib/econn-owlapi/io.jar  
   \item pellet-1.1.0/lib/econn-owlapi/rdfparser.jar
   \item pellet-1.1.0/lib/econn-owlapi/validation.jar
   \item pellet-1.1.0/lib/junit-3.8.1/junit.jar
   \end{itemize}
In it nothing will become changed, the implementation however some new classes produced, by which the old classes are replaced:
   \begin{itemize}
      \item OWL2ATermLoader instead PelletLoader;
   	  \item OWL2ATermVisitor instead PelletVisitor;
      \item RenderingVisitor2 instead RenderingVisitor
   \end{itemize}

\subsubsection{Class interpreting}
\textbf{\emph{OWL2ATermLoader} }and \textbf{\emph{OWL2ATermVisitor}} are the classes as interfaces, with which main class (\textbf{\emph{OWL2ATerm}}) with the Visitor and Render (concrete output classes: \textbf{\emph{ATermRender2}}) can be connected. With OWL2ATermLoader can still administered the KnowledgeBasis, which gets the original PelletLoader of OWL Parser.\\
   
\textbf{\emph{ATermRender2}} and \textbf{\emph{RenderingVisitor2}} are the major output classes in this implementation.\\

All class-, property and individual data structures are developed in \textbf{\emph{ATermRender2}}.  Since such data struktures with many parameters and is very complicated (for example, Class has 5 parameters, whereby Description is still another data strukture, which must be unwrapped and represented as a list), the result of the OWL Parsers is not directly to be used, but must be first analyzed here, at the end output a ATerm, which is based structurally on the abstract syntax of Haskell.\\

RenderingVisitor2 is here an assistance class of the expenditures to design only the simple ClassID and Restrictions in addition class-, property- and individual- axioms.  Because Restriction and axiom need only ID (not concrete data structure) as parameters, only those are converted to need URI to it.  The different axioms are dependent on the KnowledgeBasis, which in this class however not at all produced or changed, but already one specifies in OWL2ATerm.\\

\textbf{\emph{OWL2ATerm}} is the main class, in which the OWLParser is called.  All output messages of the Parser are collected by a assistance class \textbf{\emph{OWLATReporter}} and stored into a MessageList.  The messages are divided in 3 parts:
	\begin{itemize}
		\item Level: OWL-\{Lite, DL, Full\}.
		\item Type of Message.
		\item content of message.
	\end{itemize} 
Afterwards Parser errors and warnings behind the messages are inserted also in the message list. \\
The method "'owlParserOutput"' builds all necessary information up from the Parser, and spends at the end an entire ATerm formula (OWLParserOutput(validation, messages, name spaces, ontology)):
	\begin{itemize}
		\item validation: OWL-\{Lite, DL, Full\}.
		\item messages: all messages from OWL parser incl. parser errors and warnings.
		\item namespaces: here namespaces are stored also as some of the output.  Thus all URI can be developed late in Haskell with suitable namespaces.
		\item ontology: main part of the result ATerm, therein all classes, properties, individuals and axioms are output.
	\end{itemize} 
   With the above implementation all output ATerm is developed so near by the abstract syntax by OWL\_DL, which is builded in Haskell, that later very simply to the Haskell abstract syntax converts becomes (see AS.hs and ATerm module of HETS)\\

   the JAVA output is an unshared ATerm-file.\\

   @Klaus: try to contact the person maintaining the JAVA-ATerm
   library and try to get a fix for the textual shared format writing
   bug. 

\subsection{Representation}
The ATerm represents the abstract syntax after reading all
   imports. It has a classification in OWL-{Lite,DL,Full} and the used
   XML-namespaces are saved. Mutual recursive (circular) imports are
   solved by integration of all information into one abstract syntax.

   @Heng: Circular imports need to be detected and yield a
   warning.
   
 \subsection{ ...}

\end{document}