
A roadmap for the implementation of an OWL-DL logic
===================================================

General Ideas:
--------------

 - parsing and first analysis is done in JAVA

   used libraries:

   @Heng please write down here which JAVA libraries you used and
   which modifications were neccessary.

   @Heng: Also document briefly what your own implementations do.

   the JAVA output is an unshared ATerm-file.

   @Klaus: try to contact the person maintaining the JAVA-ATerm
   library and try to get a fix for the textual shared format writing
   bug. 

 - The ATerm represents the abstract syntax after reading all
   imports. It has a classification in OWL-{Lite,DL,Full} and the used
   XML-namespaces are saved. Mutual recursive (circular) imports are
   solved by integration of all information into one abstract syntax.

   @Heng: Circular imports need to be detected and yield a
   warning.

 - The integrated abstract syntax will be devided into different
   theories if there are no circular imports. It maybe easier to leave
   them in one therory first. Maybe later a division can be added.
   We derive a development graph from the import structure of the 
   OWL-DL-files if there are no circular imports.

 - Static analysis of abstract syntax in Haskell within Hets
   
   (1) splitting of OWL-DL-IDs into namespace and local-name part
       with a disambiguation of IDs which have the same local-name
       part.

   (2) detection of circular imports and construction of import
       structure as graph, where the nodes are labeled with the same
       labels as in (3).

   (3) if there are no circular imports, divide the axioms into lists
       according to there originating files. These lists must be
       labeled with names derived from the ontology name/location.
       Otherwise all axioms stay in one list.

   (4) each list of axioms is now analysed. This process yields a
       theory (signature and sentences) foreach list of axioms labeled
       with each name. According to the import structure graph these
       theories form now a development graph. All signature morphisms
       are just inclusions where the source sign is a subset of the
       target sign.
       

Detailed Advices:
-----------------

Static Analysis of OWL DL Abstract Syntax

(all numbers refer to the overview in the previous section)

- splitting of (1) is done best during the conversion of the ATerm
  into the abstract syntax. For the *ID types in OWL_DL.AS the best
  data type is QName from Text.XML.HXT.DOM.XmlTreeTypes where also
  some useful functions on QName are defined.

- Disambiguation of (1) must be done in a second step, which must
  traverse the whole AS-tree. The traversal function (in its own
  class) needs a map as parameter which stores the mapping between
  original and disambiguated name. A disambiguated name can be formed
  either by adding a unique number as suffix or by adding the
  namePrefix string followed by an underscore as prefix.  In this step
  all QName entries can be updated with the namespaceURI part.
  The map will be saved later in a datastructure that is global to the
  development graph.

- @Klaus: to be continued. 