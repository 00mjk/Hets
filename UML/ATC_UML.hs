{-# OPTIONS -w -O0 #-}
{-# LANGUAGE CPP, StandaloneDeriving, DeriveDataTypeable #-}
{- |
Module      :  UML/ATC_UML.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI GmbH 2012
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(derive Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'UML.UML.Model'
'UML.UML.CM'
'UML.UML.ClassEntity'
'UML.UML.Package'
'UML.UML.AssociationClass'
'UML.UML.Class'
'UML.UML.Attribute'
'UML.UML.Procedure'
'UML.UML.Enum'
'UML.UML.Literal'
'UML.UML.Association'
'UML.UML.EndType'
'UML.UML.End'
'UML.UML.Interface'
'UML.UML.Label'
'UML.UML.Signal'
'UML.UML.UMLType'
'UML.UML.Type'
'UML.Sign.Sign'
'UML.Sign.MultForm'
'UML.Sign.FunExpr'
'UML.Sign.MFATTRIBUTE'
'UML.Sign.MFCOMPOSITION'
'UML.Sign.MFASSOCIATION'
'UML.Sign.MFTYPE'
'UML.Sign.Annot'
'UML.Sign.Sen'
-}

{-
Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
UML/UML.hs
UML/Sign.hs
-}

module UML.ATC_UML () where

import ATerm.Lib
import Prelude hiding (Enum)
import Common.ATerm.ConvInstances
import Common.Doc hiding (Label)
import Common.DocUtils
import Common.Id
import CommonLogic.AS_CommonLogic
import Data.Maybe
import Data.Typeable
import UML.Sign
import UML.StateMachine
import UML.UML
import UML.UML ()
import qualified Common.Id
import qualified Data.Map as Map


{-! for UML.UML.CM derive : Typeable !-}
{-! for UML.UML.ClassEntity derive : Typeable !-}
{-! for UML.UML.Package derive : Typeable !-}
{-! for UML.UML.AssociationClass derive : Typeable !-}
{-! for UML.UML.Class derive : Typeable !-}
{-! for UML.UML.Attribute derive : Typeable !-}
{-! for UML.UML.Procedure derive : Typeable !-}
{-! for UML.UML.Enum derive : Typeable !-}
{-! for UML.UML.Literal derive : Typeable !-}
{-! for UML.UML.Association derive : Typeable !-}
{-! for UML.UML.EndType derive : Typeable !-}
{-! for UML.UML.End derive : Typeable !-}
{-! for UML.UML.Interface derive : Typeable !-}
{-! for UML.UML.Label derive : Typeable !-}
{-! for UML.UML.Signal derive : Typeable !-}
{-! for UML.UML.UMLType derive : Typeable !-}
{-! for UML.UML.Type derive : Typeable !-}
{-! for UML.Sign.Sign derive : Typeable !-}
{-! for UML.Sign.MultForm derive : Typeable !-}
{-! for UML.Sign.FunExpr derive : Typeable !-}
{-! for UML.Sign.MFATTRIBUTE derive : Typeable !-}
{-! for UML.Sign.MFCOMPOSITION derive : Typeable !-}
{-! for UML.Sign.MFASSOCIATION derive : Typeable !-}
{-! for UML.Sign.MFTYPE derive : Typeable !-}
{-! for UML.Sign.Annot derive : Typeable !-}
{-! for UML.Sign.Sen derive : Typeable !-}


{-! for UML.UML.CM derive : ShATermConvertible !-}
{-! for UML.UML.ClassEntity derive : ShATermConvertible !-}
{-! for UML.UML.Package derive : ShATermConvertible !-}
{-! for UML.UML.AssociationClass derive : ShATermConvertible !-}
{-! for UML.UML.Class derive : ShATermConvertible !-}
{-! for UML.UML.Attribute derive : ShATermConvertible !-}
{-! for UML.UML.Procedure derive : ShATermConvertible !-}
{-! for UML.UML.Enum derive : ShATermConvertible !-}
{-! for UML.UML.Literal derive : ShATermConvertible !-}
{-! for UML.UML.Association derive : ShATermConvertible !-}
{-! for UML.UML.EndType derive : ShATermConvertible !-}
{-! for UML.UML.End derive : ShATermConvertible !-}
{-! for UML.UML.Interface derive : ShATermConvertible !-}
{-! for UML.UML.Label derive : ShATermConvertible !-}
{-! for UML.UML.Signal derive : ShATermConvertible !-}
{-! for UML.UML.UMLType derive : ShATermConvertible !-}
{-! for UML.UML.Type derive : ShATermConvertible !-}
{-! for UML.Sign.Sign derive : ShATermConvertible !-}
{-! for UML.Sign.MultForm derive : ShATermConvertible !-}
{-! for UML.Sign.FunExpr derive : ShATermConvertible !-}
{-! for UML.Sign.MFATTRIBUTE derive : ShATermConvertible !-}
{-! for UML.Sign.MFCOMPOSITION derive : ShATermConvertible !-}
{-! for UML.Sign.MFASSOCIATION derive : ShATermConvertible !-}
{-! for UML.Sign.MFTYPE derive : ShATermConvertible !-}
{-! for UML.Sign.Annot derive : ShATermConvertible !-}
{-! for UML.Sign.Sen derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

instance ShATermConvertible Sen where
  toShATermAux att0 xv = case xv of
    TEXT_META -> return $ addATerm (ShAAppl "TEXT_META" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TEXT_META" [] _ -> (att0, TEXT_META)
    u -> fromShATermError "Sen" u

instance ShATermConvertible Annot where
  toShATermAux att0 xv = case xv of
    OrderedSet -> return $ addATerm (ShAAppl "OrderedSet" [] []) att0
    Set -> return $ addATerm (ShAAppl "Set" [] []) att0
    Sequence -> return $ addATerm (ShAAppl "Sequence" [] []) att0
    Bag -> return $ addATerm (ShAAppl "Bag" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OrderedSet" [] _ -> (att0, OrderedSet)
    ShAAppl "Set" [] _ -> (att0, Set)
    ShAAppl "Sequence" [] _ -> (att0, Sequence)
    ShAAppl "Bag" [] _ -> (att0, Bag)
    u -> fromShATermError "Annot" u

instance ShATermConvertible MFTYPE where
  toShATermAux att0 xv = case xv of
    MFType a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "MFType" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "MFType" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, MFType a' b') }}
    u -> fromShATermError "MFTYPE" u

instance ShATermConvertible MFASSOCIATION where
  toShATermAux att0 xv = case xv of
    MFAssociation a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "MFAssociation" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "MFAssociation" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, MFAssociation a' b') }}
    u -> fromShATermError "MFASSOCIATION" u

instance ShATermConvertible MFCOMPOSITION where
  toShATermAux att0 xv = case xv of
    MFComposition a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "MFComposition" [a', b', c', d',
                                                  e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "MFComposition" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, MFComposition a' b' c' d' e') }}}}}
    u -> fromShATermError "MFCOMPOSITION" u

instance ShATermConvertible MFATTRIBUTE where
  toShATermAux att0 xv = case xv of
    MFAttribute a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "MFAttribute" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "MFAttribute" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, MFAttribute a' b' c') }}}
    u -> fromShATermError "MFATTRIBUTE" u

instance ShATermConvertible FunExpr where
  toShATermAux att0 xv = case xv of
    NumComp a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "NumComp" [a', b'] []) att2
    NumAss a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "NumAss" [a', b'] []) att2
    NumAttr a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "NumAttr" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "NumComp" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, NumComp a' b') }}
    ShAAppl "NumAss" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, NumAss a' b') }}
    ShAAppl "NumAttr" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, NumAttr a') }
    u -> fromShATermError "FunExpr" u

instance ShATermConvertible MultForm where
  toShATermAux att0 xv = case xv of
    NLeqF a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "NLeqF" [a', b'] []) att2
    FLeqN a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "FLeqN" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "NLeqF" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, NLeqF a' b') }}
    ShAAppl "FLeqN" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, FLeqN a' b') }}
    u -> fromShATermError "MultForm" u

instance ShATermConvertible Sign where
  toShATermAux att0 xv = case xv of
    Sign a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "Sign" [a', b', c', d', e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sign" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, Sign a' b' c' d' e') }}}}}
    u -> fromShATermError "Sign" u

deriving instance Typeable Sen

deriving instance Typeable Annot

deriving instance Typeable MFTYPE

deriving instance Typeable MFASSOCIATION

deriving instance Typeable MFCOMPOSITION

deriving instance Typeable MFATTRIBUTE

deriving instance Typeable FunExpr

deriving instance Typeable MultForm

deriving instance Typeable Sign

instance ShATermConvertible Type where
  toShATermAux att0 xv = case xv of
    Type a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Type" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Type" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Type a' b' c') }}}
    u -> fromShATermError "Type" u

instance ShATermConvertible UMLType where
  toShATermAux att0 xv = case xv of
    CE a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "CE" [a'] []) att1
    UMLString -> return $ addATerm (ShAAppl "UMLString" [] []) att0
    UMLInteger -> return $ addATerm (ShAAppl "UMLInteger" [] []) att0
    UMLBool -> return $ addATerm (ShAAppl "UMLBool" [] []) att0
    UMLUnlimitedNatural ->
      return $ addATerm (ShAAppl "UMLUnlimitedNatural" [] []) att0
    UMLReal -> return $ addATerm (ShAAppl "UMLReal" [] []) att0
    UMLSequence a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "UMLSequence" [a'] []) att1
    UMLSet a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "UMLSet" [a'] []) att1
    UMLOrderedSet a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "UMLOrderedSet" [a'] []) att1
    UMLBag a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "UMLBag" [a'] []) att1
    Other a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Other" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "CE" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, CE a') }
    ShAAppl "UMLString" [] _ -> (att0, UMLString)
    ShAAppl "UMLInteger" [] _ -> (att0, UMLInteger)
    ShAAppl "UMLBool" [] _ -> (att0, UMLBool)
    ShAAppl "UMLUnlimitedNatural" [] _ -> (att0, UMLUnlimitedNatural)
    ShAAppl "UMLReal" [] _ -> (att0, UMLReal)
    ShAAppl "UMLSequence" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, UMLSequence a') }
    ShAAppl "UMLSet" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, UMLSet a') }
    ShAAppl "UMLOrderedSet" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, UMLOrderedSet a') }
    ShAAppl "UMLBag" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, UMLBag a') }
    ShAAppl "Other" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Other a') }
    u -> fromShATermError "UMLType" u

instance ShATermConvertible Signal where
  toShATermAux att0 xv = case xv of
    Signal a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Signal" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Signal" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Signal a' b' c' d') }}}}
    u -> fromShATermError "Signal" u

instance ShATermConvertible Label where
  toShATermAux att0 xv = case xv of
    Label a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Label" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Label" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Label a' b') }}
    u -> fromShATermError "Label" u

instance ShATermConvertible Interface where
  toShATermAux att0 xv = case xv of
    Interface a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Interface" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Interface" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Interface a') }
    u -> fromShATermError "Interface" u

instance ShATermConvertible End where
  toShATermAux att0 xv = case xv of
    End a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "End" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "End" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, End a' b' c' d') }}}}
    u -> fromShATermError "End" u

instance ShATermConvertible EndType where
  toShATermAux att0 xv = case xv of
    Composition -> return $ addATerm (ShAAppl "Composition" [] []) att0
    Aggregation -> return $ addATerm (ShAAppl "Aggregation" [] []) att0
    Normal -> return $ addATerm (ShAAppl "Normal" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Composition" [] _ -> (att0, Composition)
    ShAAppl "Aggregation" [] _ -> (att0, Aggregation)
    ShAAppl "Normal" [] _ -> (att0, Normal)
    u -> fromShATermError "EndType" u

instance ShATermConvertible Association where
  toShATermAux att0 xv = case xv of
    Association a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Association" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Association" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Association a' b') }}
    u -> fromShATermError "Association" u

instance ShATermConvertible Literal where
  toShATermAux att0 xv = case xv of
    Literal a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Literal" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Literal" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Literal a' b') }}
    u -> fromShATermError "Literal" u

instance ShATermConvertible Enum where
  toShATermAux att0 xv = case xv of
    Enum a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Enum" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Enum" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Enum a' b') }}
    u -> fromShATermError "Enum" u

instance ShATermConvertible Procedure where
  toShATermAux att0 xv = case xv of
    Procedure a b c d e f -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      return $ addATerm (ShAAppl "Procedure" [a', b', c', d', e',
                                              f'] []) att6
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Procedure" [a, b, c, d, e, f] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      (att6, Procedure a' b' c' d' e' f') }}}}}}
    u -> fromShATermError "Procedure" u

instance ShATermConvertible Attribute where
  toShATermAux att0 xv = case xv of
    Attribute a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "Attribute" [a', b', c', d',
                                              e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Attribute" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, Attribute a' b' c' d' e') }}}}}
    u -> fromShATermError "Attribute" u

instance ShATermConvertible Class where
  toShATermAux att0 xv = case xv of
    Class a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Class" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Class" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Class a' b' c' d') }}}}
    u -> fromShATermError "Class" u

instance ShATermConvertible AssociationClass where
  toShATermAux att0 xv = case xv of
    AssociationClass a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "AssociationClass" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "AssociationClass" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, AssociationClass a' b') }}
    u -> fromShATermError "AssociationClass" u

instance ShATermConvertible Package where
  toShATermAux att0 xv = case xv of
    Package a b c d e f g h i -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      (att7, g') <- toShATerm' att6 g
      (att8, h') <- toShATerm' att7 h
      (att9, i') <- toShATerm' att8 i
      return $ addATerm (ShAAppl "Package" [a', b', c', d', e', f', g',
                                            h', i'] []) att9
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Package" [a, b, c, d, e, f, g, h, i] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      case fromShATerm' g att6 of
      { (att7, g') ->
      case fromShATerm' h att7 of
      { (att8, h') ->
      case fromShATerm' i att8 of
      { (att9, i') ->
      (att9, Package a' b' c' d' e' f' g' h' i') }}}}}}}}}
    u -> fromShATermError "Package" u

instance ShATermConvertible ClassEntity where
  toShATermAux att0 xv = case xv of
    CL a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "CL" [a'] []) att1
    AC a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "AC" [a'] []) att1
    EN a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "EN" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "CL" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, CL a') }
    ShAAppl "AC" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, AC a') }
    ShAAppl "EN" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, EN a') }
    u -> fromShATermError "ClassEntity" u

instance ShATermConvertible CM where
  toShATermAux att0 xv = case xv of
    CM a b c d e f g h i -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      (att7, g') <- toShATerm' att6 g
      (att8, h') <- toShATerm' att7 h
      (att9, i') <- toShATerm' att8 i
      return $ addATerm (ShAAppl "CM" [a', b', c', d', e', f', g', h',
                                       i'] []) att9
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "CM" [a, b, c, d, e, f, g, h, i] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      case fromShATerm' g att6 of
      { (att7, g') ->
      case fromShATerm' h att7 of
      { (att8, h') ->
      case fromShATerm' i att8 of
      { (att9, i') ->
      (att9, CM a' b' c' d' e' f' g' h' i') }}}}}}}}}
    u -> fromShATermError "CM" u

deriving instance Typeable Type

deriving instance Typeable UMLType

deriving instance Typeable Signal

deriving instance Typeable Label

deriving instance Typeable Interface

deriving instance Typeable End

deriving instance Typeable EndType

deriving instance Typeable Association

deriving instance Typeable Literal

deriving instance Typeable Enum

deriving instance Typeable Procedure

deriving instance Typeable Attribute

deriving instance Typeable Class

deriving instance Typeable AssociationClass

deriving instance Typeable Package

deriving instance Typeable ClassEntity

deriving instance Typeable CM
